---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x520_2001_SelectedAttributeTypes.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to resolve supertype MAPPING-BASED-MATCHING of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod selected_attribute_types {
    extern crate alloc;
    use super::directory_abstract_service::{
        FilterItem, HierarchySelections, SearchControlOptions, ServiceControlOptions,
    };
    use super::information_framework::*;
    use super::mtsabstract_service::G3FacsimileNonBasicParameters;
    use super::service_administration::{AttributeCombination, ContextCombination, MRMapping};
    use super::upper_bounds::{
        UB_ANSWERBACK, UB_BUSINESS_CATEGORY, UB_COMMON_NAME, UB_COUNTRY_CODE, UB_DESCRIPTION,
        UB_DESTINATION_INDICATOR, UB_DIRECTORY_STRING_FIRST_COMPONENT_MATCH,
        UB_INTERNATIONAL_ISDN_NUMBER, UB_KNOWLEDGE_INFORMATION, UB_LOCALE_CONTEXT_SYNTAX,
        UB_LOCALITY_NAME, UB_MATCH, UB_NAME, UB_ORGANIZATIONAL_UNIT_NAME, UB_ORGANIZATION_NAME,
        UB_PHYSICAL_OFFICE_NAME, UB_POSTAL_CODE, UB_POSTAL_LINE, UB_POSTAL_STRING,
        UB_POST_OFFICE_BOX, UB_PSEUDONYM, UB_SERIAL_NUMBER, UB_STATE_NAME, UB_STREET_ADDRESS,
        UB_SURNAME, UB_TELEPHONE_NUMBER, UB_TELETEX_TERMINAL_ID, UB_TELEX_NUMBER, UB_TITLE,
        UB_USER_PASSWORD, UB_X121_ADDRESS,
    };
    use super::useful_definitions::{
        DIRECTORY_ABSTRACT_SERVICE, ID_AT, ID_AVC, ID_CAT, ID_MR, ID_NOT, ID_PR,
        INFORMATION_FRAMEWORK, SERVICE_ADMINISTRATION, UPPER_BOUNDS,
    };
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    pub enum AnonymousCaseIgnoreList {
        teletexString(TeletexString),
        #[rasn(size("1.."))]
        printableString(PrintableString),
        #[rasn(size("1.."))]
        bmpString(BmpString),
        #[rasn(size("1.."))]
        universalString(UniversalString),
        uTF8String(Utf8String),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CaseIgnoreList(pub SequenceOf<AnonymousCaseIgnoreList>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CharacterMatchTypes {
        characterExact = 0,
        characterCaseIgnore = 1,
        characterMapped = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("2"))]
    pub struct CountryName(pub PrintableString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Criteria {
        #[rasn(tag(context, 0), identifier = "type")]
        R_type(CriteriaItem),
        #[rasn(tag(context, 1))]
        and(SetOf<Criteria>),
        #[rasn(tag(context, 2))]
        or(SetOf<Criteria>),
        #[rasn(tag(context, 3))]
        not(Box<Criteria>),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum CriteriaItem {
        #[rasn(tag(context, 0))]
        equality(AttributeType),
        #[rasn(tag(context, 1))]
        substrings(AttributeType),
        #[rasn(tag(context, 2))]
        greaterOrEqual(AttributeType),
        #[rasn(tag(context, 3))]
        lessOrEqual(AttributeType),
        #[rasn(tag(context, 4))]
        approximateMatch(AttributeType),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct DayTime {
        #[rasn(value("0..=23"), tag(context, 0))]
        pub hour: u8,
        #[rasn(value("0..=59"), tag(context, 1), default = "day_time_minute_default")]
        pub minute: u8,
        #[rasn(value("0..=59"), tag(context, 2), default = "day_time_second_default")]
        pub second: u8,
    }
    impl DayTime {
        pub fn new(hour: u8, minute: u8, second: u8) -> Self {
            Self {
                hour,
                minute,
                second,
            }
        }
    }
    fn day_time_minute_default() -> u8 {
        0
    }
    fn day_time_second_default() -> u8 {
        0
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct DayTimeBand {
        #[rasn(
            tag(context, 0),
            default = "day_time_band_start_day_time_default",
            identifier = "startDayTime"
        )]
        pub start_day_time: DayTime,
        #[rasn(
            tag(context, 1),
            default = "day_time_band_end_day_time_default",
            identifier = "endDayTime"
        )]
        pub end_day_time: DayTime,
    }
    impl DayTimeBand {
        pub fn new(start_day_time: DayTime, end_day_time: DayTime) -> Self {
            Self {
                start_day_time,
                end_day_time,
            }
        }
    }
    impl std::default::Default for DayTimeBand {
        fn default() -> Self {
            Self {
                start_day_time: day_time_band_start_day_time_default(),
                end_day_time: day_time_band_end_day_time_default(),
            }
        }
    }
    fn day_time_band_start_day_time_default() -> DayTime {
        DayTime(Oid::new(&[&***HOUR, &[0u32]].concat()).unwrap().to_owned())
    }
    fn day_time_band_end_day_time_default() -> DayTime {
        DayTime(DayTime::new(23, 59, 59))
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct DestinationIndicator(pub PrintableString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct EnhancedGuide {
        #[rasn(tag(context, 0), identifier = "objectClass")]
        pub object_class: Any,
        #[rasn(tag(context, 1))]
        pub criteria: Criteria,
        #[rasn(tag(context, 2), default = "enhanced_guide_subset_default")]
        pub subset: Integer,
    }
    impl EnhancedGuide {
        pub fn new(object_class: Any, criteria: Criteria, subset: Integer) -> Self {
            Self {
                object_class,
                criteria,
                subset,
            }
        }
    }
    fn enhanced_guide_subset_default() -> Integer {
        Integer::from(1)
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct FacsimileTelephoneNumber {
        #[rasn(identifier = "telephoneNumber")]
        pub telephone_number: TelephoneNumber,
        pub parameters: Option<G3FacsimileNonBasicParameters>,
    }
    impl FacsimileTelephoneNumber {
        pub fn new(
            telephone_number: TelephoneNumber,
            parameters: Option<G3FacsimileNonBasicParameters>,
        ) -> Self {
            Self {
                telephone_number,
                parameters,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct Guide {
        #[rasn(tag(context, 0), identifier = "objectClass")]
        pub object_class: Option<Any>,
        #[rasn(tag(context, 1))]
        pub criteria: Criteria,
    }
    impl Guide {
        pub fn new(object_class: Option<Any>, criteria: Criteria) -> Self {
            Self {
                object_class,
                criteria,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct InternationalISDNNumber(pub NumericString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("2..=3"))]
    pub struct LanguageContextSyntax(pub PrintableString);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum LocaleContextSyntaxLocaleID2 {
        teletexString(TeletexString),
        #[rasn(size("1.."))]
        printableString(PrintableString),
        #[rasn(size("1.."))]
        bmpString(BmpString),
        #[rasn(size("1.."))]
        universalString(UniversalString),
        uTF8String(Utf8String),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum LocaleContextSyntax {
        localeID1(ObjectIdentifier),
        localeID2(LocaleContextSyntaxLocaleID2),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MultipleMatchingLocalities {
        #[rasn(identifier = "matchingRuleUsed")]
        pub matching_rule_used: Option<Any>,
        #[rasn(identifier = "attributeList")]
        pub attribute_list: SequenceOf<AttributeValueAssertion>,
    }
    impl MultipleMatchingLocalities {
        pub fn new(
            matching_rule_used: Option<Any>,
            attribute_list: SequenceOf<AttributeValueAssertion>,
        ) -> Self {
            Self {
                matching_rule_used,
                attribute_list,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct NameAndOptionalUID {
        pub dn: DistinguishedName,
        pub uid: Option<UniqueIdentifier>,
    }
    impl NameAndOptionalUID {
        pub fn new(dn: DistinguishedName, uid: Option<UniqueIdentifier>) -> Self {
            Self { dn, uid }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum NamedDayIntNamedDays {
        sunday = 1,
        monday = 2,
        tuesday = 3,
        wednesday = 4,
        thursday = 5,
        friday = 6,
        saturday = 7,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum NamedDay {
        intNamedDays(NamedDayIntNamedDays),
        bitNamedDays(BitString),
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    pub enum AnonymousOctetSubstringAssertion {
        #[rasn(tag(context, 0))]
        initial(OctetString),
        #[rasn(tag(context, 1))]
        any(OctetString),
        #[rasn(tag(context, 2), identifier = "final")]
        R_final(OctetString),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OctetSubstringAssertion(pub SequenceOf<AnonymousOctetSubstringAssertion>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum PeriodDays {
        intDay(SetOf<Integer>),
        bitDay(BitString),
        dayOf(XDayOf),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum PeriodWeeks {
        allWeeks(()),
        intWeek(SetOf<Integer>),
        bitWeek(BitString),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum PeriodMonths {
        allMonths(()),
        intMonth(SetOf<Integer>),
        bitMonth(BitString),
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER", value("1000.."))]
    pub struct AnonymousPeriodYears(pub Integer);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PeriodYears(pub SetOf<AnonymousPeriodYears>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Period {
        #[rasn(size("1.."), tag(context, 0), identifier = "timesOfDay")]
        pub times_of_day: Option<SetOf<DayTimeBand>>,
        #[rasn(tag(context, 1))]
        pub days: Option<PeriodDays>,
        #[rasn(tag(context, 2))]
        pub weeks: Option<PeriodWeeks>,
        #[rasn(tag(context, 3))]
        pub months: Option<PeriodMonths>,
        #[rasn(tag(context, 4))]
        pub years: Option<PeriodYears>,
    }
    impl Period {
        pub fn new(
            times_of_day: Option<SetOf<DayTimeBand>>,
            days: Option<PeriodDays>,
            weeks: Option<PeriodWeeks>,
            months: Option<PeriodMonths>,
            years: Option<PeriodYears>,
        ) -> Self {
            Self {
                times_of_day,
                days,
                weeks,
                months,
                years,
            }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    pub enum AnonymousPostalAddress {
        teletexString(TeletexString),
        #[rasn(size("1.."))]
        printableString(PrintableString),
        #[rasn(size("1.."))]
        bmpString(BmpString),
        #[rasn(size("1.."))]
        universalString(UniversalString),
        uTF8String(Utf8String),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct PostalAddress(pub SequenceOf<AnonymousPostalAddress>);
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER")]
    pub struct AnonymousPreferredDeliveryMethod(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PreferredDeliveryMethod(pub SequenceOf<AnonymousPreferredDeliveryMethod>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct PresentationAddress {
        #[rasn(tag(context, 0), identifier = "pSelector")]
        pub p_selector: Option<OctetString>,
        #[rasn(tag(context, 1), identifier = "sSelector")]
        pub s_selector: Option<OctetString>,
        #[rasn(tag(context, 2), identifier = "tSelector")]
        pub t_selector: Option<OctetString>,
        #[rasn(size("1.."), tag(context, 3), identifier = "nAddresses")]
        pub n_addresses: SetOf<OctetString>,
    }
    impl PresentationAddress {
        pub fn new(
            p_selector: Option<OctetString>,
            s_selector: Option<OctetString>,
            t_selector: Option<OctetString>,
            n_addresses: SetOf<OctetString>,
        ) -> Self {
            Self {
                p_selector,
                s_selector,
                t_selector,
                n_addresses,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ProtocolInformation {
        #[rasn(identifier = "nAddress")]
        pub n_address: OctetString,
        pub profiles: SetOf<ObjectIdentifier>,
    }
    impl ProtocolInformation {
        pub fn new(n_address: OctetString, profiles: SetOf<ObjectIdentifier>) -> Self {
            Self {
                n_address,
                profiles,
            }
        }
    }
    #[doc = " defaulting to sequenceExact"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum SequenceMatchType {
        sequenceExact = 0,
        sequenceDeletion = 1,
        sequenceRestrictedDeletion = 2,
        sequencePermutation = 3,
        sequencePermutationAndDeletion = 4,
        sequenceProviderDefined = 5,
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AnonymousSubstringAssertionInitial {
        teletexString(TeletexString),
        #[rasn(size("1.."))]
        printableString(PrintableString),
        #[rasn(size("1.."))]
        bmpString(BmpString),
        #[rasn(size("1.."))]
        universalString(UniversalString),
        uTF8String(Utf8String),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AnonymousSubstringAssertionAny {
        teletexString(TeletexString),
        #[rasn(size("1.."))]
        printableString(PrintableString),
        #[rasn(size("1.."))]
        bmpString(BmpString),
        #[rasn(size("1.."))]
        universalString(UniversalString),
        uTF8String(Utf8String),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AnonymousSubstringAssertionFinal {
        teletexString(TeletexString),
        #[rasn(size("1.."))]
        printableString(PrintableString),
        #[rasn(size("1.."))]
        bmpString(BmpString),
        #[rasn(size("1.."))]
        universalString(UniversalString),
        uTF8String(Utf8String),
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    pub enum AnonymousSubstringAssertion {
        #[rasn(tag(context, 0))]
        initial(AnonymousSubstringAssertionInitial),
        #[rasn(tag(context, 1))]
        any(AnonymousSubstringAssertionAny),
        #[rasn(tag(context, 2), identifier = "final")]
        R_final(AnonymousSubstringAssertionFinal),
        control(Attribute),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SubstringAssertion(pub SequenceOf<AnonymousSubstringAssertion>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct TelephoneNumber(pub PrintableString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct TelexNumber {
        #[rasn(size("1.."), identifier = "telexNumber")]
        pub telex_number: PrintableString,
        #[rasn(size("1.."), identifier = "countryCode")]
        pub country_code: PrintableString,
        #[rasn(size("1.."))]
        pub answerback: PrintableString,
    }
    impl TelexNumber {
        pub fn new(
            telex_number: PrintableString,
            country_code: PrintableString,
            answerback: PrintableString,
        ) -> Self {
            Self {
                telex_number,
                country_code,
                answerback,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct TimeAssertionBetween {
        #[rasn(tag(context, 0), identifier = "startTime")]
        pub start_time: GeneralizedTime,
        #[rasn(tag(context, 1), identifier = "endTime")]
        pub end_time: Option<GeneralizedTime>,
        #[rasn(default = "time_assertion_between_entirely_default")]
        pub entirely: bool,
    }
    impl TimeAssertionBetween {
        pub fn new(
            start_time: GeneralizedTime,
            end_time: Option<GeneralizedTime>,
            entirely: bool,
        ) -> Self {
            Self {
                start_time,
                end_time,
                entirely,
            }
        }
    }
    fn time_assertion_between_entirely_default() -> bool {
        false
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum TimeAssertion {
        now(()),
        at(GeneralizedTime),
        between(TimeAssertionBetween),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct TimeSpecificationTimeAbsolute {
        #[rasn(tag(context, 0), identifier = "startTime")]
        pub start_time: Option<GeneralizedTime>,
        #[rasn(tag(context, 1), identifier = "endTime")]
        pub end_time: Option<GeneralizedTime>,
    }
    impl TimeSpecificationTimeAbsolute {
        pub fn new(start_time: Option<GeneralizedTime>, end_time: Option<GeneralizedTime>) -> Self {
            Self {
                start_time,
                end_time,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum TimeSpecificationTime {
        absolute(TimeSpecificationTimeAbsolute),
        periodic(SetOf<Period>),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct TimeSpecification {
        pub time: TimeSpecificationTime,
        #[rasn(
            default = "time_specification_not_this_time_default",
            identifier = "notThisTime"
        )]
        pub not_this_time: bool,
        #[rasn(identifier = "timeZone")]
        pub time_zone: Option<TimeZone>,
    }
    impl TimeSpecification {
        pub fn new(
            time: TimeSpecificationTime,
            not_this_time: bool,
            time_zone: Option<TimeZone>,
        ) -> Self {
            Self {
                time,
                not_this_time,
                time_zone,
            }
        }
    }
    fn time_specification_not_this_time_default() -> bool {
        false
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("-12..=12"))]
    pub struct TimeZone(pub i8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct UniqueIdentifier(pub BitString);
    #[doc = " defaulting to wordExact"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum WordMatchTypes {
        wordExact = 0,
        wordTruncated = 1,
        wordPhonetic = 2,
        wordProviderDefined = 3,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct X121Address(pub NumericString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum XDayOf {
        #[rasn(tag(context, 1))]
        first(NamedDay),
        #[rasn(tag(context, 2))]
        second(NamedDay),
        #[rasn(tag(context, 3))]
        third(NamedDay),
        #[rasn(tag(context, 4))]
        fourth(NamedDay),
        #[rasn(tag(context, 5))]
        fifth(NamedDay),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "ZONAL-MATCHING")]
    pub struct ZONALMATCHING(pub MAPPINGBASEDMATCHING);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ZonalResult {
        #[rasn(identifier = "cannot-select-mapping")]
        cannot_select_mapping = 0,
        #[rasn(identifier = "zero-mappings")]
        zero_mappings = 2,
        #[rasn(identifier = "multiple-mappings")]
        multiple_mappings = 3,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ZonalSelect(pub SequenceOf<AttributeType>);
    pub static ID_AT_BUSINESS_CATEGORY: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[15u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COLLECTIVE_FACSIMILE_TELEPHONE_NUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[23u32, 1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_COLLECTIVE_INTERNATIONAL_ISDNNUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[25u32, 1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_COLLECTIVE_LOCALITY_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[7u32, 1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COLLECTIVE_ORGANIZATION_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[10u32, 1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_COLLECTIVE_ORGANIZATIONAL_UNIT_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[11u32, 1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_COLLECTIVE_PHYSICAL_DELIVERY_OFFICE_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[19u32, 1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_COLLECTIVE_POST_OFFICE_BOX: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[18u32, 1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COLLECTIVE_POSTAL_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[16u32, 1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COLLECTIVE_POSTAL_CODE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[17u32, 1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COLLECTIVE_STATE_OR_PROVINCE_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[8u32, 1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_COLLECTIVE_STREET_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[9u32, 1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COLLECTIVE_TELEPHONE_NUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[20u32, 1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_COLLECTIVE_TELEX_NUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[21u32, 1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COMMON_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[3u32]].concat()).unwrap().to_owned());
    pub static ID_AT_COMMUNICATIONS_NETWORK: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[67u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COMMUNICATIONS_SERVICE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[66u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_COUNTRY_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[6u32]].concat()).unwrap().to_owned());
    pub static ID_AT_DESCRIPTION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[13u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_DESTINATION_INDICATOR: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[27u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_DISTINGUISHED_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[49u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_DMD_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[54u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_DN_QUALIFIER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[46u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " Object identifier assignments -"]
    #[doc = " object identifiers assigned in other modules are shown in comments"]
    #[doc = " Attributes"]
    #[doc = " id-at-objectClass\t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 0}"]
    #[doc = " id-at-aliasedEntryName\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 1}"]
    pub static ID_AT_ENCRYPTED_ALIASED_ENTRY_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-at-attributeCertificate\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 58}"]
    pub static ID_AT_ENCRYPTED_ATTRIBUTE_CERTIFICATE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[58u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-at-attributeCertificateRevocationList\t\tOBJECT IDENTIFIER\t::=\t{id-at 59}"]
    pub static ID_AT_ENCRYPTED_ATTRIBUTE_CERTIFICATE_REVOCATION_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[59u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-at-defaultDirQop\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 56}"]
    #[doc = " id-at-encryptedDefaultDirQop  \t\t\tOBJECT IDENTIFIER\t::=\t{id-at 56 2}"]
    #[doc = " id-at-attributeIntegrityInfo\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 57}"]
    pub static ID_AT_ENCRYPTED_ATTRIBUTE_INTEGRITY_INFO: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[57u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-at-authorityRevocationList\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 38}"]
    pub static ID_AT_ENCRYPTED_AUTHORITY_REVOCATION_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[38u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_BUSINESS_CATEGORY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[15u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-at-cACertificate\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 37}"]
    pub static ID_AT_ENCRYPTED_CACERTIFICATE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[37u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-certificateRevocationList\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 39}"]
    pub static ID_AT_ENCRYPTED_CERTIFICATE_REVOCATION_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[39u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-at-clearance   \t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 55}"]
    pub static ID_AT_ENCRYPTED_CLEARANCE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[55u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_FACSIMILE_TELEPHONE_NUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[23u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_INTERNATIONAL_ISDNNUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[25u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_LOCALITY_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[7u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_ORGANIZATION_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[10u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_ORGANIZATIONAL_UNIT_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[11u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_PHYSICAL_DELIVERY_OFFICE_NAME: LazyLock<
        ObjectIdentifier,
    > = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[19u32, 1u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_POST_OFFICE_BOX: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[18u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_POSTAL_ADDRESS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[16u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_POSTAL_CODE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[17u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_STATE_OR_PROVINCE_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[8u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_STREET_ADDRESS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[9u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_TELEPHONE_NUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[20u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COLLECTIVE_TELEX_NUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[21u32, 1u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_COMMON_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[3u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-confKeyInfo\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 60}"]
    pub static ID_AT_ENCRYPTED_CONF_KEY_INFO: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[60u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_COUNTRY_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[6u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-crossCertificatePair\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 40}"]
    pub static ID_AT_ENCRYPTED_CROSS_CERTIFICATE_PAIR: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[40u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-at-deltaRevocationList\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 53}"]
    pub static ID_AT_ENCRYPTED_DELTA_REVOCATION_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[53u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_DESCRIPTION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[13u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_DESTINATION_INDICATOR: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[27u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_DISTINGUISHED_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[49u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_DMD_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[54u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_DN_QUALIFIER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[46u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_ENHANCED_SEARCH_GUIDE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[47u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_FACSIMILE_TELEPHONE_NUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[23u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_GENERATION_QUALIFIER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[44u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_GIVEN_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[42u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_HOUSE_IDENTIFIER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[51u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_INITIALS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[43u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_INTERNATIONAL_ISDNNUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[25u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_LOCALITY_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[7u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_MEMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[31u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_ORGANIZATION_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[10u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_ORGANIZATIONAL_UNIT_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[11u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_OWNER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[32u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_PHYSICAL_DELIVERY_OFFICE_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[19u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_POST_OFFICE_BOX: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[18u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_POSTAL_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[16u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_POSTAL_CODE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[17u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_PREFERRED_DELIVERY_METHOD: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[28u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_PRESENTATION_ADDRESS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[29u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_PROTOCOL_INFORMATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[48u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_REGISTERED_ADDRESS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[26u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_ROLE_OCCUPANT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[33u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_SEARCH_GUIDE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[14u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_SEE_ALSO: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[34u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_SERIAL_NUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[5u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_STATE_OR_PROVINCE_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[8u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_STREET_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[9u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-supportedAlgorithms\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 52}"]
    pub static ID_AT_ENCRYPTED_SUPPORTED_ALGORITHMS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[52u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_SUPPORTED_APPLICATION_CONTEXT: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[30u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_SURNAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[4u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_TELEPHONE_NUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[20u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_TELEX_NUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[21u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_TITLE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[12u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_UNIQUE_IDENTIFIER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[45u32, 2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_ENCRYPTED_UNIQUE_MEMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[50u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-userCertificate\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 36}"]
    pub static ID_AT_ENCRYPTED_USER_CERTIFICATE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[36u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-userPassword\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 35}"]
    pub static ID_AT_ENCRYPTED_USER_PASSWORD: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[35u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENCRYPTED_X121_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[24u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ENHANCED_SEARCH_GUIDE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[47u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-teletexTerminalIdentifier  \t\t\tOBJECT IDENTIFIER\t::=\t{id-at 22}"]
    #[doc = " id-at-encryptedTeletexTerminalIdentifier\t\tOBJECT IDENTIFIER\t::=\t{id-at 22 2}"]
    #[doc = " id-at-collectiveTeletexTerminalIdentifier\t\tOBJECT IDENTIFIER\t::=\t{id-at 22 1}"]
    #[doc = " id-at-encryptedCollectiveTeletexTerminalIdentifier"]
    #[doc = "\t\t\t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 22 1 2}"]
    pub static ID_AT_FACSIMILE_TELEPHONE_NUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[23u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_GENERATION_QUALIFIER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[44u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_GIVEN_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[42u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_HOUSE_IDENTIFIER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[51u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_INITIALS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[43u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_INTERNATIONAL_ISDNNUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[25u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_KNOWLEDGE_INFORMATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[2u32]].concat()).unwrap().to_owned());
    pub static ID_AT_LOCALITY_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[7u32]].concat()).unwrap().to_owned());
    pub static ID_AT_MEMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[31u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[41u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ORGANIZATION_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[10u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ORGANIZATIONAL_UNIT_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[11u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_OWNER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[32u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_PHYSICAL_DELIVERY_OFFICE_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[19u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_POST_OFFICE_BOX: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[18u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_POSTAL_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[16u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_POSTAL_CODE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[17u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_PREFERRED_DELIVERY_METHOD: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[28u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_PRESENTATION_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[29u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_PROTOCOL_INFORMATION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[48u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-aACertificate\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 61}"]
    #[doc = " id-at-attributeDescriptorCertificate\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 62}"]
    #[doc = " id-at-attributeAuthorityRevocationList\t\tOBJECT IDENTIFIER\t::=\t{id-at 63}"]
    #[doc = " id-at-family-information\t\t\t\t\tOBJECT IDENTIFIER\t\t{id-at 64}"]
    pub static ID_AT_PSEUDONYM: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[65u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_REGISTERED_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[26u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_ROLE_OCCUPANT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[33u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_SEARCH_GUIDE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[14u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_SEE_ALSO: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[34u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_SERIAL_NUMBER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[5u32]].concat()).unwrap().to_owned());
    pub static ID_AT_STATE_OR_PROVINCE_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[8u32]].concat()).unwrap().to_owned());
    pub static ID_AT_STREET_ADDRESS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[9u32]].concat()).unwrap().to_owned());
    pub static ID_AT_SUPPORTED_APPLICATION_CONTEXT: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AT, &[30u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_AT_SURNAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[4u32]].concat()).unwrap().to_owned());
    pub static ID_AT_TELEPHONE_NUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[20u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_TELEX_NUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[21u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_TITLE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[12u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_UNIQUE_IDENTIFIER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[45u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_UNIQUE_MEMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[50u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AT_X121_ADDRESS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[24u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " contexts"]
    pub static ID_AVC_LANGUAGE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AVC, &[0u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AVC_LOCALE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AVC, &[2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AVC_TEMPORAL: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AVC, &[1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CAT_CHARACTER_MATCH_TYPES: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CAT, &[3u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CAT_SELECTED_CONTEXTS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CAT, &[4u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-at-certificationPracticeStmt\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 68}"]
    #[doc = " id-at-certificatePolicy\t\t\t\t\tOBJECT IDENTIFIER \t::=\t{id-at 69}"]
    #[doc = " id-at-pkiPath\t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 70}"]
    #[doc = " id-at-privPolicy\t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 71}"]
    #[doc = " id-at-role\t\t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 72}"]
    #[doc = " id-at-delegationPath\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 73}"]
    #[doc = " Control  attributes"]
    pub static ID_CAT_SEQUENCE_MATCH_TYPE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CAT, &[1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CAT_WORD_MATCH_TYPE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CAT, &[2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_APPROXIMATE_STRING_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[49u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_BIT_STRING_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[16u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_BOOLEAN_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[13u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_CASE_EXACT_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[5u32]].concat()).unwrap().to_owned());
    pub static ID_MR_CASE_EXACT_ORDERING_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[6u32]].concat()).unwrap().to_owned());
    pub static ID_MR_CASE_EXACT_SUBSTRINGS_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[7u32]].concat()).unwrap().to_owned());
    pub static ID_MR_CASE_IGNORE_LIST_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[11u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_CASE_IGNORE_LIST_SUBSTRINGS_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[12u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " Matching rules"]
    #[doc = " id-mr-objectIdentifierMatch \t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 0}"]
    #[doc = " id-mr-distinguishedNameMatch\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 1}"]
    pub static ID_MR_CASE_IGNORE_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[2u32]].concat()).unwrap().to_owned());
    pub static ID_MR_CASE_IGNORE_ORDERING_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[3u32]].concat()).unwrap().to_owned());
    pub static ID_MR_CASE_IGNORE_SUBSTRINGS_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[4u32]].concat()).unwrap().to_owned());
    pub static ID_MR_DIRECTORY_STRING_FIRST_COMPONENT_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[31u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-mr-authAttIdMatch\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 53}"]
    #[doc = " id-mr-roleSpecCertIdMatch\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 54}"]
    #[doc = " id-mr-basicAttConstraintsMatch\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 55}"]
    #[doc = " id-mr-delegatedNameConstraintsMatch\t\tOBJECT IDENTIFIER\t::=\t{id-mr 56}"]
    #[doc = " id-mr-timeSpecMatch\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 57}"]
    #[doc = " id-mr-attDescriptorMatch\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 58}"]
    #[doc = " id-mr-acceptableCertPoliciesMatch\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 59}"]
    #[doc = " id-mr-policyMatch\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 60}"]
    #[doc = " id-mr-delegationPathMatch\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 61}"]
    #[doc = " id-mr-pkiPathMatch\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 62}"]
    pub static ID_MR_FACSIMILE_NUMBER_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[63u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_FACSIMILE_NUMBER_SUBSTRINGS_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[64u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_GENERAL_WORD_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[48u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_GENERALIZED_TIME_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[27u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_GENERALIZED_TIME_ORDERING_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[28u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_IGNORE_IF_ABSENT_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[50u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_INTEGER_FIRST_COMPONENT_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[29u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_INTEGER_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[14u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_INTEGER_ORDERING_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[15u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_KEYWORD_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[33u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_NULL_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[51u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_NUMERIC_STRING_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[8u32]].concat()).unwrap().to_owned());
    pub static ID_MR_NUMERIC_STRING_ORDERING_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[9u32]].concat()).unwrap().to_owned());
    pub static ID_MR_NUMERIC_STRING_SUBSTRINGS_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[10u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_OBJECT_IDENTIFIER_FIRST_COMPONENT_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[30u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_OCTET_STRING_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[17u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_OCTET_STRING_ORDERING_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[18u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_OCTET_STRING_SUBSTRINGS_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[19u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_PRESENTATION_ADDRESS_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[22u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_PROTOCOL_INFORMATION_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[24u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-mr-certificateExactMatch\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 34}"]
    #[doc = " id-mr-certificateMatch\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 35}"]
    #[doc = " id-mr-certificatePairExactMatch\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 36}"]
    #[doc = " id-mr-certificatePairMatch\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 37}"]
    #[doc = " id-mr-certificateListExactMatch\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 38}"]
    #[doc = " id-mr-certificateListMatch\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 39}"]
    #[doc = " id-mr-algorithmIdentifierMatch\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 40}"]
    pub static ID_MR_STORED_PREFIX_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[41u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " id-mr-attributeCertificateMatch\t\t\tOBJECT IDENTIFIER \t::=\t{id-mr 42}"]
    #[doc = " id-mr-readerAndKeyIDMatch\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 43}"]
    #[doc = " id-mr-attributeIntegrityMatch\t\t\t\tOBJECT IDENTIFIER \t::=\t{id-mr 44} \tobsolete"]
    #[doc = " id-mr-attributeCertificateExactMatch\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 45}"]
    #[doc = " id-mr-holderIssuerMatch\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 46}"]
    pub static ID_MR_SYSTEM_PROPOSED_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[47u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_TELEPHONE_NUMBER_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[20u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_TELEPHONE_NUMBER_SUBSTRINGS_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[21u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_U_TCTIME_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[25u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_U_TCTIME_ORDERING_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[26u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_UNIQUE_MEMBER_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[23u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_WORD_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[32u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_ZONAL_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[52u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_APPLIED_RELAXATION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[15u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_ATTRIBUTE_COMBINATIONS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[6u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_ATTRIBUTE_TYPE_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[3u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_CONTEXT_COMBINATIONS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[9u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_CONTEXT_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[8u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_CONTEXT_TYPE_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[7u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " Notification attributes"]
    pub static ID_NOT_D_SAPROBLEM: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[0u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_FILTER_ITEM: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[5u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_HIERARCHY_SELECT_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[10u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_MATCHING_RULE_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[4u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_MULTIPLE_MATCHING_LOCALITIES: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_NOT, &[13u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_NOT_PROPOSED_RELAXATION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[14u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_SEARCH_CONTROL_OPTIONS_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_NOT, &[11u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_NOT_SEARCH_SERVICE_PROBLEM: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_NOT_SERVICE_CONTROL_OPTIONS_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_NOT, &[12u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_NOT_SERVICE_TYPE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NOT, &[2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_ADMINISTRATOR_IMPOSED_LIMIT: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[33u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_AMBIGUOUS_KEY_ATTRIBUTES: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[30u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_ATTRIBUTE_MATCHING_VIOLATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[20u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_ATTRIBUTE_NEGATION_VIOLATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[10u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_DATA_SOURCE_UNAVAILABLE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[2u32]].concat()).unwrap().to_owned());
    pub static ID_PR_EMPTY_HIERARCHY_SELECTION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[32u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_HIERARCHY_SELECT_FORBIDDEN: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[23u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_INVALID_CONTEXT_SEARCH_VALUE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[18u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_INVALID_HIERARCHY_SELECT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[24u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_INVALID_SEARCH_CONTROL_OPTIONS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[26u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_INVALID_SEARCH_VALUE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[12u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_INVALID_SERVICE_CONTROL_OPTIONS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[27u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_MATCHING_USE_VIOLATION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[22u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_MISSING_SEARCH_ATTRIBUTE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[8u32]].concat()).unwrap().to_owned());
    pub static ID_PR_MISSING_SEARCH_CONTEXT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[15u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_PERMANENT_RESTRICTION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[34u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_RELAXATION_NOT_SUPPORTED: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[36u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_SEARCH_ATTRIBUTE_COMBINATION_VIOLATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[6u32]].concat()).unwrap().to_owned());
    pub static ID_PR_SEARCH_ATTRIBUTE_VIOLATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[5u32]].concat()).unwrap().to_owned());
    pub static ID_PR_SEARCH_CONTEXT_COMBINATION_VIOLATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[14u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_SEARCH_CONTEXT_VALUE_REQUIRED: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[17u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_SEARCH_CONTEXT_VALUE_VIOLATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[16u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_SEARCH_CONTEXT_VIOLATION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[13u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_SEARCH_SUBSET_VIOLATION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[28u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_SEARCH_VALUE_NOT_ALLOWED: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[7u32]].concat()).unwrap().to_owned());
    pub static ID_PR_SEARCH_VALUE_REQUIRED: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[11u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_SEARCH_VALUE_VIOLATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[9u32]].concat()).unwrap().to_owned());
    #[doc = " Problem definitions"]
    pub static ID_PR_TARGET_DSA_UNAVAILABLE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_PR_TEMPORARY_RESTRICTION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[35u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_UNAVAILABLE_HIERARCHY_SELECT: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[25u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_UNAVAILABLE_OPERATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[4u32]].concat()).unwrap().to_owned());
    pub static ID_PR_UNAVAILABLE_RELAXATION_LEVEL: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_PR, &[31u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_PR_UNIDENTIFIED_OPERATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_PR, &[3u32]].concat()).unwrap().to_owned());
    pub static ID_PR_UNMATCHED_KEY_ATTRIBUTES: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[29u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_UNSUPPORTED_MATCHING_RULE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[19u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_PR_UNSUPPORTED_MATCHING_USE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_PR, &[21u32]].concat())
            .unwrap()
            .to_owned()
    });
}
