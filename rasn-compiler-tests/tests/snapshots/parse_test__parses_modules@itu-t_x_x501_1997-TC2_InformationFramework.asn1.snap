---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x501_1997-TC2_InformationFramework.asn1
---
Warnings:
Unidentified generating bindings for : Unexpectedly encountered unlinked struct-like ASN1 value!
Unidentified generating bindings for : Unexpectedly encountered unlinked struct-like ASN1 value!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
SyntaxMismatch in ASN grammar: Syntax mismatch while resolving information object.
SyntaxMismatch in ASN grammar: Syntax mismatch while resolving information object.
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
SyntaxMismatch in ASN grammar: Syntax mismatch while resolving information object.
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
LinkerError in ASN grammar: Failed to resolve supertype DirectoryString of parameterized implementation.
LinkerError in ASN grammar: No value for field mapping found!
LinkerError in ASN grammar: Failed to link value with 'ServiceControlOptions'


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod information_framework {
    extern crate alloc;
    use super::directory_abstract_service::{
        FamilyGrouping, FamilyReturn, HierarchySelections, SearchControlOptions,
        ServiceControlOptions, TypeAndContextAssertion,
    };
    use super::selected_attribute_types::{
        DirectoryString, BOOLEAN_MATCH, COMMON_NAME, GENERALIZED_TIME_MATCH,
        GENERALIZED_TIME_ORDERING_MATCH, INTEGER_FIRST_COMPONENT_MATCH, INTEGER_MATCH,
        INTEGER_ORDERING_MATCH, OBJECT_IDENTIFIER_FIRST_COMPONENT_MATCH,
    };
    use super::upper_bounds::UB_SEARCH;
    use super::useful_definitions::{
        DIRECTORY_ABSTRACT_SERVICE, ID_AR, ID_AT, ID_MR, ID_NF, ID_OA, ID_OC, ID_SC,
        SELECTED_ATTRIBUTE_TYPES, UPPER_BOUNDS,
    };
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AllowedSubset(pub BitString);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$ATTRIBUTE$&Type")]
    pub struct AnonymousAttributeValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeValues(pub SetOf<AnonymousAttributeValues>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousAttributeValuesWithContext {
        pub value: Any,
        #[rasn(size("1.."), identifier = "contextList")]
        pub context_list: SetOf<Context>,
    }
    impl AnonymousAttributeValuesWithContext {
        pub fn new(value: Any, context_list: SetOf<Context>) -> Self {
            Self {
                value,
                context_list,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct AttributeValuesWithContext(pub SetOf<AnonymousAttributeValuesWithContext>);
    #[doc = " attribute data types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Attribute {
        #[rasn(identifier = "type")]
        pub r_type: ObjectIdentifier,
        pub values: AttributeValues,
        #[rasn(identifier = "valuesWithContext")]
        pub values_with_context: Option<AttributeValuesWithContext>,
    }
    impl Attribute {
        pub fn new(
            r_type: ObjectIdentifier,
            values: AttributeValues,
            values_with_context: Option<AttributeValuesWithContext>,
        ) -> Self {
            Self {
                r_type,
                values,
                values_with_context,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AttributeCombination {
        #[rasn(tag(context, 0))]
        attribute(AttributeType),
        #[rasn(tag(context, 1))]
        and(SequenceOf<AttributeCombination>),
        #[rasn(tag(context, 2))]
        or(SequenceOf<AttributeCombination>),
        #[rasn(tag(context, 3))]
        not(Box<AttributeCombination>),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeType(pub ObjectIdentifier);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousAttributeTypeAndDistinguishedValueValuesWithContext {
        #[rasn(tag(context, 0), identifier = "distingAttrValue")]
        pub disting_attr_value: Option<Any>,
        #[rasn(size("1.."), identifier = "contextList")]
        pub context_list: SetOf<Context>,
    }
    impl AnonymousAttributeTypeAndDistinguishedValueValuesWithContext {
        pub fn new(disting_attr_value: Option<Any>, context_list: SetOf<Context>) -> Self {
            Self {
                disting_attr_value,
                context_list,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct AttributeTypeAndDistinguishedValueValuesWithContext(
        pub SetOf<AnonymousAttributeTypeAndDistinguishedValueValuesWithContext>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct AttributeTypeAndDistinguishedValue {
        #[rasn(identifier = "type")]
        pub r_type: ObjectIdentifier,
        pub value: Any,
        #[rasn(
            default = "attribute_type_and_distinguished_value_primary_distinguished_default",
            identifier = "primaryDistinguished"
        )]
        pub primary_distinguished: bool,
        #[rasn(identifier = "valuesWithContext")]
        pub values_with_context: Option<AttributeTypeAndDistinguishedValueValuesWithContext>,
    }
    impl AttributeTypeAndDistinguishedValue {
        pub fn new(
            r_type: ObjectIdentifier,
            value: Any,
            primary_distinguished: bool,
            values_with_context: Option<AttributeTypeAndDistinguishedValueValuesWithContext>,
        ) -> Self {
            Self {
                r_type,
                value,
                primary_distinguished,
                values_with_context,
            }
        }
    }
    fn attribute_type_and_distinguished_value_primary_distinguished_default() -> bool {
        true
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct AttributeTypeAssertion {
        #[rasn(identifier = "type")]
        pub r_type: ObjectIdentifier,
        #[rasn(size("1.."), identifier = "assertedContexts")]
        pub asserted_contexts: Option<SequenceOf<ContextAssertion>>,
    }
    impl AttributeTypeAssertion {
        pub fn new(
            r_type: ObjectIdentifier,
            asserted_contexts: Option<SequenceOf<ContextAssertion>>,
        ) -> Self {
            Self {
                r_type,
                asserted_contexts,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum AttributeUsage {
        userApplications = 0,
        directoryOperation = 1,
        distributedOperation = 2,
        dSAOperation = 3,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeValue(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AttributeValueAssertionAssertedContexts {
        #[rasn(tag(context, 0))]
        allContexts(()),
        #[rasn(size("1.."), tag(context, 1))]
        selectedContexts(SetOf<ContextAssertion>),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct AttributeValueAssertion {
        #[rasn(identifier = "type")]
        pub r_type: ObjectIdentifier,
        pub assertion: Any,
        #[rasn(identifier = "assertedContexts")]
        pub asserted_contexts: Option<AttributeValueAssertionAssertedContexts>,
    }
    impl AttributeValueAssertion {
        pub fn new(
            r_type: ObjectIdentifier,
            assertion: Any,
            asserted_contexts: Option<AttributeValueAssertionAssertedContexts>,
        ) -> Self {
            Self {
                r_type,
                assertion,
                asserted_contexts,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0.."))]
    pub struct BaseDistance(pub Integer);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    pub enum AnonymousChopSpecificationSpecificExclusions {
        #[rasn(tag(context, 0))]
        chopBefore(LocalName),
        #[rasn(tag(context, 1))]
        chopAfter(LocalName),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct ChopSpecificationSpecificExclusions(
        pub SetOf<AnonymousChopSpecificationSpecificExclusions>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ChopSpecification {
        #[rasn(tag(context, 1), identifier = "specificExclusions")]
        pub specific_exclusions: Option<ChopSpecificationSpecificExclusions>,
        #[rasn(tag(context, 2), default = "chop_specification_minimum_default")]
        pub minimum: BaseDistance,
        #[rasn(tag(context, 3))]
        pub maximum: Option<BaseDistance>,
    }
    impl ChopSpecification {
        pub fn new(
            specific_exclusions: Option<ChopSpecificationSpecificExclusions>,
            minimum: BaseDistance,
            maximum: Option<BaseDistance>,
        ) -> Self {
            Self {
                specific_exclusions,
                minimum,
                maximum,
            }
        }
    }
    fn chop_specification_minimum_default() -> BaseDistance {
        BaseDistance(Integer::from(0))
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$CONTEXT$&Type")]
    pub struct AnonymousContextContextValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct ContextContextValues(pub SetOf<AnonymousContextContextValues>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Context {
        #[rasn(identifier = "contextType")]
        pub context_type: ObjectIdentifier,
        #[rasn(identifier = "contextValues")]
        pub context_values: ContextContextValues,
        #[rasn(default = "context_fallback_default")]
        pub fallback: bool,
    }
    impl Context {
        pub fn new(
            context_type: ObjectIdentifier,
            context_values: ContextContextValues,
            fallback: bool,
        ) -> Self {
            Self {
                context_type,
                context_values,
                fallback,
            }
        }
    }
    fn context_fallback_default() -> bool {
        false
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$CONTEXT$&Assertion")]
    pub struct AnonymousContextAssertionContextValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct ContextAssertionContextValues(pub SetOf<AnonymousContextAssertionContextValues>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ContextAssertion {
        #[rasn(identifier = "contextType")]
        pub context_type: ObjectIdentifier,
        #[rasn(identifier = "contextValues")]
        pub context_values: ContextAssertionContextValues,
    }
    impl ContextAssertion {
        pub fn new(
            context_type: ObjectIdentifier,
            context_values: ContextAssertionContextValues,
        ) -> Self {
            Self {
                context_type,
                context_values,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ContextCombination {
        #[rasn(tag(context, 0))]
        context(ObjectIdentifier),
        #[rasn(tag(context, 1))]
        and(SequenceOf<ContextCombination>),
        #[rasn(tag(context, 2))]
        or(SequenceOf<ContextCombination>),
        #[rasn(tag(context, 3))]
        not(Box<ContextCombination>),
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$CONTEXT$&Assertion")]
    pub struct AnonymousContextProfileContextValue(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct ContextProfileContextValue(pub SequenceOf<AnonymousContextProfileContextValue>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ContextProfile {
        #[rasn(identifier = "contextType")]
        pub context_type: ObjectIdentifier,
        #[rasn(identifier = "contextValue")]
        pub context_value: Option<ContextProfileContextValue>,
    }
    impl ContextProfile {
        pub fn new(
            context_type: ObjectIdentifier,
            context_value: Option<ContextProfileContextValue>,
        ) -> Self {
            Self {
                context_type,
                context_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct DITContentRule {
        #[rasn(identifier = "structuralObjectClass")]
        pub structural_object_class: ObjectIdentifier,
        #[rasn(size("1.."))]
        pub auxiliaries: Option<SetOf<Any>>,
        #[rasn(size("1.."), tag(context, 1))]
        pub mandatory: Option<SetOf<Any>>,
        #[rasn(size("1.."), tag(context, 2))]
        pub optional: Option<SetOf<Any>>,
        #[rasn(size("1.."), tag(context, 3))]
        pub precluded: Option<SetOf<Any>>,
    }
    impl DITContentRule {
        pub fn new(
            structural_object_class: ObjectIdentifier,
            auxiliaries: Option<SetOf<Any>>,
            mandatory: Option<SetOf<Any>>,
            optional: Option<SetOf<Any>>,
            precluded: Option<SetOf<Any>>,
        ) -> Self {
            Self {
                structural_object_class,
                auxiliaries,
                mandatory,
                optional,
                precluded,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct DITContextUse {
        #[rasn(identifier = "attributeType")]
        pub attribute_type: ObjectIdentifier,
        #[rasn(size("1.."), tag(context, 1), identifier = "mandatoryContexts")]
        pub mandatory_contexts: Option<SetOf<Any>>,
        #[rasn(size("1.."), tag(context, 2), identifier = "optionalContexts")]
        pub optional_contexts: Option<SetOf<Any>>,
    }
    impl DITContextUse {
        pub fn new(
            attribute_type: ObjectIdentifier,
            mandatory_contexts: Option<SetOf<Any>>,
            optional_contexts: Option<SetOf<Any>>,
        ) -> Self {
            Self {
                attribute_type,
                mandatory_contexts,
                optional_contexts,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct DITStructureRule {
        #[rasn(identifier = "ruleIdentifier")]
        pub rule_identifier: RuleIdentifier,
        #[rasn(identifier = "nameForm")]
        pub name_form: ObjectIdentifier,
        #[rasn(size("1.."), identifier = "superiorStructureRules")]
        pub superior_structure_rules: Option<SetOf<RuleIdentifier>>,
    }
    impl DITStructureRule {
        pub fn new(
            rule_identifier: RuleIdentifier,
            name_form: ObjectIdentifier,
            superior_structure_rules: Option<SetOf<RuleIdentifier>>,
        ) -> Self {
            Self {
                rule_identifier,
                name_form,
                superior_structure_rules,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DistinguishedName(pub RDNSequence);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct EntryLimit {
        pub default: Integer,
        pub max: Integer,
    }
    impl EntryLimit {
        pub fn new(default: Integer, max: Integer) -> Self {
            Self { default, max }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ImposedSubset {
        baseObject = 0,
        oneLevel = 1,
        wholeSubtree = 2,
    }
    #[doc = " empty sequence specifies whole administrative area"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct LocalName(pub RDNSequence);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MRMapping {
        #[rasn(size("1.."), tag(context, 0))]
        pub mapping: Option<SequenceOf<Mapping>>,
        #[rasn(size("1.."), tag(context, 1))]
        pub substitution: Option<SequenceOf<MRSubstitution>>,
    }
    impl MRMapping {
        pub fn new(
            mapping: Option<SequenceOf<Mapping>>,
            substitution: Option<SequenceOf<MRSubstitution>>,
        ) -> Self {
            Self {
                mapping,
                substitution,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MRSubstitution {
        pub attribute: AttributeType,
        #[rasn(tag(context, 0), identifier = "oldMatchingRule")]
        pub old_matching_rule: Option<ObjectIdentifier>,
        #[rasn(tag(context, 1), identifier = "newMatchingRule")]
        pub new_matching_rule: Option<ObjectIdentifier>,
    }
    impl MRSubstitution {
        pub fn new(
            attribute: AttributeType,
            old_matching_rule: Option<ObjectIdentifier>,
            new_matching_rule: Option<ObjectIdentifier>,
        ) -> Self {
            Self {
                attribute,
                old_matching_rule,
                new_matching_rule,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Mapping {
        #[rasn(value("0.."), identifier = "mappingFunction")]
        pub mapping_function: ObjectIdentifier,
        #[rasn(default = "mapping_level_default")]
        pub level: Integer,
    }
    impl Mapping {
        pub fn new(mapping_function: ObjectIdentifier, level: Integer) -> Self {
            Self {
                mapping_function,
                level,
            }
        }
    }
    fn mapping_level_default() -> Integer {
        Integer::from(0)
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MatchingUse {
        #[rasn(identifier = "restrictionType")]
        pub restriction_type: ObjectIdentifier,
        #[rasn(identifier = "restrictionValue")]
        pub restriction_value: Any,
    }
    impl MatchingUse {
        pub fn new(restriction_type: ObjectIdentifier, restriction_value: Any) -> Self {
            Self {
                restriction_type,
                restriction_value,
            }
        }
    }
    #[doc = " naming data types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Name {
        rdnSequence(RDNSequence),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ObjectClassKind {
        #[rasn(identifier = "abstract")]
        R_abstract = 0,
        structural = 1,
        auxiliary = 2,
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$ATTRIBUTE$&Type")]
    pub struct AnonymousOutputValuesSelectedValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct OutputValuesSelectedValues(pub SequenceOf<AnonymousOutputValuesSelectedValues>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum OutputValues {
        selectedValues(OutputValuesSelectedValues),
        matchedValuesOnly(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RDNSequence(pub SequenceOf<RelativeDistinguishedName>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Refinement {
        #[rasn(tag(context, 0))]
        item(ObjectIdentifier),
        #[rasn(tag(context, 1))]
        and(SetOf<Refinement>),
        #[rasn(tag(context, 2))]
        or(SetOf<Refinement>),
        #[rasn(tag(context, 3))]
        not(Box<Refinement>),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct RelativeDistinguishedName(pub SetOf<AttributeTypeAndDistinguishedValue>);
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$ATTRIBUTE$&Type")]
    pub struct AnonymousRequestAttributeSelectedValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RequestAttributeSelectedValues(
        pub SequenceOf<AnonymousRequestAttributeSelectedValues>,
    );
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$ATTRIBUTE$&Type")]
    pub struct AnonymousAnonymousRequestAttributeDefaultValuesValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AnonymousRequestAttributeDefaultValuesValues(
        pub SequenceOf<AnonymousAnonymousRequestAttributeDefaultValuesValues>,
    );
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousRequestAttributeDefaultValues {
        #[rasn(identifier = "entryType")]
        pub entry_type: Option<Any>,
        pub values: AnonymousRequestAttributeDefaultValuesValues,
    }
    impl AnonymousRequestAttributeDefaultValues {
        pub fn new(
            entry_type: Option<Any>,
            values: AnonymousRequestAttributeDefaultValuesValues,
        ) -> Self {
            Self { entry_type, values }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RequestAttributeDefaultValues(
        pub SequenceOf<AnonymousRequestAttributeDefaultValues>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct RequestAttribute {
        #[rasn(identifier = "attributeType")]
        pub attribute_type: ObjectIdentifier,
        #[rasn(
            tag(context, 0),
            default = "request_attribute_include_subtypes_default",
            identifier = "includeSubtypes"
        )]
        pub include_subtypes: bool,
        #[rasn(tag(context, 1), identifier = "selectedValues")]
        pub selected_values: Option<RequestAttributeSelectedValues>,
        #[rasn(tag(context, 2), identifier = "defaultValues")]
        pub default_values: Option<RequestAttributeDefaultValues>,
        #[rasn(tag(context, 3))]
        pub contexts: Option<SequenceOf<ContextProfile>>,
        #[rasn(
            tag(context, 4),
            default = "request_attribute_context_combination_default",
            identifier = "contextCombination"
        )]
        pub context_combination: ContextCombination,
        #[rasn(size("1.."), tag(context, 5), identifier = "matchingUse")]
        pub matching_use: Option<SequenceOf<MatchingUse>>,
    }
    impl RequestAttribute {
        pub fn new(
            attribute_type: ObjectIdentifier,
            include_subtypes: bool,
            selected_values: Option<RequestAttributeSelectedValues>,
            default_values: Option<RequestAttributeDefaultValues>,
            contexts: Option<SequenceOf<ContextProfile>>,
            context_combination: ContextCombination,
            matching_use: Option<SequenceOf<MatchingUse>>,
        ) -> Self {
            Self {
                attribute_type,
                include_subtypes,
                selected_values,
                default_values,
                contexts,
                context_combination,
                matching_use,
            }
        }
    }
    fn request_attribute_include_subtypes_default() -> bool {
        false
    }
    fn request_attribute_context_combination_default() -> ContextCombination {
        ContextCombination::and(alloc::vec![])
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$ATTRIBUTE$&Type")]
    pub struct AnonymousResultAttributeOutputValuesSelectedValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct ResultAttributeOutputValuesSelectedValues(
        pub SequenceOf<AnonymousResultAttributeOutputValuesSelectedValues>,
    );
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ResultAttributeOutputValues {
        selectedValues(ResultAttributeOutputValuesSelectedValues),
        matchedValuesOnly(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ResultAttribute {
        #[rasn(identifier = "attributeType")]
        pub attribute_type: ObjectIdentifier,
        #[rasn(identifier = "outputValues")]
        pub output_values: Option<ResultAttributeOutputValues>,
        #[rasn(size("1.."), tag(context, 0))]
        pub contexts: Option<SequenceOf<ContextProfile>>,
    }
    impl ResultAttribute {
        pub fn new(
            attribute_type: ObjectIdentifier,
            output_values: Option<ResultAttributeOutputValues>,
            contexts: Option<SequenceOf<ContextProfile>>,
        ) -> Self {
            Self {
                attribute_type,
                output_values,
                contexts,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RuleIdentifier(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SearchRule {
        #[rasn(tag(context, 1), identifier = "serviceType")]
        pub service_type: Option<ObjectIdentifier>,
        #[rasn(tag(context, 2), identifier = "userClass")]
        pub user_class: Option<Integer>,
        #[rasn(size("1.."), tag(context, 3), identifier = "inputAttributeTypes")]
        pub input_attribute_types: Option<SequenceOf<RequestAttribute>>,
        #[rasn(
            tag(context, 4),
            default = "search_rule_attribute_combination_default",
            identifier = "attributeCombination"
        )]
        pub attribute_combination: AttributeCombination,
        #[rasn(size("1.."), tag(context, 5), identifier = "outputAttributeTypes")]
        pub output_attribute_types: Option<SequenceOf<ResultAttribute>>,
        #[rasn(tag(context, 6), identifier = "defaultControls")]
        pub default_controls: Option<ControlOptions>,
        #[rasn(tag(context, 7), identifier = "mandatoryControls")]
        pub mandatory_controls: Option<ControlOptions>,
        #[rasn(tag(context, 8), identifier = "searchRuleControls")]
        pub search_rule_controls: Option<ControlOptions>,
        #[rasn(tag(context, 9), identifier = "familyGrouping")]
        pub family_grouping: Option<FamilyGrouping>,
        #[rasn(tag(context, 10), identifier = "familyReturn")]
        pub family_return: Option<FamilyReturn>,
        #[rasn(tag(context, 11))]
        pub relaxation: Option<RelaxationPolicy>,
        #[rasn(size("1.."), tag(context, 12), identifier = "additionalControl")]
        pub additional_control: Option<SequenceOf<AttributeType>>,
        #[rasn(
            tag(context, 13),
            default = "search_rule_allowed_subset_default",
            identifier = "allowedSubset"
        )]
        pub allowed_subset: AllowedSubset,
        #[rasn(tag(context, 14), identifier = "imposedSubset")]
        pub imposed_subset: Option<ImposedSubset>,
        #[rasn(tag(context, 15), identifier = "entryLimit")]
        pub entry_limit: Option<EntryLimit>,
        pub id: Integer,
        #[rasn(tag(context, 0), identifier = "dmdId")]
        pub dmd_id: ObjectIdentifier,
    }
    impl SearchRule {
        pub fn new(
            service_type: Option<ObjectIdentifier>,
            user_class: Option<Integer>,
            input_attribute_types: Option<SequenceOf<RequestAttribute>>,
            attribute_combination: AttributeCombination,
            output_attribute_types: Option<SequenceOf<ResultAttribute>>,
            default_controls: Option<ControlOptions>,
            mandatory_controls: Option<ControlOptions>,
            search_rule_controls: Option<ControlOptions>,
            family_grouping: Option<FamilyGrouping>,
            family_return: Option<FamilyReturn>,
            relaxation: Option<RelaxationPolicy>,
            additional_control: Option<SequenceOf<AttributeType>>,
            allowed_subset: AllowedSubset,
            imposed_subset: Option<ImposedSubset>,
            entry_limit: Option<EntryLimit>,
            id: Integer,
            dmd_id: ObjectIdentifier,
        ) -> Self {
            Self {
                service_type,
                user_class,
                input_attribute_types,
                attribute_combination,
                output_attribute_types,
                default_controls,
                mandatory_controls,
                search_rule_controls,
                family_grouping,
                family_return,
                relaxation,
                additional_control,
                allowed_subset,
                imposed_subset,
                entry_limit,
                id,
                dmd_id,
            }
        }
    }
    fn search_rule_attribute_combination_default() -> AttributeCombination {
        AttributeCombination::and(alloc::vec![])
    }
    fn search_rule_allowed_subset_default() -> AllowedSubset {
        AllowedSubset([true, true, true].into_iter().collect())
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct SearchRuleDescriptionName(pub SetOf<DirectoryString>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SearchRuleDescription {
        #[rasn(tag(context, 28))]
        pub name: Option<SearchRuleDescriptionName>,
        #[rasn(value("0.."), tag(context, 29))]
        pub description: Option<DirectoryString>,
        #[rasn(tag(context, 30), default = "search_rule_description_obsolete_default")]
        pub obsolete: bool,
        #[rasn(tag(context, 1), identifier = "serviceType")]
        pub service_type: Option<ObjectIdentifier>,
        #[rasn(tag(context, 2), identifier = "userClass")]
        pub user_class: Option<Integer>,
        #[rasn(size("1.."), tag(context, 3), identifier = "inputAttributeTypes")]
        pub input_attribute_types: Option<SequenceOf<RequestAttribute>>,
        #[rasn(
            tag(context, 4),
            default = "search_rule_description_attribute_combination_default",
            identifier = "attributeCombination"
        )]
        pub attribute_combination: AttributeCombination,
        #[rasn(size("1.."), tag(context, 5), identifier = "outputAttributeTypes")]
        pub output_attribute_types: Option<SequenceOf<ResultAttribute>>,
        #[rasn(tag(context, 6), identifier = "defaultControls")]
        pub default_controls: Option<ControlOptions>,
        #[rasn(tag(context, 7), identifier = "mandatoryControls")]
        pub mandatory_controls: Option<ControlOptions>,
        #[rasn(tag(context, 8), identifier = "searchRuleControls")]
        pub search_rule_controls: Option<ControlOptions>,
        #[rasn(tag(context, 9), identifier = "familyGrouping")]
        pub family_grouping: Option<FamilyGrouping>,
        #[rasn(tag(context, 10), identifier = "familyReturn")]
        pub family_return: Option<FamilyReturn>,
        #[rasn(tag(context, 11))]
        pub relaxation: Option<RelaxationPolicy>,
        #[rasn(size("1.."), tag(context, 12), identifier = "additionalControl")]
        pub additional_control: Option<SequenceOf<AttributeType>>,
        #[rasn(
            tag(context, 13),
            default = "search_rule_description_allowed_subset_default",
            identifier = "allowedSubset"
        )]
        pub allowed_subset: AllowedSubset,
        #[rasn(tag(context, 14), identifier = "imposedSubset")]
        pub imposed_subset: Option<ImposedSubset>,
        #[rasn(tag(context, 15), identifier = "entryLimit")]
        pub entry_limit: Option<EntryLimit>,
    }
    impl SearchRuleDescription {
        pub fn new(
            name: Option<SearchRuleDescriptionName>,
            description: Option<DirectoryString>,
            obsolete: bool,
            service_type: Option<ObjectIdentifier>,
            user_class: Option<Integer>,
            input_attribute_types: Option<SequenceOf<RequestAttribute>>,
            attribute_combination: AttributeCombination,
            output_attribute_types: Option<SequenceOf<ResultAttribute>>,
            default_controls: Option<ControlOptions>,
            mandatory_controls: Option<ControlOptions>,
            search_rule_controls: Option<ControlOptions>,
            family_grouping: Option<FamilyGrouping>,
            family_return: Option<FamilyReturn>,
            relaxation: Option<RelaxationPolicy>,
            additional_control: Option<SequenceOf<AttributeType>>,
            allowed_subset: AllowedSubset,
            imposed_subset: Option<ImposedSubset>,
            entry_limit: Option<EntryLimit>,
        ) -> Self {
            Self {
                name,
                description,
                obsolete,
                service_type,
                user_class,
                input_attribute_types,
                attribute_combination,
                output_attribute_types,
                default_controls,
                mandatory_controls,
                search_rule_controls,
                family_grouping,
                family_return,
                relaxation,
                additional_control,
                allowed_subset,
                imposed_subset,
                entry_limit,
            }
        }
    }
    fn search_rule_description_obsolete_default() -> bool {
        false
    }
    fn search_rule_description_attribute_combination_default() -> AttributeCombination {
        AttributeCombination::and(alloc::vec![])
    }
    fn search_rule_description_allowed_subset_default() -> AllowedSubset {
        AllowedSubset([true, true, true].into_iter().collect())
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SearchRuleId {
        pub id: Integer,
        #[rasn(tag(context, 0), identifier = "dmdId")]
        pub dmd_id: ObjectIdentifier,
    }
    impl SearchRuleId {
        pub fn new(id: Integer, dmd_id: ObjectIdentifier) -> Self {
            Self { id, dmd_id }
        }
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    pub enum AnonymousSubtreeSpecificationSpecificExclusions {
        #[rasn(tag(context, 0))]
        chopBefore(LocalName),
        #[rasn(tag(context, 1))]
        chopAfter(LocalName),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct SubtreeSpecificationSpecificExclusions(
        pub SetOf<AnonymousSubtreeSpecificationSpecificExclusions>,
    );
    #[doc = " subtree data types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SubtreeSpecification {
        #[rasn(tag(context, 0), default = "subtree_specification_base_default")]
        pub base: LocalName,
        #[rasn(tag(context, 4), identifier = "specificationFilter")]
        pub specification_filter: Option<Refinement>,
        #[rasn(tag(context, 1), identifier = "specificExclusions")]
        pub specific_exclusions: Option<SubtreeSpecificationSpecificExclusions>,
        #[rasn(tag(context, 2), default = "subtree_specification_minimum_default")]
        pub minimum: BaseDistance,
        #[rasn(tag(context, 3))]
        pub maximum: Option<BaseDistance>,
    }
    impl SubtreeSpecification {
        pub fn new(
            base: LocalName,
            specification_filter: Option<Refinement>,
            specific_exclusions: Option<SubtreeSpecificationSpecificExclusions>,
            minimum: BaseDistance,
            maximum: Option<BaseDistance>,
        ) -> Self {
            Self {
                base,
                specification_filter,
                specific_exclusions,
                minimum,
                maximum,
            }
        }
    }
    fn subtree_specification_base_default() -> LocalName {
        LocalName(RDNSequence(alloc::vec![]))
    }
    fn subtree_specification_minimum_default() -> BaseDistance {
        BaseDistance(Integer::from(0))
    }
    pub static ID_AR_ACCESS_CONTROL_INNER_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[3u32]].concat()).unwrap().to_owned());
    pub static ID_AR_ACCESS_CONTROL_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[2u32]].concat()).unwrap().to_owned());
    #[doc = " administrative roles"]
    pub static ID_AR_AUTONOMOUS_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_AR_COLLECTIVE_ATTRIBUTE_INNER_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[6u32]].concat()).unwrap().to_owned());
    pub static ID_AR_COLLECTIVE_ATTRIBUTE_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[5u32]].concat()).unwrap().to_owned());
    pub static ID_AR_CONTEXT_DEFAULT_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[7u32]].concat()).unwrap().to_owned());
    pub static ID_AR_SERVICE_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[8u32]].concat()).unwrap().to_owned());
    pub static ID_AR_SUBSCHEMA_ADMIN_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[4u32]].concat()).unwrap().to_owned());
    pub static ID_AT_ALIASED_ENTRY_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[1u32]].concat()).unwrap().to_owned());
    #[doc = " attributes"]
    pub static ID_AT_OBJECT_CLASS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[0u32]].concat()).unwrap().to_owned());
    pub static ID_MR_DISTINGUISHED_NAME_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[1u32]].concat()).unwrap().to_owned());
    #[doc = " matching rules"]
    pub static ID_MR_OBJECT_IDENTIFIER_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[0u32]].concat()).unwrap().to_owned());
    #[doc = "  Name forms"]
    pub static ID_NF_SUBENTRY_NAME_FORM: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NF, &[16u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_ACCESS_CONTROL_SUBENTRY_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_OA, &[11u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_OA_ADMINISTRATIVE_ROLE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[5u32]].concat()).unwrap().to_owned());
    pub static ID_OA_COLLECTIVE_ATTRIBUTE_SUBENTRY_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_OA, &[12u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_OA_COLLECTIVE_EXCLUSIONS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[7u32]].concat()).unwrap().to_owned());
    pub static ID_OA_CONTEXT_ASSERTION_DEFAULT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[14u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_CONTEXT_DEFAULT_SUBENTRY_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_OA, &[13u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_OA_CREATE_TIMESTAMP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_OA_CREATORS_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[3u32]].concat()).unwrap().to_owned());
    #[doc = " operational attributes"]
    pub static ID_OA_EXCLUDE_ALL_COLLECTIVE_ATTRIBUTES: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[0u32]].concat()).unwrap().to_owned());
    pub static ID_OA_HAS_SUBORDINATES: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[9u32]].concat()).unwrap().to_owned());
    pub static ID_OA_HIERARCHY_BELOW: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[18u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_HIERARCHY_LEVEL: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[17u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_HIERARCHY_PARENT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[19u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_MODIFIERS_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[4u32]].concat()).unwrap().to_owned());
    pub static ID_OA_MODIFY_TIMESTAMP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[2u32]].concat()).unwrap().to_owned());
    pub static ID_OA_SEARCH_RULES: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[16u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_SERVICE_ADMIN_SUBENTRY_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_OA, &[15u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_OA_SUBSCHEMA_SUBENTRY_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[10u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_SUBSCHEMA_TIMESTAMP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[8u32]].concat()).unwrap().to_owned());
    pub static ID_OA_SUBTREE_SPECIFICATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[6u32]].concat()).unwrap().to_owned());
    pub static ID_OC_ALIAS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OC, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_OC_CHILD: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OC, &[29u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OC_PARENT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OC, &[28u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " object identifier assignments"]
    #[doc = " object classes"]
    pub static ID_OC_TOP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OC, &[0u32]].concat()).unwrap().to_owned());
    pub static ID_SC_ACCESS_CONTROL_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_SC_COLLECTIVE_ATTRIBUTE_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[2u32]].concat()).unwrap().to_owned());
    pub static ID_SC_CONTEXT_ASSERTION_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[3u32]].concat()).unwrap().to_owned());
    pub static ID_SC_SERVICE_ADMIN_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[4u32]].concat()).unwrap().to_owned());
    #[doc = " subentry classes"]
    pub static ID_SC_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[0u32]].concat()).unwrap().to_owned());
}
