---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x746_2000_Schedulerev1-ASN1Module.asn1
---
Warnings:
Unidentified generating bindings for : Unexpectedly encountered unlinked struct-like ASN1 value!
Unidentified generating bindings for : A type name is needed to stringify sequence value LinkedStructLikeValue([("daysOfMonth", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "DaysOfMonth", constraints: [] }), Explicit(LinkedElsewhereDefinedValue { parent: None, identifier: "defaultDaysOfMonth", can_be_const: false })), ("timesOfDayWps", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "TimesOfDayWps", constraints: [] }), Explicit(LinkedNestedValue { supertypes: [], value: Choice { type_name: Some("TimesOfDayWps"), variant_name: "intervalsOfDayWps", inner_value: LinkedElsewhereDefinedValue { parent: None, identifier: "defaultIntervalsOfDayWps", can_be_const: false } } }))])
Unidentified generating bindings for : A type name is needed to stringify sequence value LinkedStructLikeValue([("weekDay", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "WeekDay", constraints: [] }), Explicit(EnumeratedValue { enumerated: "WeekDay", enumerable: "sunday" })), ("typeOfDay", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "TypeOfDay", constraints: [] }), Explicit(LinkedNestedValue { supertypes: ["TypeOfDay"], value: LinkedIntValue { integer_type: Unbounded, value: 0 } }))])
Unidentified generating bindings for : A type name is needed to stringify sequence value LinkedStructLikeValue([("daysOfWeek", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "DaysOfWeek", constraints: [] }), Explicit(LinkedNestedValue { supertypes: ["DaysOfWeek"], value: BitString([true, true, true, true, true, true, true]) })), ("timesOfDayWps", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "TimesOfDayWps", constraints: [] }), Explicit(LinkedNestedValue { supertypes: [], value: Choice { type_name: Some("TimesOfDayWps"), variant_name: "intervalsOfDayWps", inner_value: LinkedElsewhereDefinedValue { parent: None, identifier: "defaultIntervalsOfDayWps", can_be_const: false } } }))])
LinkerError in ASN grammar: Failed to link value with 'TimePeriod'
LinkerError in ASN grammar: Failed to interpret object identifier value as sequence value!


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod schedulerev1_asn1_module {
    extern crate alloc;
    use super::asn1_defined_types_module::NameType;
    use super::attribute_asn1_module::*;
    use super::cmip_1::*;
    use super::metric_module::TimePeriod;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CommonError {
        #[rasn(identifier = "managedObjectClass")]
        pub managed_object_class: ObjectClass,
        #[rasn(identifier = "managedObjectInstance")]
        pub managed_object_instance: ObjectInstance,
        #[rasn(identifier = "errorId")]
        pub error_id: ErrorId,
        #[rasn(identifier = "errorValue")]
        pub error_value: Option<Any>,
    }
    impl CommonError {
        pub fn new(
            managed_object_class: ObjectClass,
            managed_object_instance: ObjectInstance,
            error_id: ErrorId,
            error_value: Option<Any>,
        ) -> Self {
            Self {
                managed_object_class,
                managed_object_instance,
                error_id,
                error_value,
            }
        }
    }
    #[doc = " supporting productions"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("8"))]
    pub struct Date(pub VisibleString);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousDateTranslationList {
        #[rasn(tag(context, 1))]
        pub date: Date,
        #[rasn(tag(context, 2), identifier = "typeOfDay")]
        pub type_of_day: TypeOfDay,
    }
    impl AnonymousDateTranslationList {
        pub fn new(date: Date, type_of_day: TypeOfDay) -> Self {
            Self { date, type_of_day }
        }
    }
    #[doc = " i.e. YYYYMMDD"]
    #[doc = " according to example in ITU-T Recommendation X.208 [2]"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DateTranslationList(pub SetOf<AnonymousDateTranslationList>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct DaysOfMonth {
        #[rasn(size("31"), tag(context, 0), identifier = "daysFromFirst")]
        pub days_from_first: BitString,
        #[rasn(size("31"), tag(context, 1), identifier = "daysFromLast")]
        pub days_from_last: BitString,
    }
    impl DaysOfMonth {
        pub fn new(days_from_first: BitString, days_from_last: BitString) -> Self {
            Self {
                days_from_first,
                days_from_last,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DaysOfWeek(pub FixedBitString<7usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DefaultIndex(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ErrorId {
        localValue(Integer),
        globalValue(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ExternalSchedulerName(pub SetOf<ObjectInstance>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum IndexOrOperSpec {
        #[rasn(tag(context, 0))]
        index(Integer),
        #[rasn(tag(context, 1))]
        operation(OperationSpecifications),
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousIntervalsOfDayWps {
        #[rasn(identifier = "intervalStart")]
        pub interval_start: Time24Wps,
        #[rasn(identifier = "intervalEnd")]
        pub interval_end: Time24Wps,
    }
    impl AnonymousIntervalsOfDayWps {
        pub fn new(interval_start: Time24Wps, interval_end: Time24Wps) -> Self {
            Self {
                interval_start,
                interval_end,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct IntervalsOfDayWps(pub SetOf<AnonymousIntervalsOfDayWps>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousModificationList {
        #[rasn(
            tag(context, 2),
            default = "anonymous_modification_list_modify_operator_default",
            identifier = "modifyOperator"
        )]
        pub modify_operator: ModifyOperator,
        #[rasn(identifier = "attributeId")]
        pub attribute_id: Any,
        #[rasn(identifier = "attributeValue")]
        pub attribute_value: Option<Any>,
    }
    impl AnonymousModificationList {
        pub fn new(
            modify_operator: ModifyOperator,
            attribute_id: Any,
            attribute_value: Option<Any>,
        ) -> Self {
            Self {
                modify_operator,
                attribute_id,
                attribute_value,
            }
        }
    }
    fn anonymous_modification_list_modify_operator_default() -> ModifyOperator {
        REPLACE
    }
    #[doc = " Specifies the TimesOfDayWps for different days of the same month if"]
    #[doc = " they have different intervals."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ModificationList(pub SetOf<AnonymousModificationList>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousMonthMask {
        #[rasn(identifier = "daysOfMonth")]
        pub days_of_month: DaysOfMonth,
        #[rasn(identifier = "timesOfDayWps")]
        pub times_of_day_wps: TimesOfDayWps,
    }
    impl AnonymousMonthMask {
        pub fn new(days_of_month: DaysOfMonth, times_of_day_wps: TimesOfDayWps) -> Self {
            Self {
                days_of_month,
                times_of_day_wps,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct MonthMask(pub SetOf<AnonymousMonthMask>);
    #[doc = " absent for setToDefault"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct OnDuty(pub bool);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    pub enum AnonymousOperationResult {
        #[rasn(tag(context, 0))]
        getResult(GetResult),
        #[rasn(tag(context, 1))]
        getListError(GetListError),
        #[rasn(tag(context, 2))]
        setResult(SetResult),
        #[rasn(tag(context, 3))]
        setListError(SetListError),
        #[rasn(tag(context, 4))]
        actionResult(ActionResult),
        #[rasn(tag(context, 5))]
        commonError(CommonError),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OperationResult(pub SetOf<AnonymousOperationResult>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AnonymousOperationSpecificationsScheduledOperations {
        #[rasn(tag(context, 0))]
        set(ModificationList),
        #[rasn(tag(context, 1))]
        action(ActionInfo),
        #[rasn(tag(context, 2))]
        get(GetArgument),
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousOperationSpecifications {
        #[rasn(identifier = "scheduledObjects")]
        pub scheduled_objects: SetOf<ObjectInstance>,
        #[rasn(identifier = "scheduledOperations")]
        pub scheduled_operations: AnonymousOperationSpecificationsScheduledOperations,
    }
    impl AnonymousOperationSpecifications {
        pub fn new(
            scheduled_objects: SetOf<ObjectInstance>,
            scheduled_operations: AnonymousOperationSpecificationsScheduledOperations,
        ) -> Self {
            Self {
                scheduled_objects,
                scheduled_operations,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OperationSpecifications(pub SetOf<AnonymousOperationSpecifications>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct ResynchronizeMode(pub bool);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Schedule {
        #[rasn(tag(context, 0))]
        daily(SequenceOfDays),
        #[rasn(tag(context, 1))]
        weekly(SequenceOfWeeks),
        #[rasn(tag(context, 2))]
        monthly(SequenceOfMonths),
        #[rasn(tag(context, 3))]
        typeOfDay(SequenceOfTypeOfDays),
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousScheduledManagedObjectsList {
        #[rasn(identifier = "objectInstance")]
        pub object_instance: ObjectInstance,
        pub activity: Option<AttributeId>,
    }
    impl AnonymousScheduledManagedObjectsList {
        pub fn new(object_instance: ObjectInstance, activity: Option<AttributeId>) -> Self {
            Self {
                object_instance,
                activity,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ScheduledManagedObjectsList(pub SetOf<AnonymousScheduledManagedObjectsList>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousSchedulingData {
        #[rasn(tag(context, 0), identifier = "indexOrOperSpec")]
        pub index_or_oper_spec: IndexOrOperSpec,
        #[rasn(tag(context, 1))]
        pub schedule: Schedule,
        #[rasn(tag(context, 2))]
        pub priority: Option<Integer>,
    }
    impl AnonymousSchedulingData {
        pub fn new(
            index_or_oper_spec: IndexOrOperSpec,
            schedule: Schedule,
            priority: Option<Integer>,
        ) -> Self {
            Self {
                index_or_oper_spec,
                schedule,
                priority,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SchedulingData(pub SetOf<AnonymousSchedulingData>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SequenceOfDays(pub SequenceOf<TimesOfDayWps>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SequenceOfMonths(pub SequenceOf<MonthMask>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1"))]
    pub struct SequenceOfTypeOfDays(pub SequenceOf<TypeOfDaysMaskWps>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SequenceOfWeeks(pub SequenceOf<WeekMaskWps>);
    #[doc = " SIZE(1) because more has no meaning because there is no implied periodicity, contrary to"]
    #[doc = " SequenceOfDays, SequenceOfWeeks, SequenceOfMonths."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Time24Wps {
        #[rasn(value("0..=23"), tag(context, 1))]
        pub hour: u8,
        #[rasn(value("0..=59"), tag(context, 2))]
        pub minute: Option<u8>,
        #[rasn(value("0..=59"), tag(context, 3))]
        pub second: Option<u8>,
        #[rasn(value("0..=999"), tag(context, 4))]
        pub milliseconds: Option<u16>,
        #[rasn(value("0..=999999"), tag(context, 5))]
        pub microseconds: Option<u32>,
        #[rasn(value("0..=999999999"), tag(context, 6))]
        pub nanoseconds: Option<u32>,
        #[rasn(value("0..=999999999999"), tag(context, 7))]
        pub picoseconds: Option<u64>,
    }
    impl Time24Wps {
        pub fn new(
            hour: u8,
            minute: Option<u8>,
            second: Option<u8>,
            milliseconds: Option<u16>,
            microseconds: Option<u32>,
            nanoseconds: Option<u32>,
            picoseconds: Option<u64>,
        ) -> Self {
            Self {
                hour,
                minute,
                second,
                milliseconds,
                microseconds,
                nanoseconds,
                picoseconds,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum TimesOfDayWps {
        #[rasn(tag(context, 0))]
        intervalsOfDayWps(IntervalsOfDayWps),
        #[rasn(tag(context, 1))]
        triggerTimes(TriggerTimes),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TriggerTimes(pub SetOf<Time24Wps>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TypeOfDay(pub Integer);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousTypeOfDaysMaskWps {
        #[rasn(identifier = "typeOfDay")]
        pub type_of_day: TypeOfDay,
        #[rasn(identifier = "timesOfDay")]
        pub times_of_day: TimesOfDayWps,
    }
    impl AnonymousTypeOfDaysMaskWps {
        pub fn new(type_of_day: TypeOfDay, times_of_day: TimesOfDayWps) -> Self {
            Self {
                type_of_day,
                times_of_day,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TypeOfDaysMaskWps(pub SetOf<AnonymousTypeOfDaysMaskWps>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum WeekDay {
        sunday = 0,
        monday = 1,
        tuesday = 2,
        wednesday = 3,
        thursday = 4,
        friday = 5,
        saturday = 6,
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousWeekDayTranslationList {
        #[rasn(tag(context, 1), identifier = "weekDay")]
        pub week_day: WeekDay,
        #[rasn(tag(context, 2), identifier = "typeOfDay")]
        pub type_of_day: TypeOfDay,
    }
    impl AnonymousWeekDayTranslationList {
        pub fn new(week_day: WeekDay, type_of_day: TypeOfDay) -> Self {
            Self {
                week_day,
                type_of_day,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct WeekDayTranslationList(pub SetOf<AnonymousWeekDayTranslationList>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousWeekMaskWps {
        #[rasn(identifier = "daysOfWeek")]
        pub days_of_week: DaysOfWeek,
        #[rasn(identifier = "timesOfDayWps")]
        pub times_of_day_wps: TimesOfDayWps,
    }
    impl AnonymousWeekMaskWps {
        pub fn new(days_of_week: DaysOfWeek, times_of_day_wps: TimesOfDayWps) -> Self {
            Self {
                days_of_week,
                times_of_day_wps,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct WeekMaskWps(pub SetOf<AnonymousWeekMaskWps>);
    #[doc = " default value definitions"]
    pub static DEFAULT_DATE_TRANSLATION_LIST: LazyLock<DateTranslationList> =
        LazyLock::new(|| DateTranslationList(alloc::vec![]));
    pub static DEFAULT_DAYS_OF_MONTH: LazyLock<DaysOfMonth> = LazyLock::new(|| {
        DaysOfMonth::new(
            [
                true, true, true, true, true, true, true, true, true, true, true, true, true, true,
                true, true, true, true, true, true, true, true, true, true, true, true, true, true,
                true, true, true,
            ]
            .into_iter()
            .collect(),
            [
                true, true, true, true, true, true, true, true, true, true, true, true, true, true,
                true, true, true, true, true, true, true, true, true, true, true, true, true, true,
                true, true, true,
            ]
            .into_iter()
            .collect(),
        )
    });
    pub static DEFAULT_DEFAULT_INDEX: LazyLock<DefaultIndex> =
        LazyLock::new(|| DefaultIndex(Integer::from(0i128)));
    pub const DEFAULT_RESYNCHRONIZE_MODE: ResynchronizeMode = ResynchronizeMode(false);
    pub static DEFAULT_SEQUENCE_OF_DAYS: LazyLock<SequenceOfDays> = LazyLock::new(|| {
        SequenceOfDays(alloc::vec![TimesOfDayWps::intervalsOfDayWps(
            DEFAULT_INTERVALS_OF_DAY_WPS
        )])
    });
    pub static DEFAULT_SEQUENCE_OF_WEEKS: LazyLock<SequenceOfWeeks> =
        LazyLock::new(|| SequenceOfWeeks(Oid::const_new(&[]).to_owned()));
    pub static DEFAULT_TIME_PERIOD: LazyLock<TimePeriod> =
        LazyLock::new(|| TimePeriod(TimePeriod(TimePeriod::seconds(0))));
    pub static SCHED_ATT: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 2u32, 15u32, 7u32]).to_owned());
    pub static SCHED_MO: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 2u32, 15u32, 3u32]).to_owned());
    pub static SCHED_NB: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 2u32, 15u32, 6u32]).to_owned());
    pub static SCHED_NOTIF: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 2u32, 15u32, 10u32]).to_owned());
    pub static SCHED_PKG: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 2u32, 15u32, 4u32]).to_owned());
}
