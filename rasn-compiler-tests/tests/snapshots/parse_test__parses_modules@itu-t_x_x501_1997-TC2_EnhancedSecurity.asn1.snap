---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x501_1997-TC2_EnhancedSecurity.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to resolve supertype SIGNED of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype SIGNED of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype SIGNED of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype SIGNED of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype SIGNED of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype HASH of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype HASH of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod enhanced_security {
    extern crate alloc;
    use super::authentication_framework::*;
    use super::basic_access_control::AttributeTypeAndValue;
    use super::certificate_extensions::{GeneralName, KeyIdentifier};
    use super::information_framework::*;
    use super::upper_bounds::UB_PRIVACY_MARK_LENGTH;
    use super::useful_definitions::{
        AUTHENTICATION_FRAMEWORK, BASIC_ACCESS_CONTROL, CERTIFICATE_EXTENSIONS, ID_AT, ID_AVC,
        ID_MR, INFORMATION_FRAMEWORK, UPPER_BOUNDS,
    };
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " Hash value of protected attribute"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AVIHash(pub HASH);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttribsHash(pub HASH);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeIntegrityInfo(pub SIGNED);
    #[doc = " Attribute type and value with associated context values"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct AttributeTypeValueContexts {
        #[rasn(identifier = "type")]
        pub r_type: Any,
        pub value: Any,
        #[rasn(size("1.."), identifier = "contextList")]
        pub context_list: Option<SetOf<Context>>,
    }
    impl AttributeTypeValueContexts {
        pub fn new(r_type: Any, value: Any, context_list: Option<SetOf<Context>>) -> Self {
            Self {
                r_type,
                value,
                context_list,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeValueIntegrityInfo(pub SIGNED);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ClassList(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Clearance {
        #[rasn(identifier = "policyId")]
        pub policy_id: ObjectIdentifier,
        #[rasn(default = "clearance_class_list_default", identifier = "classList")]
        pub class_list: ClassList,
        #[rasn(size("1.."), identifier = "securityCategories")]
        pub security_categories: Option<SetOf<SecurityCategory>>,
    }
    impl Clearance {
        pub fn new(
            policy_id: ObjectIdentifier,
            class_list: ClassList,
            security_categories: Option<SetOf<SecurityCategory>>,
        ) -> Self {
            Self {
                policy_id,
                class_list,
                security_categories,
            }
        }
    }
    fn clearance_class_list_default() -> ClassList {
        ClassList(
            [false, true, false, false, false, false]
                .into_iter()
                .collect(),
        )
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct IssuerAndSerialNumber {
        pub issuer: Name,
        pub serial: CertificateSerialNumber,
    }
    impl IssuerAndSerialNumber {
        pub fn new(issuer: Name, serial: CertificateSerialNumber) -> Self {
            Self { issuer, serial }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct PrivacyMark(pub PrintableString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Scope {
        #[rasn(tag(context, 0))]
        wholeEntry(()),
        #[rasn(tag(context, 1))]
        selectedTypes(SelectedTypes),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct SecurityCategories(pub SetOf<SecurityCategory>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SecurityCategory {
        #[rasn(tag(context, 0), identifier = "type")]
        pub r_type: Any,
        #[rasn(tag(explicit(context, 1)))]
        pub value: Any,
    }
    impl SecurityCategory {
        pub fn new(r_type: Any, value: Any) -> Self {
            Self { r_type, value }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SecurityClassification(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct SecurityLabel {
        #[rasn(identifier = "security-policy-identifier")]
        pub security_policy_identifier: Option<SecurityPolicyIdentifier>,
        #[rasn(identifier = "security-classification")]
        pub security_classification: Option<SecurityClassification>,
        #[rasn(identifier = "privacy-mark")]
        pub privacy_mark: Option<PrivacyMark>,
        #[rasn(identifier = "security-categories")]
        pub security_categories: Option<SecurityCategories>,
    }
    impl SecurityLabel {
        pub fn new(
            security_policy_identifier: Option<SecurityPolicyIdentifier>,
            security_classification: Option<SecurityClassification>,
            privacy_mark: Option<PrivacyMark>,
            security_categories: Option<SecurityCategories>,
        ) -> Self {
            Self {
                security_policy_identifier,
                security_classification,
                privacy_mark,
                security_categories,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SecurityPolicyIdentifier(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct SelectedTypes(pub SequenceOf<AttributeType>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SignedSecurityLabel(pub SIGNED);
    #[doc = " Hash value of protected attributes"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Signer {
        #[rasn(tag(explicit(context, 0)))]
        thisEntry(ThisEntry),
        #[rasn(tag(context, 1))]
        thirdParty(SpecificallyIdentified),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SpecificallyIdentified {
        pub name: GeneralName,
        pub issuer: Option<GeneralName>,
        pub serial: Option<CertificateSerialNumber>,
    }
    impl SpecificallyIdentified {
        pub fn new(
            name: GeneralName,
            issuer: Option<GeneralName>,
            serial: Option<CertificateSerialNumber>,
        ) -> Self {
            Self {
                name,
                issuer,
                serial,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ThisEntry {
        onlyOne(()),
        specific(IssuerAndSerialNumber),
    }
    #[doc = " id-at-defaultDirQop\t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 56}"]
    pub static ID_AT_ATTRIBUTE_INTEGRITY_INFO: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[57u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " The following out-commented ASN.1 specification are know to be erroneous and are therefore deprecated."]
    #[doc = " EncryptedAttributeSyntax {AttributeSyntax}  ::=  SEQUENCE  {"]
    #[doc = "\tkeyInfo\tSEQUENCE OF KeyIdOrProtectedKey,"]
    #[doc = "\tencAlg\tAlgorithmIdentifier,"]
    #[doc = "\tencValue\tENCRYPTED { AttributeSyntax } }"]
    #[doc = " KeyIdOrProtectedKey  ::=  SEQUENCE  {"]
    #[doc = "\tkeyIdentifier\t[0]\tKeyIdentifier\tOPTIONAL,"]
    #[doc = "\tprotectedKeys\t[1]\tProtectedKey\tOPTIONAL }"]
    #[doc = " At least one key identifier or protected key must be present"]
    #[doc = " ProtectedKey  ::=  SEQUENCE  {"]
    #[doc = "\tauthReaders\tAuthReaders,"]
    #[doc = " if absent, use attribute in authorized reader entry"]
    #[doc = "\tkeyEncAlg   \tAlgorithmIdentifier  OPTIONAL, "]
    #[doc = "  algorithm to encrypt encAttrKey"]
    #[doc = "\tencAttKey\t\tEncAttKey  }"]
    #[doc = " confidentiality key protected with authorized user's"]
    #[doc = " protection mechanism"]
    #[doc = " AuthReaders  ::=  SEQUENCE OF Name"]
    #[doc = " EncAttKey  ::=  PROTECTED {SymmetricKey, keyProtection}"]
    #[doc = " SymmetricKey  ::=  BIT STRING"]
    #[doc = " keyProtection PROTECTION-MAPPING  ::=  {"]
    #[doc = "\tSECURITY-TRANSFORMATION {genEncryption} }"]
    #[doc = " confKeyInfo  ATTRIBUTE  ::=  {"]
    #[doc = "\tWITH SYNTAX\t\t\t\tConfKeyInfo"]
    #[doc = "\tEQUALITY MATCHING RULE   \treaderAndKeyIDMatch"]
    #[doc = "\tID\t\t\t\t\t\tid-at-confKeyInfo }"]
    #[doc = " ConfKeyInfo  ::=  SEQUENCE  {"]
    #[doc = "\tkeyIdentifier\tKeyIdentifier,"]
    #[doc = "\tprotectedKey\tProtectedKey }"]
    #[doc = " readerAndKeyIDMatch MATCHING-RULE  ::=  {"]
    #[doc = "\tSYNTAX\tReaderAndKeyIDAssertion"]
    #[doc = "\tID\t\tid-mr-readerAndKeyIDMatch }"]
    #[doc = " ReaderAndKeyIDAssertion  ::=  SEQUENCE {"]
    #[doc = "\tkeyIdentifier\tKeyIdentifier,"]
    #[doc = "\tauthReaders\tAuthReaders OPTIONAL }"]
    #[doc = " Object identifier assignments"]
    #[doc = " attributes"]
    pub static ID_AT_CLEARANCE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[55u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_AVC_ATTRIBUTE_VALUE_INTEGRITY_INFO_CONTEXT: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AVC, &[4u32]].concat())
                .unwrap()
                .to_owned()
        });
    #[doc = " id-at-confKeyInfo\t\t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-at 60}"]
    #[doc = " matching rules"]
    #[doc = " id-mr-readerAndKeyIDMatch\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-mr 43}"]
    #[doc = " contexts"]
    pub static ID_AVC_ATTRIBUTE_VALUE_SECURITY_LABEL_CONTEXT: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_AVC, &[3u32]].concat())
                .unwrap()
                .to_owned()
        });
}
