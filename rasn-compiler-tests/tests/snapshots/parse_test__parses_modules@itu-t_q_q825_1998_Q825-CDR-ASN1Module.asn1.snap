---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_q_q825_1998_Q825-CDR-ASN1Module.asn1
---
Warnings:
Unidentified generating bindings for : Unexpectedly encountered unlinked struct-like ASN1 value!
LinkerError in ASN grammar: Failed to link value with 'ReportingTriggers'


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod q825_cdr_asn1_module {
    extern crate alloc;
    use super::asn1_defined_types_module::NameType;
    use super::attribute_asn1_module::ManagementExtension;
    use super::cmip_1::ObjectInstance;
    use super::mtpdefined_types_module::PointCode;
    use super::usage_metering_function::ReportingTriggers;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AccessDelivery(pub FixedBitString<8usize>);
    #[doc = "\tBit 0 (setupMessageGeneration) has the following meaning:"]
    #[doc = "\t\t0\tNo set-up message generated"]
    #[doc = "\t\t1\tSet-up message generated"]
    #[doc = "\tBit 1 to 7 are not used."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=18"))]
    pub struct AccountCodeInput(pub OctetString);
    #[doc = "\tThis type is used to represent information, which is provided by the subscriber necessary for"]
    #[doc = "\tuse by some services."]
    #[doc = "\ta)\tbits\t876:\tEncoding scheme"]
    #[doc = "\t\t\t000\tBCD even (even number of digits)"]
    #[doc = "\t\t\t001\tBCD odd (odd number of digits)"]
    #[doc = "\t\t\t010\tIA5 character"]
    #[doc = "\t\t\t011\tBinary coded"]
    #[doc = "\t\t\t100"]
    #[doc = "\t\t\t...\tspare"]
    #[doc = "\t\t\t111"]
    #[doc = ""]
    #[doc = "\tb)\tbits\t54321:\tType of digits"]
    #[doc = "\t\t\t00000\treserved for account code"]
    #[doc = "\t\t\t00001\treserved for authorization code"]
    #[doc = "\t\t\t00010\treserved for private network travelling class mark"]
    #[doc = "\t\t\t00011\treserved for business communication"]
    #[doc = "\t\t\t00100"]
    #[doc = "\t\t\t...\tspare for international use"]
    #[doc = "\t\t\t01111"]
    #[doc = "\t\t\t10000"]
    #[doc = "\t\t\t...\tspare for national use"]
    #[doc = "\t\t\t11111"]
    #[doc = ""]
    #[doc = "\tc)\tDigits:"]
    #[doc = "\t\tCoding in accordance to the coding scheme and type of digits."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct AdditionalParticipantInfo {
        #[rasn(tag(context, 0), identifier = "physicalLineCode")]
        pub physical_line_code: Option<PhysicalLineCode>,
        #[rasn(tag(context, 1), identifier = "receivedDigits")]
        pub received_digits: Option<ReceivedDigits>,
        #[rasn(tag(context, 2), identifier = "operatorSpecific1AdditionalNumber")]
        pub operator_specific1_additional_number: Option<OperatorSpecific1AdditionalNumber>,
        #[rasn(tag(context, 3), identifier = "operatorSpecific2AdditionalNumber")]
        pub operator_specific2_additional_number: Option<OperatorSpecific2AdditionalNumber>,
        #[rasn(tag(context, 4), identifier = "operatorSpecific3AdditionalNumber")]
        pub operator_specific3_additional_number: Option<OperatorSpecific3AdditionalNumber>,
    }
    impl AdditionalParticipantInfo {
        pub fn new(
            physical_line_code: Option<PhysicalLineCode>,
            received_digits: Option<ReceivedDigits>,
            operator_specific1_additional_number: Option<OperatorSpecific1AdditionalNumber>,
            operator_specific2_additional_number: Option<OperatorSpecific2AdditionalNumber>,
            operator_specific3_additional_number: Option<OperatorSpecific3AdditionalNumber>,
        ) -> Self {
            Self {
                physical_line_code,
                received_digits,
                operator_specific1_additional_number,
                operator_specific2_additional_number,
                operator_specific3_additional_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Amount {
        #[rasn(tag(context, 0), identifier = "currencyAmount")]
        pub currency_amount: NumberOfUnits,
        #[rasn(tag(context, 1))]
        pub multiplier: Multiplier,
    }
    impl Amount {
        pub fn new(currency_amount: NumberOfUnits, multiplier: Multiplier) -> Self {
            Self {
                currency_amount,
                multiplier,
            }
        }
    }
    #[doc = "\tMultiplier present only if capability = multipleRate"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "B-PartyCategory")]
    pub struct BPartyCategory(pub FixedBitString<8usize>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum BearerServiceCapability {
        speech = 0,
        audio3dot1kHZ = 1,
        uni64 = 2,
        #[rasn(identifier = "uni64withT-A")]
        uni64withT_A = 3,
        multipleRate = 4,
        #[rasn(identifier = "packetModeB-Ch")]
        packetModeB_Ch = 5,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct BearerService {
        pub capability: BearerServiceCapability,
        #[rasn(value("2..=30"))]
        pub multiplier: Option<u8>,
    }
    impl BearerService {
        pub fn new(capability: BearerServiceCapability, multiplier: Option<u8>) -> Self {
            Self {
                capability,
                multiplier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct BlockHeaderRecord {
        #[rasn(tag(context, 0), identifier = "exchangeInfo")]
        pub exchange_info: Option<ExchangeInfo>,
        #[rasn(tag(context, 1), identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(tag(context, 2), identifier = "reasonForOutput")]
        pub reason_for_output: Option<ReasonForOutput>,
        #[rasn(tag(context, 3))]
        pub extensions: Option<ManagementExtensions>,
    }
    impl BlockHeaderRecord {
        pub fn new(
            exchange_info: Option<ExchangeInfo>,
            sequence_number: SequenceNumber,
            reason_for_output: Option<ReasonForOutput>,
            extensions: Option<ManagementExtensions>,
        ) -> Self {
            Self {
                exchange_info,
                sequence_number,
                reason_for_output,
                extensions,
            }
        }
    }
    #[doc = " BLOCK CONTENTS"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct BlockRecordInfo {
        #[rasn(tag(context, 0), identifier = "blockHeaderRecord")]
        pub block_header_record: Option<BlockHeaderRecord>,
        #[rasn(tag(context, 1), identifier = "usageRecords")]
        pub usage_records: SequenceOf<RecordContent>,
    }
    impl BlockRecordInfo {
        pub fn new(
            block_header_record: Option<BlockHeaderRecord>,
            usage_records: SequenceOf<RecordContent>,
        ) -> Self {
            Self {
                block_header_record,
                usage_records,
            }
        }
    }
    #[doc = "\tCoded according to ITU-T Recommendation Q.850, Table 1/Q.850"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CDRPurpose(pub FixedBitString<2usize>);
    #[doc = " \tHHmm (Hours, Minutes)"]
    #[doc = "\teach field one digit, two digits per octet, the digits o through 9 encoded as"]
    #[doc = "\t0000 to 1001 \"hstring\", 1st digit in the LSB"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallDetailDataId(pub NameType);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct CallDuration {
        #[rasn(tag(context, 0), identifier = "conversationTime")]
        pub conversation_time: Option<ConversationTime>,
        #[rasn(tag(context, 1), identifier = "durationTimeACM")]
        pub duration_time_acm: Option<DurationTimeACM>,
        #[rasn(tag(context, 2), identifier = "durationTimeB-ans")]
        pub duration_time_b_ans: Option<DurationTimeANM>,
        #[rasn(tag(context, 3), identifier = "durationTimeNoANM")]
        pub duration_time_no_anm: Option<DurationTimeNoANM>,
    }
    impl CallDuration {
        pub fn new(
            conversation_time: Option<ConversationTime>,
            duration_time_acm: Option<DurationTimeACM>,
            duration_time_b_ans: Option<DurationTimeANM>,
            duration_time_no_anm: Option<DurationTimeNoANM>,
        ) -> Self {
            Self {
                conversation_time,
                duration_time_acm,
                duration_time_b_ans,
                duration_time_no_anm,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallIdentificationNumber(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct CallRecord {
        #[rasn(tag(context, 0), identifier = "recordType")]
        pub record_type: RecordType,
        #[rasn(tag(context, 1), identifier = "startTimeStamp")]
        pub start_time_stamp: StartTimeStamp,
        #[rasn(tag(context, 2), identifier = "participantInfo")]
        pub participant_info: ParticipantInfo,
        #[rasn(tag(context, 3), identifier = "bearerService")]
        pub bearer_service: BearerService,
        #[rasn(tag(context, 4), identifier = "serviceUser")]
        pub service_user: ServiceUser,
        #[rasn(tag(context, 6), identifier = "callIdentificationNumber")]
        pub call_identification_number: CallIdentificationNumber,
        #[rasn(tag(context, 5), identifier = "supplementaryServices")]
        pub supplementary_services: Option<SupplementaryServices>,
        #[rasn(tag(context, 7), identifier = "immediateNotificationForUsageMetering")]
        pub immediate_notification_for_usage_metering: Option<ImmediateNotification>,
        #[rasn(tag(context, 8))]
        pub cause: Option<Cause>,
        #[rasn(tag(context, 9), identifier = "iNSpecificInfo")]
        pub i_nspecific_info: Option<INSpecificInfo>,
        #[rasn(tag(context, 10), identifier = "partialGeneration")]
        pub partial_generation: Option<PartialGeneration>,
        #[rasn(tag(context, 11), identifier = "exchangeInfo")]
        pub exchange_info: Option<ExchangeInfo>,
        #[rasn(tag(context, 12), identifier = "relatedCallNumber")]
        pub related_call_number: Option<RelatedCallNumber>,
        #[rasn(tag(context, 13), identifier = "cDRPurpose")]
        pub c_drpurpose: Option<CDRPurpose>,
        #[rasn(tag(context, 14), identifier = "additionalParticipantInfo")]
        pub additional_participant_info: Option<AdditionalParticipantInfo>,
        #[rasn(tag(context, 15), identifier = "callingPartyCategory")]
        pub calling_party_category: Option<CallingPartyCategory>,
        #[rasn(tag(context, 16), identifier = "callingPartyType")]
        pub calling_party_type: Option<CallingPartyType>,
        #[rasn(tag(context, 17), identifier = "chargingInformation")]
        pub charging_information: Option<ChargingInformation>,
        #[rasn(tag(context, 18))]
        pub progress: Option<Progress>,
        #[rasn(tag(context, 19), identifier = "accessDelivery")]
        pub access_delivery: Option<AccessDelivery>,
        #[rasn(tag(context, 20), identifier = "trunkGroupOutgoing")]
        pub trunk_group_outgoing: Option<TrunkGroupOutgoing>,
        #[rasn(tag(context, 21), identifier = "trunkGroupIncoming")]
        pub trunk_group_incoming: Option<TrunkGroupIncoming>,
        #[rasn(tag(context, 22), identifier = "fallbackBearerService")]
        pub fallback_bearer_service: Option<FallbackBearerService>,
        #[rasn(tag(context, 23))]
        pub teleservice: Option<Teleservice>,
        #[rasn(tag(context, 24), identifier = "callDuration")]
        pub call_duration: Option<CallDuration>,
        #[rasn(tag(context, 25), identifier = "uUInfo")]
        pub u_uinfo: Option<UUInfo>,
        #[rasn(tag(context, 26), identifier = "standardExtensions")]
        pub standard_extensions: Option<StandardExtensions>,
        #[rasn(tag(context, 30), identifier = "recordExtensions")]
        pub record_extensions: Option<RecordExtensions>,
        #[rasn(tag(context, 31), identifier = "b-PartyCategory")]
        pub b_party_category: Option<BPartyCategory>,
        #[rasn(tag(context, 32), identifier = "iSUPPreferred")]
        pub i_suppreferred: Option<ISUPPreferred>,
        #[rasn(tag(context, 33), identifier = "networkManagementControls")]
        pub network_management_controls: Option<NetworkManagementControls>,
        #[rasn(tag(context, 34))]
        pub glare: Option<Glare>,
        #[rasn(tag(context, 35), identifier = "recordId")]
        pub record_id: Option<RecordId>,
        #[rasn(tag(context, 36), identifier = "dataValidity")]
        pub data_validity: Option<DataValidity>,
        #[rasn(tag(context, 37), identifier = "callStatus")]
        pub call_status: Option<CallStatus>,
        #[rasn(tag(context, 38), identifier = "carrierId")]
        pub carrier_id: Option<CarrierId>,
        #[rasn(tag(context, 39), identifier = "dPC")]
        pub d_pc: Option<PointCode>,
        #[rasn(tag(context, 40), identifier = "oPC")]
        pub o_pc: Option<PointCode>,
    }
    impl CallRecord {
        pub fn new(
            record_type: RecordType,
            start_time_stamp: StartTimeStamp,
            participant_info: ParticipantInfo,
            bearer_service: BearerService,
            service_user: ServiceUser,
            call_identification_number: CallIdentificationNumber,
            supplementary_services: Option<SupplementaryServices>,
            immediate_notification_for_usage_metering: Option<ImmediateNotification>,
            cause: Option<Cause>,
            i_nspecific_info: Option<INSpecificInfo>,
            partial_generation: Option<PartialGeneration>,
            exchange_info: Option<ExchangeInfo>,
            related_call_number: Option<RelatedCallNumber>,
            c_drpurpose: Option<CDRPurpose>,
            additional_participant_info: Option<AdditionalParticipantInfo>,
            calling_party_category: Option<CallingPartyCategory>,
            calling_party_type: Option<CallingPartyType>,
            charging_information: Option<ChargingInformation>,
            progress: Option<Progress>,
            access_delivery: Option<AccessDelivery>,
            trunk_group_outgoing: Option<TrunkGroupOutgoing>,
            trunk_group_incoming: Option<TrunkGroupIncoming>,
            fallback_bearer_service: Option<FallbackBearerService>,
            teleservice: Option<Teleservice>,
            call_duration: Option<CallDuration>,
            u_uinfo: Option<UUInfo>,
            standard_extensions: Option<StandardExtensions>,
            record_extensions: Option<RecordExtensions>,
            b_party_category: Option<BPartyCategory>,
            i_suppreferred: Option<ISUPPreferred>,
            network_management_controls: Option<NetworkManagementControls>,
            glare: Option<Glare>,
            record_id: Option<RecordId>,
            data_validity: Option<DataValidity>,
            call_status: Option<CallStatus>,
            carrier_id: Option<CarrierId>,
            d_pc: Option<PointCode>,
            o_pc: Option<PointCode>,
        ) -> Self {
            Self {
                record_type,
                start_time_stamp,
                participant_info,
                bearer_service,
                service_user,
                call_identification_number,
                supplementary_services,
                immediate_notification_for_usage_metering,
                cause,
                i_nspecific_info,
                partial_generation,
                exchange_info,
                related_call_number,
                c_drpurpose,
                additional_participant_info,
                calling_party_category,
                calling_party_type,
                charging_information,
                progress,
                access_delivery,
                trunk_group_outgoing,
                trunk_group_incoming,
                fallback_bearer_service,
                teleservice,
                call_duration,
                u_uinfo,
                standard_extensions,
                record_extensions,
                b_party_category,
                i_suppreferred,
                network_management_controls,
                glare,
                record_id,
                data_validity,
                call_status,
                carrier_id,
                d_pc,
                o_pc,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CallStatus {
        answered = 0,
        notanswered = 1,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CalledPartyNumber(pub Number);
    #[doc = "\tOctet string identifying the call."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallingPartyCategory(pub FixedBitString<8usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallingPartyNumber(pub Number);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallingPartyNumberNotScreened(pub Number);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CallingPartyType {
        analogue = 0,
        customerLink = 1,
        basicAccess = 2,
        primaryRateAccess = 3,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=11"))]
    pub struct CarrierId(pub VisibleString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Cause {
        #[rasn(identifier = "causeValue")]
        pub cause_value: CauseValue,
        pub location: Location,
    }
    impl Cause {
        pub fn new(cause_value: CauseValue, location: Location) -> Self {
            Self {
                cause_value,
                location,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CauseValue(pub FixedBitString<8usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ChargedDirectoryNumber(pub Number);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ChargedParticipant(pub ParticipantType);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ChargingInformation {
        #[rasn(tag(context, 0))]
        recordedCurrency(RecordedCurrency),
        #[rasn(tag(context, 1))]
        recordedUnitsList(RecordedUnitsList),
        #[rasn(tag(context, 2))]
        freeOfCharge(()),
        #[rasn(tag(context, 3))]
        chargeInfoNotAvailable(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ConfigurationMask(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ConversationTime(pub Duration);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=3"))]
    pub struct Count(pub OctetString);
    #[doc = "\tA maximum 3-byte counter."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CreateFileResponse {
        #[rasn(identifier = "fileName")]
        pub file_name: GraphicString,
        #[rasn(identifier = "fileSize")]
        pub file_size: Option<Integer>,
    }
    impl CreateFileResponse {
        pub fn new(file_name: GraphicString, file_size: Option<Integer>) -> Self {
            Self {
                file_name,
                file_size,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CreationTrigger {
        seizure = 0,
        firstDigitReceived = 1,
        aCMReceived = 2,
        aNMReceived = 3,
        supplementaryServiceInvocation = 4,
        supplementaryServiceInput = 5,
    }
    #[doc = "  \tnumber of octets in file."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CreationTriggerList(pub SetOf<CreationTrigger>);
    #[doc = "\tACMreceived is defined as the receipt of ACM for an external call. In the case of a"]
    #[doc = "\tterminating exchange the event ACM received will occur when the ACM is normally"]
    #[doc = "\tgenerated. This is either when a B-subscriber port is free (early ACM) or when"]
    #[doc = "\ta B-subscriber terminal is free (late ACM)."]
    #[doc = "\tThe choice between early and late ACM is a network option in the terminating network."]
    #[doc = "\t For local calls a corresponding time shall be used."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum DataValidity {
        possibleduplicated = 0,
        requireddatamissing = 1,
        other = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=3"))]
    pub struct Duration(pub OctetString);
    #[doc = "\tDuration in centiseconds. Maximum value in centiseconds is approx. 46 hours."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DurationTimeACM(pub Duration);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DurationTimeANM(pub Duration);
    #[doc = "fix to match reference syntax"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DurationTimeNoANM(pub Duration);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=11"))]
    pub struct ExchangeID(pub VisibleString);
    #[doc = "fix to match reference syntax"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct ExchangeInfo {
        #[rasn(tag(context, 0), identifier = "exchangeID")]
        pub exchange_id: Option<ExchangeID>,
        #[rasn(tag(context, 1), identifier = "softwareVersion")]
        pub software_version: Option<SoftwareVersion>,
    }
    impl ExchangeInfo {
        pub fn new(
            exchange_id: Option<ExchangeID>,
            software_version: Option<SoftwareVersion>,
        ) -> Self {
            Self {
                exchange_id,
                software_version,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FallbackBearerService(pub BearerService);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct FileCreationInfo {
        #[rasn(identifier = "fileName")]
        pub file_name: FileName,
        #[rasn(identifier = "reasonForOutput")]
        pub reason_for_output: ReasonForOutput,
    }
    impl FileCreationInfo {
        pub fn new(file_name: FileName, reason_for_output: ReasonForOutput) -> Self {
            Self {
                file_name,
                reason_for_output,
            }
        }
    }
    #[doc = " FILE CONTENTS"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct FileHeaderRecord {
        #[rasn(identifier = "productionDateTime")]
        pub production_date_time: StartDateTime,
        #[rasn(identifier = "exchangeInfo")]
        pub exchange_info: ExchangeInfo,
        #[rasn(identifier = "fileName")]
        pub file_name: FileName,
        #[rasn(identifier = "reasonForOutput")]
        pub reason_for_output: ReasonForOutput,
        #[rasn(identifier = "firstRecordId")]
        pub first_record_id: Option<RecordId>,
        pub extensions: Option<ManagementExtensions>,
    }
    impl FileHeaderRecord {
        pub fn new(
            production_date_time: StartDateTime,
            exchange_info: ExchangeInfo,
            file_name: FileName,
            reason_for_output: ReasonForOutput,
            first_record_id: Option<RecordId>,
            extensions: Option<ManagementExtensions>,
        ) -> Self {
            Self {
                production_date_time,
                exchange_info,
                file_name,
                reason_for_output,
                first_record_id,
                extensions,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FileName(pub NameType);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct Glare(pub bool);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct INServiceCode(pub FixedOctetString<2usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct INServiceInformation {
        #[rasn(tag(context, 0), identifier = "inServiceCode")]
        pub in_service_code: INServiceCode,
        #[rasn(tag(context, 1), identifier = "queueInfo")]
        pub queue_info: Option<QueueInfo>,
        #[rasn(tag(context, 2), identifier = "serviceSpecificINInformation")]
        pub service_specific_ininformation: Option<OctetString>,
    }
    impl INServiceInformation {
        pub fn new(
            in_service_code: INServiceCode,
            queue_info: Option<QueueInfo>,
            service_specific_ininformation: Option<OctetString>,
        ) -> Self {
            Self {
                in_service_code,
                queue_info,
                service_specific_ininformation,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct INServiceInformationList(pub SequenceOf<INServiceInformation>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct INSpecificInfo {
        #[rasn(tag(context, 0), identifier = "personalUserId")]
        pub personal_user_id: Option<PersonalUserId>,
        #[rasn(tag(context, 1), identifier = "chargedParticipant")]
        pub charged_participant: Option<ChargedParticipant>,
        #[rasn(tag(context, 2), identifier = "chargedDirectoryNumber")]
        pub charged_directory_number: Option<ChargedDirectoryNumber>,
        #[rasn(tag(context, 3), identifier = "percentageToBeBilled")]
        pub percentage_to_be_billed: Option<PercentageToBeBilled>,
        #[rasn(tag(context, 4), identifier = "accountCodeInput")]
        pub account_code_input: Option<AccountCodeInput>,
        #[rasn(tag(context, 5), identifier = "iNServiceCode")]
        pub i_nservice_code: Option<INServiceCode>,
        #[rasn(tag(context, 6), identifier = "queueInfo")]
        pub queue_info: Option<QueueInfo>,
        #[rasn(tag(context, 7), identifier = "serviceSpecificINInformation")]
        pub service_specific_ininformation: Option<ServiceSpecificINInformation>,
    }
    impl INSpecificInfo {
        pub fn new(
            personal_user_id: Option<PersonalUserId>,
            charged_participant: Option<ChargedParticipant>,
            charged_directory_number: Option<ChargedDirectoryNumber>,
            percentage_to_be_billed: Option<PercentageToBeBilled>,
            account_code_input: Option<AccountCodeInput>,
            i_nservice_code: Option<INServiceCode>,
            queue_info: Option<QueueInfo>,
            service_specific_ininformation: Option<ServiceSpecificINInformation>,
        ) -> Self {
            Self {
                personal_user_id,
                charged_participant,
                charged_directory_number,
                percentage_to_be_billed,
                account_code_input,
                i_nservice_code,
                queue_info,
                service_specific_ininformation,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ISUPPreferred {
        preferred = 0,
        notrequired = 1,
        required = 2,
        notapplicable = 3,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct ImmediateNotification(pub bool);
    #[doc = " \tSupporting productions"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Integer(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Location(pub Integer);
    #[doc = "\ttime interval in seconds."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ManagementExtensions(pub SetOf<ManagementExtension>);
    #[doc = "\tSee  ITU-T Recommendation Q.850, 2.2.3"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=32767"))]
    pub struct MaxBlockSize(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=32767"))]
    pub struct MaxTimeInterval(pub u16);
    #[doc = " \tA set of network/manufacturer specific extensions."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum Multiplier {
        oneThousandth = 0,
        oneHundredth = 1,
        oneTenth = 2,
        one = 3,
        ten = 4,
        hundred = 5,
        thousand = 6,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum NetworkManagementControls {
        acc = 0,
        adc = 1,
        cancelFrom = 2,
        cancelRerouted = 3,
        cancelTo = 4,
        destinationCodeControl = 5,
        scr = 6,
        skip = 7,
        tarfrom = 8,
        tarto = 9,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=11"))]
    pub struct NetworkProviderId(pub VisibleString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=14"))]
    pub struct Number(pub OctetString);
    #[doc = " \tThis type is used to represent a number for addressing purposes. It is composed of:"]
    #[doc = " \ta)\tone octet for odd/even indicator and nature of address indicator:"]
    #[doc = "\t\t\tbits\t8:\t\tOdd/even indicator"]
    #[doc = "\t\t\t\t0\t\teven number of address signals"]
    #[doc = "\t\t\t\t1\t\todd number of address signals"]
    #[doc = " \t\t\tbits\t7654321:\tNature of address indicator"]
    #[doc = "\t\t\t\t0000000\tspare"]
    #[doc = "\t\t\t\t0000001\tsubscriber number"]
    #[doc = "\t\t\t\t0000010\tunknown"]
    #[doc = "\t\t\t\t0000011\tnational (significant) number"]
    #[doc = "\t\t\t\t0000100\tinternational number"]
    #[doc = "\t\t\t\t0000101\t("]
    #[doc = "\t\t\t\tto\t(\tspare"]
    #[doc = "\t\t\t\t1101111\t("]
    #[doc = "\t\t\t\t1110000\t("]
    #[doc = "\t\t\t\tto\t(\treserved for national use"]
    #[doc = "\t\t\t\t1111110\t("]
    #[doc = "\t\t\t\t1111111\tspare"]
    #[doc = "\tb)\tone octet for numbering plan indicator:"]
    #[doc = "\t\t\tbits\t765:\t\tnumbering plan indicator"]
    #[doc = "\t\t\t\t000\t\tspare"]
    #[doc = "\t\t\t\t001\t\tISDN (Telephony) Number Plan (ITU-T Recommendation E.164)"]
    #[doc = "\t\t \t\t010\t\tspare"]
    #[doc = "\t\t\t\t011\t\tdata numbering plan (ITU-T Recommendation  X.121)"]
    #[doc = "\t\t\t\t100\t\ttelex numbering plan (ITU-T Recommendation  F.69)"]
    #[doc = "\t\t\t\t101\t\treserved for national use"]
    #[doc = "\t\t\t\t110\t\treserved for national use"]
    #[doc = "\t\t\t\t111\t\tspare"]
    #[doc = "\tc)\tdigits of the address encoded as TBCD String:"]
    #[doc = "      \tThe following octets representing digits of an address encoded as a TBCD-STRING."]
    #[doc = "\tTBCD-STRING\t\t::=\tOCTETSTRING"]
    #[doc = "\tThis type (Telephony Binary Coded Decimal String) is used to represent digits from 0"]
    #[doc = "\tthrough 9, *, #, a, b, c, two digits per octet, each digit encoded 0000 to 1001 (0 to 9),"]
    #[doc = "\t1010 (*) 1011(#), 1100 (a), 1101 (b) or 1110 (c); 1111 (end of pulsing signal-ST); 0000 is"]
    #[doc = "\tused as a filler when there is an odd number of digits."]
    #[doc = "\tThe most significant address signal is sent first. Subsequent address signals are sent in"]
    #[doc = "\tsuccessive 4-bit fields."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=16777215"))]
    pub struct NumberOfUnits(pub u32);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OperatorSpecific1AdditionalNumber(pub VisibleString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OperatorSpecific1Number(pub Number);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OperatorSpecific2AdditionalNumber(pub VisibleString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OperatorSpecific2Number(pub Number);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OperatorSpecific3AdditionalNumber(pub VisibleString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OperatorSpecific3Number(pub Number);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OriginalCalledNumber(pub Number);
    #[doc = "\tA sequential number in the range 0-255 indicating the partial record generated for the same call"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct PartialGeneration {
        #[rasn(tag(context, 0), identifier = "partialRecordNumber")]
        pub partial_record_number: PartialRecordNumber,
        #[rasn(tag(context, 1), identifier = "partialRecordReason")]
        pub partial_record_reason: PartialRecordReason,
    }
    impl PartialGeneration {
        pub fn new(
            partial_record_number: PartialRecordNumber,
            partial_record_reason: PartialRecordReason,
        ) -> Self {
            Self {
                partial_record_number,
                partial_record_reason,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PartialRecordNumber(pub FixedBitString<8usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum PartialRecordReason {
        timeLimit = 0,
        serviceChange = 1,
        overflow = 2,
        networkInternalReasons = 3,
        lastCDR = 4,
        timeChange = 5,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ParticipantId {
        #[rasn(tag(context, 0))]
        callingPartyNumber(CallingPartyNumber),
        #[rasn(tag(context, 1))]
        calledPartyNumber(CalledPartyNumber),
        #[rasn(tag(context, 2))]
        redirectingNumber(RedirectingNumber),
        #[rasn(tag(context, 3))]
        redirectionNumber(RedirectionNumber),
        #[rasn(tag(context, 4))]
        originalCalledNumber(OriginalCalledNumber),
        #[rasn(tag(context, 5))]
        callingPartyNumberNotScreened(CallingPartyNumberNotScreened),
        #[rasn(tag(context, 6))]
        operatorSpecific1Number(OperatorSpecific1Number),
        #[rasn(tag(context, 7))]
        operatorSpecific2Number(OperatorSpecific2Number),
        #[rasn(tag(context, 8))]
        operatorSpecific3Number(OperatorSpecific3Number),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ParticipantInfo(pub SetOf<ParticipantId>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ParticipantType {
        callingPartyNumber = 0,
        calledPartyNumber = 1,
        redirectingNumber = 2,
        redirectionNumber = 3,
        originalCalledNumber = 4,
        callingPartyNumberNotScreened = 5,
        operatorSpecific1Number = 6,
        operatorSpecific2Number = 7,
        operatorSpecific3Number = 8,
        operator = 9,
        unknown = 10,
    }
    #[doc = "   Elapsed time in minutes"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=99"))]
    pub struct PercentageToBeBilled(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=512"))]
    pub struct Period(pub u16);
    #[doc = "Subtype to use with  permitted values for reporting triggers from usage metering"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("0..=1"))]
    pub struct PermittedReportingTriggers(pub ReportingTriggers);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=10"))]
    pub struct PersonalUserId(pub OctetString);
    #[doc = " \tThis type is used to represent the Personal User Id. For UMT the Personal User Id is defined"]
    #[doc = "\taccording to E.212 as an International Mobile Station Identity (IMSI). Accordingly only numerical"]
    #[doc = "\tcharacters (0-9) are used."]
    #[doc = "\tThe PersonalNumber type does however not exclude the use of other formats. These formats"]
    #[doc = "\tcan be indicated in the numbering plan indicator."]
    #[doc = "\tThe type is composed of:"]
    #[doc = "\ta)\tone octet for odd/even indicator and numbering plan indicator:"]
    #[doc = "\t\t\tbits\t8:\tOdd/even indicator"]
    #[doc = "\t\t\t\t0\teven number of address signals"]
    #[doc = "\t\t\t\t1\todd number of address signals"]
    #[doc = "\t\t\tbits\t765:\tnumbering plan indicator"]
    #[doc = "\t\t\t\t000\tE.212 (IMSEI)"]
    #[doc = "\t\t\t\t001\tISDN (Telephony) Number Plan (ITU-T Recommendation E.164)"]
    #[doc = "\t\t\t\t010\tspare"]
    #[doc = "\t\t\t\t011\tspare"]
    #[doc = "\t\t\t\t100\tspare"]
    #[doc = "\tb)\tdigits of the address encoded as TBCD String:"]
    #[doc = "\tThe following octets representing the personal number encoded as a TBCD-STRING."]
    #[doc = " \tTBCD-STRING\t::=\tOCTET STRING"]
    #[doc = "\tThis type (Telephony Binary Coded Decimal String) is used to represent digits from 0"]
    #[doc = "\tthrough 9, *, #, a, b, c, two digits per octet, each digit encoded 0000 to 1001 (0 to 9),"]
    #[doc = "\t1010 (*), 1011(#), 1100 (a), 1101 (b) or 1110 (c); 1111 (end of pulsing signal-ST); 0000 is"]
    #[doc = "\tused as a filler when there is an odd number of digits."]
    #[doc = "\tThe most significant address signal is sent first. Subsequent address signals are sent in"]
    #[doc = "\tsuccessive 4-bit fields."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PhysicalLineCode(pub VisibleString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Progress {
        pub description: ProgressDescription,
        pub location: Location,
    }
    impl Progress {
        pub fn new(description: ProgressDescription, location: Location) -> Self {
            Self {
                description,
                location,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ProgressDescription(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct QueueInfo {
        #[rasn(tag(context, 0), identifier = "queueTimeStamp")]
        pub queue_time_stamp: StartDateTime,
        #[rasn(tag(context, 1), identifier = "queueDuration")]
        pub queue_duration: Duration,
    }
    impl QueueInfo {
        pub fn new(queue_time_stamp: StartDateTime, queue_duration: Duration) -> Self {
            Self {
                queue_time_stamp,
                queue_duration,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ReasonForOutput {
        absoluteTimeEvent = 0,
        maxBlockSizeReached = 1,
        maxTimeIntervalElapsed = 2,
        internalSizeLimitReached = 3,
        oSAction = 4,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=18"))]
    pub struct ReceivedDigits(pub OctetString);
    #[doc = " USAGE METERING RECORDS"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum RecordContent {
        #[rasn(tag(context, 0))]
        callRecord(CallRecord),
        #[rasn(tag(context, 1))]
        supplServiceInputRecord(SupplServiceInputRecord),
        #[rasn(tag(context, 2))]
        standardAdditionalRecordTypes(ManagementExtensions),
        #[rasn(tag(context, 3))]
        additionalRecordTypes(ManagementExtensions),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RecordExtensions(pub ManagementExtensions);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RecordId(pub Count);
    #[doc = "The record Id is a sequence number that is incremented for each logged CDR,"]
    #[doc = "it is generated by the log"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RecordType(pub Integer);
    #[doc = "\tThis type is used to represent digits input by the subscriber. It is composed of:"]
    #[doc = "\ta)\tone octet for odd/even indicator:"]
    #[doc = "\t\t\tbits\t8:\tOdd/even indicator"]
    #[doc = "\t\t\t\t0\teven number of address signals"]
    #[doc = "\t\t\t\t1\todd number of address signals"]
    #[doc = "\tb)\tdigits of the address encoded as TBCD String"]
    #[doc = "      \tThe following octets representing the received digits encoded as a TBCD-STRING."]
    #[doc = " \tTBCD-STRING\t::=\tOCTET STRING"]
    #[doc = "\tThis type (Telephony Binary Coded Decimal String) is used to represent digits from 0"]
    #[doc = "\tthrough 9, *, #, a, b, c, two digits per octet, each digit encoded 0000 to 1001 (0 to 9),"]
    #[doc = "\t1010 (*), 1011(#), 1100 (a), 1101 (b) or 1110 (c); 1111 (end of pulsing signal-ST);"]
    #[doc = "\t0000 is used as a filler when there is an odd number of digits."]
    #[doc = "\tThe most significant address signal is sent first. Subsequent address signals are sent in"]
    #[doc = "\tsuccessive 4-bit fields."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum RecordedCurrency {
        #[rasn(size("1..=10"), tag(context, 0))]
        currency(Ia5String),
        #[rasn(tag(context, 1))]
        amount(Amount),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum RecordedUnitsUnits {
        #[rasn(tag(context, 0))]
        recordedNumberOfUnits(NumberOfUnits),
        #[rasn(tag(context, 1))]
        notAvailable(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct RecordedUnits {
        pub units: RecordedUnitsUnits,
        #[rasn(value("1..=16"), identifier = "recordedTypeOfUnits")]
        pub recorded_type_of_units: Option<u8>,
    }
    impl RecordedUnits {
        pub fn new(units: RecordedUnitsUnits, recorded_type_of_units: Option<u8>) -> Self {
            Self {
                units,
                recorded_type_of_units,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=32"))]
    pub struct RecordedUnitsList(pub SequenceOf<RecordedUnits>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RedirectingNumber(pub Number);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RedirectionNumber(pub Number);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RelatedCallNumber(pub CallIdentificationNumber);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SequenceNumber(pub Count);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ServiceSpecificINInformation(pub ManagementExtensions);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ServiceUser(pub ParticipantType);
    #[doc = " The record block sequence number is incremented for each block generation"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=12"))]
    pub struct SoftwareVersion(pub VisibleString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct StandardExtensions(pub ManagementExtensions);
    #[doc = "\tEvent time is used in connection with supplementary service input  records."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct StartDateTime(pub FixedOctetString<7usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum StartTimeStamp {
        #[rasn(tag(context, 0))]
        answerTime(StartDateTime),
        #[rasn(tag(context, 1))]
        seizureTime(StartDateTime),
        #[rasn(tag(context, 2))]
        partialTime(StartDateTime),
        #[rasn(tag(context, 3))]
        eventTime(StartDateTime),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SupplServiceInputRecord(pub CallRecord);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum SupplementaryAction {
        provision = 0,
        withdrawal = 1,
        registration = 2,
        erasure = 3,
        activation = 4,
        deactivation = 5,
        invocation = 6,
        disabling = 7,
        interrogation = 8,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SupplementaryService {
        #[rasn(identifier = "supplementaryServiceCode")]
        pub supplementary_service_code: SupplementaryServiceCode,
        #[rasn(identifier = "supplementaryAction")]
        pub supplementary_action: SupplementaryAction,
        pub supplementarytimestamp: Option<Duration>,
        #[rasn(identifier = "functionalInformation")]
        pub functional_information: Option<ManagementExtensions>,
    }
    impl SupplementaryService {
        pub fn new(
            supplementary_service_code: SupplementaryServiceCode,
            supplementary_action: SupplementaryAction,
            supplementarytimestamp: Option<Duration>,
            functional_information: Option<ManagementExtensions>,
        ) -> Self {
            Self {
                supplementary_service_code,
                supplementary_action,
                supplementarytimestamp,
                functional_information,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SupplementaryServiceCode(pub FixedOctetString<2usize>);
    #[doc = "\tYYMMDDHHmmSSCC (Year, Month, Day, Hour, Minute, Second, Centisecond),"]
    #[doc = "\teach field one digit, two digits per octet, the digits 0 through 9, encoded as"]
    #[doc = "\t0000 to 1001 \"hstring\". 1st digit in the LSB."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SupplementaryServices(pub SequenceOf<SupplementaryService>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Teleservice(pub FixedBitString<8usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TimesOfDay(pub FixedOctetString<2usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Trailer {
        #[rasn(tag(context, 0), identifier = "numberOfRecords")]
        pub number_of_records: Integer,
        #[rasn(tag(context, 1), identifier = "lastRecordId")]
        pub last_record_id: Integer,
    }
    impl Trailer {
        pub fn new(number_of_records: Integer, last_record_id: Integer) -> Self {
            Self {
                number_of_records,
                last_record_id,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct TrunkGroupId {
        #[rasn(tag(context, 0), identifier = "trunkGroupId")]
        pub trunk_group_id: NameType,
        #[rasn(tag(context, 1), identifier = "trunkId")]
        pub trunk_id: Option<NameType>,
        #[rasn(tag(context, 2), identifier = "pCMId")]
        pub p_cmid: Option<NameType>,
        #[rasn(tag(context, 3), identifier = "channelNumber")]
        pub channel_number: Option<Integer>,
    }
    impl TrunkGroupId {
        pub fn new(
            trunk_group_id: NameType,
            trunk_id: Option<NameType>,
            p_cmid: Option<NameType>,
            channel_number: Option<Integer>,
        ) -> Self {
            Self {
                trunk_group_id,
                trunk_id,
                p_cmid,
                channel_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TrunkGroupIncoming(pub TrunkGroupId);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TrunkGroupOutgoing(pub TrunkGroupId);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct UUInfo {
        #[rasn(tag(context, 0), identifier = "uu1Info")]
        pub uu1_info: Option<UUxInfo>,
        #[rasn(tag(context, 1), identifier = "uu2Info")]
        pub uu2_info: Option<UUxInfo>,
        #[rasn(tag(context, 2), identifier = "uu3Info")]
        pub uu3_info: Option<UUxInfo>,
    }
    impl UUInfo {
        pub fn new(
            uu1_info: Option<UUxInfo>,
            uu2_info: Option<UUxInfo>,
            uu3_info: Option<UUxInfo>,
        ) -> Self {
            Self {
                uu1_info,
                uu2_info,
                uu3_info,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct UUxInfo {
        #[rasn(tag(context, 0), identifier = "receivedMessages")]
        pub received_messages: Option<Count>,
        #[rasn(tag(context, 1), identifier = "transmittedMessages")]
        pub transmitted_messages: Option<Count>,
        #[rasn(tag(context, 2), identifier = "receivedOctets")]
        pub received_octets: Option<Count>,
        #[rasn(tag(context, 3), identifier = "transmittedOctets")]
        pub transmitted_octets: Option<Count>,
    }
    impl UUxInfo {
        pub fn new(
            received_messages: Option<Count>,
            transmitted_messages: Option<Count>,
            received_octets: Option<Count>,
            transmitted_octets: Option<Count>,
        ) -> Self {
            Self {
                received_messages,
                transmitted_messages,
                received_octets,
                transmitted_octets,
            }
        }
    }
    #[doc = " \tDEFAULT VALUE DEFINITION"]
    pub static DEFAULT_CREATION_TRIGGER: LazyLock<CreationTriggerList> =
        LazyLock::new(|| CreationTriggerList(alloc::vec![]));
    #[doc = "see Rec. X.742"]
    #[doc = " OBJECT IDENTIFIERS"]
    pub static Q825_INFORMATION_MODEL: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[0u32, 0u32, 17u32, 825u32, 0u32]).to_owned());
    pub static Q825_ACTION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***Q825_INFORMATION_MODEL, &[7u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static Q825_ATTRIBUTE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***Q825_INFORMATION_MODEL, &[6u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static Q825_NAME_BINDING: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***Q825_INFORMATION_MODEL, &[5u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static Q825_NOTIFICATION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***Q825_INFORMATION_MODEL, &[8u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static Q825_OBJECT_CLASS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***Q825_INFORMATION_MODEL, &[3u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static Q825_PACKAGE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***Q825_INFORMATION_MODEL, &[4u32]].concat())
            .unwrap()
            .to_owned()
    });
}
