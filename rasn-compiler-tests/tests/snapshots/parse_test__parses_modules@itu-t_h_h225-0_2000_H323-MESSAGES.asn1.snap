---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_h_h225-0_2000_H323-MESSAGES.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to resolve supertype HASHED of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod h323_messages {
    extern crate alloc;
    use super::h235_security_messages::*;
    use super::multimedia_system_control::{DataProtocolCapability, T38FaxProfile};
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ANSI41UIMSystemId {
        #[rasn(size("1..=4"))]
        sid(TBCDSTRING),
        #[rasn(size("1..=4"))]
        mid(TBCDSTRING),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "ANSI-41-UIM")]
    #[non_exhaustive]
    pub struct ANSI41UIM {
        #[rasn(size("3..=16"))]
        pub imsi: Option<TBCDSTRING>,
        #[rasn(size("3..=16"))]
        pub min: Option<TBCDSTRING>,
        #[rasn(size("3..=16"))]
        pub mdn: Option<TBCDSTRING>,
        #[rasn(size("3..=16"))]
        pub msisdn: Option<TBCDSTRING>,
        #[rasn(size("16"))]
        pub esn: Option<TBCDSTRING>,
        #[rasn(size("3..=16"))]
        pub mscid: Option<TBCDSTRING>,
        #[rasn(identifier = "system-id")]
        pub system_id: ANSI41UIMSystemId,
        #[rasn(size("1"), identifier = "systemMyTypeCode")]
        pub system_my_type_code: Option<OctetString>,
        #[rasn(size("1"), identifier = "systemAccessType")]
        pub system_access_type: Option<OctetString>,
        #[rasn(size("1"), identifier = "qualificationInformationCode")]
        pub qualification_information_code: Option<OctetString>,
        #[rasn(size("16"))]
        pub sesn: Option<TBCDSTRING>,
        #[rasn(size("3..=16"))]
        pub soc: Option<TBCDSTRING>,
    }
    impl ANSI41UIM {
        pub fn new(
            imsi: Option<TBCDSTRING>,
            min: Option<TBCDSTRING>,
            mdn: Option<TBCDSTRING>,
            msisdn: Option<TBCDSTRING>,
            esn: Option<TBCDSTRING>,
            mscid: Option<TBCDSTRING>,
            system_id: ANSI41UIMSystemId,
            system_my_type_code: Option<OctetString>,
            system_access_type: Option<OctetString>,
            qualification_information_code: Option<OctetString>,
            sesn: Option<TBCDSTRING>,
            soc: Option<TBCDSTRING>,
        ) -> Self {
            Self {
                imsi,
                min,
                mdn,
                msisdn,
                esn,
                mscid,
                system_id,
                system_my_type_code,
                system_access_type,
                qualification_information_code,
                sesn,
                soc,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct AddressPatternRange {
        #[rasn(identifier = "startOfRange")]
        pub start_of_range: PartyNumber,
        #[rasn(identifier = "endOfRange")]
        pub end_of_range: PartyNumber,
    }
    impl AddressPatternRange {
        pub fn new(start_of_range: PartyNumber, end_of_range: PartyNumber) -> Self {
            Self {
                start_of_range,
                end_of_range,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AddressPattern {
        wildcard(AliasAddress),
        range(AddressPatternRange),
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IA5String", size("1..=32"))]
    pub struct AnonymousAdmissionConfirmLanguage(pub Ia5String);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AdmissionConfirmLanguage(pub SequenceOf<AnonymousAdmissionConfirmLanguage>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AdmissionConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "callModel")]
        pub call_model: CallModel,
        #[rasn(identifier = "destCallSignalAddress")]
        pub dest_call_signal_address: TransportAddress,
        #[rasn(value("1..=65535"), identifier = "irrFrequency")]
        pub irr_frequency: Option<u16>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "destinationInfo")]
        pub destination_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "destinationType")]
        pub destination_type: Option<EndpointType>,
        #[rasn(extension_addition, identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "transportQOS")]
        pub transport_qos: Option<TransportQOS>,
        #[rasn(extension_addition, identifier = "willRespondToIRR")]
        pub will_respond_to_irr: bool,
        #[rasn(extension_addition, identifier = "uuiesRequested")]
        pub uuies_requested: UUIEsRequested,
        #[rasn(extension_addition)]
        pub language: Option<AdmissionConfirmLanguage>,
        #[rasn(extension_addition, identifier = "alternateTransportAddresses")]
        pub alternate_transport_addresses: Option<AlternateTransportAddresses>,
        #[rasn(extension_addition, identifier = "useSpecifiedTransport")]
        pub use_specified_transport: Option<UseSpecifiedTransport>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
        #[rasn(extension_addition, identifier = "usageSpec")]
        pub usage_spec: Option<SequenceOf<RasUsageSpecification>>,
        #[rasn(extension_addition, identifier = "supportedProtocols")]
        pub supported_protocols: Option<SequenceOf<SupportedProtocols>>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: Option<bool>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl AdmissionConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            band_width: BandWidth,
            call_model: CallModel,
            dest_call_signal_address: TransportAddress,
            irr_frequency: Option<u16>,
            non_standard_data: Option<NonStandardParameter>,
            destination_info: Option<SequenceOf<AliasAddress>>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            destination_type: Option<EndpointType>,
            remote_extension_address: Option<SequenceOf<AliasAddress>>,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            transport_qos: Option<TransportQOS>,
            will_respond_to_irr: bool,
            uuies_requested: UUIEsRequested,
            language: Option<AdmissionConfirmLanguage>,
            alternate_transport_addresses: Option<AlternateTransportAddresses>,
            use_specified_transport: Option<UseSpecifiedTransport>,
            circuit_info: Option<CircuitInfo>,
            usage_spec: Option<SequenceOf<RasUsageSpecification>>,
            supported_protocols: Option<SequenceOf<SupportedProtocols>>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            multiple_calls: Option<bool>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                band_width,
                call_model,
                dest_call_signal_address,
                irr_frequency,
                non_standard_data,
                destination_info,
                dest_extra_call_info,
                destination_type,
                remote_extension_address,
                alternate_endpoints,
                tokens,
                crypto_tokens,
                integrity_check_value,
                transport_qos,
                will_respond_to_irr,
                uuies_requested,
                language,
                alternate_transport_addresses,
                use_specified_transport,
                circuit_info,
                usage_spec,
                supported_protocols,
                service_control,
                multiple_calls,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AdmissionReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: AdmissionRejectReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "callSignalAddress")]
        pub call_signal_address: Option<SequenceOf<TransportAddress>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl AdmissionReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: AdmissionRejectReason,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            call_signal_address: Option<SequenceOf<TransportAddress>>,
            integrity_check_value: Option<ICV>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                call_signal_address,
                integrity_check_value,
                service_control,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AdmissionRejectReason {
        calledPartyNotRegistered(()),
        invalidPermission(()),
        requestDenied(()),
        undefinedReason(()),
        callerNotRegistered(()),
        routeCallToGatekeeper(()),
        invalidEndpointIdentifier(()),
        resourceUnavailable(()),
        #[rasn(extension_addition)]
        securityDenial(()),
        #[rasn(extension_addition)]
        qosControlNotSupported(()),
        #[rasn(extension_addition)]
        incompleteAddress(()),
        #[rasn(extension_addition)]
        aliasesInconsistent(()),
        #[rasn(extension_addition)]
        routeCallToSCN(SequenceOf<PartyNumber>),
        #[rasn(extension_addition)]
        exceedsCallCapacity(()),
        #[rasn(extension_addition)]
        collectDestination(()),
        #[rasn(extension_addition)]
        collectPIN(()),
        #[rasn(extension_addition)]
        genericDataReason(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AdmissionRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "callType")]
        pub call_type: CallType,
        #[rasn(identifier = "callModel")]
        pub call_model: Option<CallModel>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "destCallSignalAddress")]
        pub dest_call_signal_address: Option<TransportAddress>,
        #[rasn(identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "srcInfo")]
        pub src_info: SequenceOf<AliasAddress>,
        #[rasn(identifier = "srcCallSignalAddress")]
        pub src_call_signal_address: Option<TransportAddress>,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "callServices")]
        pub call_services: Option<QseriesOptions>,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "activeMC")]
        pub active_mc: bool,
        #[rasn(identifier = "answerCall")]
        pub answer_call: bool,
        #[rasn(extension_addition, identifier = "canMapAlias")]
        pub can_map_alias: bool,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "srcAlternatives")]
        pub src_alternatives: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition, identifier = "destAlternatives")]
        pub dest_alternatives: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "transportQOS")]
        pub transport_qos: Option<TransportQOS>,
        #[rasn(extension_addition, identifier = "willSupplyUUIEs")]
        pub will_supply_uuies: bool,
        #[rasn(extension_addition, identifier = "callLinkage")]
        pub call_linkage: Option<CallLinkage>,
        #[rasn(extension_addition, identifier = "gatewayDataRate")]
        pub gateway_data_rate: Option<DataRate>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
        #[rasn(extension_addition, identifier = "desiredProtocols")]
        pub desired_protocols: Option<SequenceOf<SupportedProtocols>>,
        #[rasn(extension_addition, identifier = "desiredTunnelledProtocol")]
        pub desired_tunnelled_protocol: Option<TunnelledProtocol>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl AdmissionRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            call_type: CallType,
            call_model: Option<CallModel>,
            endpoint_identifier: EndpointIdentifier,
            destination_info: Option<SequenceOf<AliasAddress>>,
            dest_call_signal_address: Option<TransportAddress>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            src_info: SequenceOf<AliasAddress>,
            src_call_signal_address: Option<TransportAddress>,
            band_width: BandWidth,
            call_reference_value: CallReferenceValue,
            non_standard_data: Option<NonStandardParameter>,
            call_services: Option<QseriesOptions>,
            conference_id: ConferenceIdentifier,
            active_mc: bool,
            answer_call: bool,
            can_map_alias: bool,
            call_identifier: CallIdentifier,
            src_alternatives: Option<SequenceOf<Endpoint>>,
            dest_alternatives: Option<SequenceOf<Endpoint>>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            transport_qos: Option<TransportQOS>,
            will_supply_uuies: bool,
            call_linkage: Option<CallLinkage>,
            gateway_data_rate: Option<DataRate>,
            capacity: Option<CallCapacity>,
            circuit_info: Option<CircuitInfo>,
            desired_protocols: Option<SequenceOf<SupportedProtocols>>,
            desired_tunnelled_protocol: Option<TunnelledProtocol>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                call_type,
                call_model,
                endpoint_identifier,
                destination_info,
                dest_call_signal_address,
                dest_extra_call_info,
                src_info,
                src_call_signal_address,
                band_width,
                call_reference_value,
                non_standard_data,
                call_services,
                conference_id,
                active_mc,
                answer_call,
                can_map_alias,
                call_identifier,
                src_alternatives,
                dest_alternatives,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                transport_qos,
                will_supply_uuies,
                call_linkage,
                gateway_data_rate,
                capacity,
                circuit_info,
                desired_protocols,
                desired_tunnelled_protocol,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Alerting-UUIE")]
    #[non_exhaustive]
    pub struct AlertingUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: EndpointType,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: bool,
        #[rasn(extension_addition, identifier = "maintainConnection")]
        pub maintain_connection: bool,
        #[rasn(extension_addition, identifier = "alertingAddress")]
        pub alerting_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "presentationIndicator")]
        pub presentation_indicator: Option<PresentationIndicator>,
        #[rasn(extension_addition, identifier = "screeningIndicator")]
        pub screening_indicator: Option<ScreeningIndicator>,
        #[rasn(extension_addition, identifier = "fastConnectRefused")]
        pub fast_connect_refused: Option<()>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
    }
    impl AlertingUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            destination_info: EndpointType,
            h245_address: Option<TransportAddress>,
            call_identifier: CallIdentifier,
            h245_security_mode: Option<H245Security>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
            multiple_calls: bool,
            maintain_connection: bool,
            alerting_address: Option<SequenceOf<AliasAddress>>,
            presentation_indicator: Option<PresentationIndicator>,
            screening_indicator: Option<ScreeningIndicator>,
            fast_connect_refused: Option<()>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            capacity: Option<CallCapacity>,
            feature_set: Option<FeatureSet>,
        ) -> Self {
            Self {
                protocol_identifier,
                destination_info,
                h245_address,
                call_identifier,
                h245_security_mode,
                tokens,
                crypto_tokens,
                fast_start,
                multiple_calls,
                maintain_connection,
                alerting_address,
                presentation_indicator,
                screening_indicator,
                fast_connect_refused,
                service_control,
                capacity,
                feature_set,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AliasAddress {
        #[rasn(
            size("1..=128"),
            from(
                "\u{23}", "\u{2a}", "\u{2c}", "\u{30}", "\u{31}", "\u{32}", "\u{33}", "\u{34}",
                "\u{35}", "\u{36}", "\u{37}", "\u{38}", "\u{39}"
            )
        )]
        dialedDigits(Ia5String),
        #[rasn(size("1..=256"), identifier = "h323-ID")]
        h323_ID(BmpString),
        #[rasn(extension_addition, size("1..=512"), identifier = "url-ID")]
        url_ID(Ia5String),
        #[rasn(extension_addition)]
        transportID(TransportAddress),
        #[rasn(extension_addition, size("1..=512"), identifier = "email-ID")]
        email_ID(Ia5String),
        #[rasn(extension_addition)]
        partyNumber(PartyNumber),
        #[rasn(extension_addition)]
        mobileUIM(MobileUIM),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AltGKInfo {
        #[rasn(identifier = "alternateGatekeeper")]
        pub alternate_gatekeeper: SequenceOf<AlternateGK>,
        #[rasn(identifier = "altGKisPermanent")]
        pub alt_gkis_permanent: bool,
    }
    impl AltGKInfo {
        pub fn new(
            alternate_gatekeeper: SequenceOf<AlternateGK>,
            alt_gkis_permanent: bool,
        ) -> Self {
            Self {
                alternate_gatekeeper,
                alt_gkis_permanent,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AlternateGK {
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "needToRegister")]
        pub need_to_register: bool,
        #[rasn(value("0..=127"))]
        pub priority: u8,
    }
    impl AlternateGK {
        pub fn new(
            ras_address: TransportAddress,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            need_to_register: bool,
            priority: u8,
        ) -> Self {
            Self {
                ras_address,
                gatekeeper_identifier,
                need_to_register,
                priority,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AlternateTransportAddresses {
        #[rasn(identifier = "annexE")]
        pub annex_e: Option<SequenceOf<TransportAddress>>,
    }
    impl AlternateTransportAddresses {
        pub fn new(annex_e: Option<SequenceOf<TransportAddress>>) -> Self {
            Self { annex_e }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum BandRejectReason {
        notBound(()),
        invalidConferenceID(()),
        invalidPermission(()),
        insufficientResources(()),
        invalidRevision(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=4294967295"))]
    pub struct BandWidth(pub u32);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BandwidthConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl BandwidthConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            band_width: BandWidth,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            capacity: Option<CallCapacity>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                band_width,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
                capacity,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BandwidthDetails {
        pub sender: bool,
        pub multicast: bool,
        pub bandwidth: BandWidth,
        #[rasn(identifier = "rtcpAddresses")]
        pub rtcp_addresses: TransportChannelInfo,
    }
    impl BandwidthDetails {
        pub fn new(
            sender: bool,
            multicast: bool,
            bandwidth: BandWidth,
            rtcp_addresses: TransportChannelInfo,
        ) -> Self {
            Self {
                sender,
                multicast,
                bandwidth,
                rtcp_addresses,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BandwidthReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: BandRejectReason,
        #[rasn(identifier = "allowedBandWidth")]
        pub allowed_band_width: BandWidth,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl BandwidthReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: BandRejectReason,
            allowed_band_width: BandWidth,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                allowed_band_width,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BandwidthRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "callType")]
        pub call_type: Option<CallType>,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "answeredCall")]
        pub answered_call: bool,
        #[rasn(extension_addition, identifier = "callLinkage")]
        pub call_linkage: Option<CallLinkage>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "usageInformation")]
        pub usage_information: Option<RasUsageInformation>,
        #[rasn(extension_addition, identifier = "bandwidthDetails")]
        pub bandwidth_details: Option<SequenceOf<BandwidthDetails>>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl BandwidthRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            endpoint_identifier: EndpointIdentifier,
            conference_id: ConferenceIdentifier,
            call_reference_value: CallReferenceValue,
            call_type: Option<CallType>,
            band_width: BandWidth,
            non_standard_data: Option<NonStandardParameter>,
            call_identifier: CallIdentifier,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            answered_call: bool,
            call_linkage: Option<CallLinkage>,
            capacity: Option<CallCapacity>,
            usage_information: Option<RasUsageInformation>,
            bandwidth_details: Option<SequenceOf<BandwidthDetails>>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                endpoint_identifier,
                conference_id,
                call_reference_value,
                call_type,
                band_width,
                non_standard_data,
                call_identifier,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                answered_call,
                call_linkage,
                capacity,
                usage_information,
                bandwidth_details,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CallCapacity {
        #[rasn(identifier = "maximumCallCapacity")]
        pub maximum_call_capacity: Option<CallCapacityInfo>,
        #[rasn(identifier = "currentCallCapacity")]
        pub current_call_capacity: Option<CallCapacityInfo>,
    }
    impl CallCapacity {
        pub fn new(
            maximum_call_capacity: Option<CallCapacityInfo>,
            current_call_capacity: Option<CallCapacityInfo>,
        ) -> Self {
            Self {
                maximum_call_capacity,
                current_call_capacity,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CallCapacityInfo {
        #[rasn(identifier = "voiceGwCallsAvailable")]
        pub voice_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "h310GwCallsAvailable")]
        pub h310_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "h320GwCallsAvailable")]
        pub h320_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "h321GwCallsAvailable")]
        pub h321_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "h322GwCallsAvailable")]
        pub h322_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "h323GwCallsAvailable")]
        pub h323_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "h324GwCallsAvailable")]
        pub h324_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "t120OnlyGwCallsAvailable")]
        pub t120_only_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "t38FaxAnnexbOnlyGwCallsAvailable")]
        pub t38_fax_annexb_only_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "terminalCallsAvailable")]
        pub terminal_calls_available: Option<SequenceOf<CallsAvailable>>,
        #[rasn(identifier = "mcuCallsAvailable")]
        pub mcu_calls_available: Option<SequenceOf<CallsAvailable>>,
    }
    impl CallCapacityInfo {
        pub fn new(
            voice_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            h310_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            h320_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            h321_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            h322_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            h323_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            h324_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            t120_only_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            t38_fax_annexb_only_gw_calls_available: Option<SequenceOf<CallsAvailable>>,
            terminal_calls_available: Option<SequenceOf<CallsAvailable>>,
            mcu_calls_available: Option<SequenceOf<CallsAvailable>>,
        ) -> Self {
            Self {
                voice_gw_calls_available,
                h310_gw_calls_available,
                h320_gw_calls_available,
                h321_gw_calls_available,
                h322_gw_calls_available,
                h323_gw_calls_available,
                h324_gw_calls_available,
                t120_only_gw_calls_available,
                t38_fax_annexb_only_gw_calls_available,
                terminal_calls_available,
                mcu_calls_available,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CallCreditCapability {
        #[rasn(identifier = "canDisplayAmountString")]
        pub can_display_amount_string: Option<bool>,
        #[rasn(identifier = "canEnforceDurationLimit")]
        pub can_enforce_duration_limit: Option<bool>,
    }
    impl CallCreditCapability {
        pub fn new(
            can_display_amount_string: Option<bool>,
            can_enforce_duration_limit: Option<bool>,
        ) -> Self {
            Self {
                can_display_amount_string,
                can_enforce_duration_limit,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CallCreditServiceControlBillingMode {
        credit(()),
        debit(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CallCreditServiceControlCallStartingPoint {
        alerting(()),
        connect(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CallCreditServiceControl {
        #[rasn(size("1..=512"), identifier = "amountString")]
        pub amount_string: Option<BmpString>,
        #[rasn(identifier = "billingMode")]
        pub billing_mode: Option<CallCreditServiceControlBillingMode>,
        #[rasn(value("1..=4294967295"), identifier = "callDurationLimit")]
        pub call_duration_limit: Option<u32>,
        #[rasn(identifier = "enforceCallDurationLimit")]
        pub enforce_call_duration_limit: Option<bool>,
        #[rasn(identifier = "callStartingPoint")]
        pub call_starting_point: Option<CallCreditServiceControlCallStartingPoint>,
    }
    impl CallCreditServiceControl {
        pub fn new(
            amount_string: Option<BmpString>,
            billing_mode: Option<CallCreditServiceControlBillingMode>,
            call_duration_limit: Option<u32>,
            enforce_call_duration_limit: Option<bool>,
            call_starting_point: Option<CallCreditServiceControlCallStartingPoint>,
        ) -> Self {
            Self {
                amount_string,
                billing_mode,
                call_duration_limit,
                enforce_call_duration_limit,
                call_starting_point,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CallIdentifier {
        pub guid: GloballyUniqueID,
    }
    impl CallIdentifier {
        pub fn new(guid: GloballyUniqueID) -> Self {
            Self { guid }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CallLinkage {
        #[rasn(identifier = "globalCallId")]
        pub global_call_id: Option<GloballyUniqueID>,
        #[rasn(identifier = "threadId")]
        pub thread_id: Option<GloballyUniqueID>,
    }
    impl CallLinkage {
        pub fn new(
            global_call_id: Option<GloballyUniqueID>,
            thread_id: Option<GloballyUniqueID>,
        ) -> Self {
            Self {
                global_call_id,
                thread_id,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CallModel {
        direct(()),
        gatekeeperRouted(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "CallProceeding-UUIE")]
    #[non_exhaustive]
    pub struct CallProceedingUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: EndpointType,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: bool,
        #[rasn(extension_addition, identifier = "maintainConnection")]
        pub maintain_connection: bool,
        #[rasn(extension_addition, identifier = "fastConnectRefused")]
        pub fast_connect_refused: Option<()>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
    }
    impl CallProceedingUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            destination_info: EndpointType,
            h245_address: Option<TransportAddress>,
            call_identifier: CallIdentifier,
            h245_security_mode: Option<H245Security>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
            multiple_calls: bool,
            maintain_connection: bool,
            fast_connect_refused: Option<()>,
            feature_set: Option<FeatureSet>,
        ) -> Self {
            Self {
                protocol_identifier,
                destination_info,
                h245_address,
                call_identifier,
                h245_security_mode,
                tokens,
                crypto_tokens,
                fast_start,
                multiple_calls,
                maintain_connection,
                fast_connect_refused,
                feature_set,
            }
        }
    }
    #[doc = " in 100s of bits"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=65535"))]
    pub struct CallReferenceValue(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CallTerminationCause {
        releaseCompleteReason(ReleaseCompleteReason),
        #[rasn(size("2..=32"))]
        releaseCompleteCauseIE(OctetString),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CallType {
        pointToPoint(()),
        oneToN(()),
        nToOne(()),
        nToN(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CallsAvailable {
        #[rasn(value("0..=4294967295"))]
        pub calls: u32,
        #[rasn(size("2..=4"))]
        pub group: Option<OctetString>,
    }
    impl CallsAvailable {
        pub fn new(calls: u32, group: Option<OctetString>) -> Self {
            Self { calls, group }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CapacityReportingCapability {
        #[rasn(identifier = "canReportCallCapacity")]
        pub can_report_call_capacity: bool,
    }
    impl CapacityReportingCapability {
        pub fn new(can_report_call_capacity: bool) -> Self {
            Self {
                can_report_call_capacity,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CapacityReportingSpecificationWhen {
        #[rasn(identifier = "callStart")]
        pub call_start: Option<()>,
        #[rasn(identifier = "callEnd")]
        pub call_end: Option<()>,
    }
    impl CapacityReportingSpecificationWhen {
        pub fn new(call_start: Option<()>, call_end: Option<()>) -> Self {
            Self {
                call_start,
                call_end,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CapacityReportingSpecification {
        pub when: CapacityReportingSpecificationWhen,
    }
    impl CapacityReportingSpecification {
        pub fn new(when: CapacityReportingSpecificationWhen) -> Self {
            Self { when }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "OCTET_STRING", size("2..=4"))]
    pub struct AnonymousCicInfoCic(pub OctetString);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CicInfoCic(pub SequenceOf<AnonymousCicInfoCic>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CicInfo {
        pub cic: CicInfoCic,
        #[rasn(size("2..=5"), identifier = "pointCode")]
        pub point_code: OctetString,
    }
    impl CicInfo {
        pub fn new(cic: CicInfoCic, point_code: OctetString) -> Self {
            Self { cic, point_code }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CircuitIdentifier {
        pub cic: Option<CicInfo>,
        pub group: Option<GroupID>,
    }
    impl CircuitIdentifier {
        pub fn new(cic: Option<CicInfo>, group: Option<GroupID>) -> Self {
            Self { cic, group }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CircuitInfo {
        #[rasn(identifier = "sourceCircuitID")]
        pub source_circuit_id: Option<CircuitIdentifier>,
        #[rasn(identifier = "destinationCircuitID")]
        pub destination_circuit_id: Option<CircuitIdentifier>,
        #[rasn(identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl CircuitInfo {
        pub fn new(
            source_circuit_id: Option<CircuitIdentifier>,
            destination_circuit_id: Option<CircuitIdentifier>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                source_circuit_id,
                destination_circuit_id,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ConferenceIdentifier(pub GloballyUniqueID);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceList {
        #[rasn(identifier = "conferenceID")]
        pub conference_id: Option<ConferenceIdentifier>,
        #[rasn(identifier = "conferenceAlias")]
        pub conference_alias: Option<AliasAddress>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl ConferenceList {
        pub fn new(
            conference_id: Option<ConferenceIdentifier>,
            conference_alias: Option<AliasAddress>,
            non_standard_data: Option<NonStandardParameter>,
        ) -> Self {
            Self {
                conference_id,
                conference_alias,
                non_standard_data,
            }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IA5String", size("1..=32"))]
    pub struct AnonymousConnectUUIELanguage(pub Ia5String);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ConnectUUIELanguage(pub SequenceOf<AnonymousConnectUUIELanguage>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Connect-UUIE")]
    #[non_exhaustive]
    pub struct ConnectUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: EndpointType,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: bool,
        #[rasn(extension_addition, identifier = "maintainConnection")]
        pub maintain_connection: bool,
        #[rasn(extension_addition)]
        pub language: Option<ConnectUUIELanguage>,
        #[rasn(extension_addition, identifier = "connectedAddress")]
        pub connected_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "presentationIndicator")]
        pub presentation_indicator: Option<PresentationIndicator>,
        #[rasn(extension_addition, identifier = "screeningIndicator")]
        pub screening_indicator: Option<ScreeningIndicator>,
        #[rasn(extension_addition, identifier = "fastConnectRefused")]
        pub fast_connect_refused: Option<()>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
    }
    impl ConnectUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            h245_address: Option<TransportAddress>,
            destination_info: EndpointType,
            conference_id: ConferenceIdentifier,
            call_identifier: CallIdentifier,
            h245_security_mode: Option<H245Security>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
            multiple_calls: bool,
            maintain_connection: bool,
            language: Option<ConnectUUIELanguage>,
            connected_address: Option<SequenceOf<AliasAddress>>,
            presentation_indicator: Option<PresentationIndicator>,
            screening_indicator: Option<ScreeningIndicator>,
            fast_connect_refused: Option<()>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            capacity: Option<CallCapacity>,
            feature_set: Option<FeatureSet>,
        ) -> Self {
            Self {
                protocol_identifier,
                h245_address,
                destination_info,
                conference_id,
                call_identifier,
                h245_security_mode,
                tokens,
                crypto_tokens,
                fast_start,
                multiple_calls,
                maintain_connection,
                language,
                connected_address,
                presentation_indicator,
                screening_indicator,
                fast_connect_refused,
                service_control,
                capacity,
                feature_set,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum Content {
        raw(OctetString),
        text(Ia5String),
        unicode(BmpString),
        bool(bool),
        #[rasn(value("0..=255"))]
        number8(u8),
        #[rasn(value("0..=65535"))]
        number16(u16),
        #[rasn(value("0..=4294967295"))]
        number32(u32),
        id(GenericIdentifier),
        alias(AliasAddress),
        transport(TransportAddress),
        #[rasn(size("1..=512"))]
        compound(SequenceOf<EnumeratedParameter>),
        #[rasn(size("1..=16"))]
        nested(SequenceOf<GenericData>),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoH323TokenCryptoEPPwdHash {
        pub alias: AliasAddress,
        #[rasn(identifier = "timeStamp")]
        pub time_stamp: TimeStamp,
        #[rasn(value("0.."))]
        pub token: HASHED,
    }
    impl CryptoH323TokenCryptoEPPwdHash {
        pub fn new(alias: AliasAddress, time_stamp: TimeStamp, token: HASHED) -> Self {
            Self {
                alias,
                time_stamp,
                token,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoH323TokenCryptoGKPwdHash {
        #[rasn(identifier = "gatekeeperId")]
        pub gatekeeper_id: GatekeeperIdentifier,
        #[rasn(identifier = "timeStamp")]
        pub time_stamp: TimeStamp,
        #[rasn(value("0.."))]
        pub token: HASHED,
    }
    impl CryptoH323TokenCryptoGKPwdHash {
        pub fn new(
            gatekeeper_id: GatekeeperIdentifier,
            time_stamp: TimeStamp,
            token: HASHED,
        ) -> Self {
            Self {
                gatekeeper_id,
                time_stamp,
                token,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CryptoH323Token {
        cryptoEPPwdHash(CryptoH323TokenCryptoEPPwdHash),
        cryptoGKPwdHash(CryptoH323TokenCryptoGKPwdHash),
        #[rasn(value("0.."))]
        cryptoEPPwdEncr(ENCRYPTED),
        #[rasn(value("0.."))]
        cryptoGKPwdEncr(ENCRYPTED),
        #[rasn(value("0.."))]
        cryptoEPCert(SIGNED),
        #[rasn(value("0.."))]
        cryptoGKCert(SIGNED),
        #[rasn(value("0.."))]
        cryptoFastStart(SIGNED),
        nestedcryptoToken(CryptoToken),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DataRate {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "channelRate")]
        pub channel_rate: BandWidth,
        #[rasn(value("1..=256"), identifier = "channelMultiplier")]
        pub channel_multiplier: Option<u16>,
    }
    impl DataRate {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            channel_rate: BandWidth,
            channel_multiplier: Option<u16>,
        ) -> Self {
            Self {
                non_standard_data,
                channel_rate,
                channel_multiplier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DisengageConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
        #[rasn(extension_addition, identifier = "usageInformation")]
        pub usage_information: Option<RasUsageInformation>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl DisengageConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            capacity: Option<CallCapacity>,
            circuit_info: Option<CircuitInfo>,
            usage_information: Option<RasUsageInformation>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
                capacity,
                circuit_info,
                usage_information,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DisengageReason {
        forcedDrop(()),
        normalDrop(()),
        undefinedReason(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DisengageReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: DisengageRejectReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl DisengageReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: DisengageRejectReason,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DisengageRejectReason {
        notRegistered(()),
        requestToDropOther(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DisengageRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "disengageReason")]
        pub disengage_reason: DisengageReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "answeredCall")]
        pub answered_call: bool,
        #[rasn(extension_addition, identifier = "callLinkage")]
        pub call_linkage: Option<CallLinkage>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
        #[rasn(extension_addition, identifier = "usageInformation")]
        pub usage_information: Option<RasUsageInformation>,
        #[rasn(extension_addition, identifier = "terminationCause")]
        pub termination_cause: Option<CallTerminationCause>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl DisengageRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            endpoint_identifier: EndpointIdentifier,
            conference_id: ConferenceIdentifier,
            call_reference_value: CallReferenceValue,
            disengage_reason: DisengageReason,
            non_standard_data: Option<NonStandardParameter>,
            call_identifier: CallIdentifier,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            answered_call: bool,
            call_linkage: Option<CallLinkage>,
            capacity: Option<CallCapacity>,
            circuit_info: Option<CircuitInfo>,
            usage_information: Option<RasUsageInformation>,
            termination_cause: Option<CallTerminationCause>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                endpoint_identifier,
                conference_id,
                call_reference_value,
                disengage_reason,
                non_standard_data,
                call_identifier,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                answered_call,
                call_linkage,
                capacity,
                circuit_info,
                usage_information,
                termination_cause,
                service_control,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EncodedFastStartToken(pub Any);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum EncryptIntAlg {
        nonStandard(NonStandardParameter),
        isoAlgorithm(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Endpoint {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "aliasAddress")]
        pub alias_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: Option<SequenceOf<TransportAddress>>,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: Option<SequenceOf<TransportAddress>>,
        #[rasn(identifier = "endpointType")]
        pub endpoint_type: Option<EndpointType>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(value("0..=127"))]
        pub priority: Option<u8>,
        #[rasn(identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "alternateTransportAddresses")]
        pub alternate_transport_addresses: Option<AlternateTransportAddresses>,
    }
    impl Endpoint {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            alias_address: Option<SequenceOf<AliasAddress>>,
            call_signal_address: Option<SequenceOf<TransportAddress>>,
            ras_address: Option<SequenceOf<TransportAddress>>,
            endpoint_type: Option<EndpointType>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            priority: Option<u8>,
            remote_extension_address: Option<SequenceOf<AliasAddress>>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            alternate_transport_addresses: Option<AlternateTransportAddresses>,
        ) -> Self {
            Self {
                non_standard_data,
                alias_address,
                call_signal_address,
                ras_address,
                endpoint_type,
                tokens,
                crypto_tokens,
                priority,
                remote_extension_address,
                dest_extra_call_info,
                alternate_transport_addresses,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=128"))]
    pub struct EndpointIdentifier(pub BmpString);
    #[doc = " Beginning of common message elements section"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EndpointType {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub vendor: Option<VendorIdentifier>,
        pub gatekeeper: Option<GatekeeperInfo>,
        pub gateway: Option<GatewayInfo>,
        pub mcu: Option<McuInfo>,
        pub terminal: Option<TerminalInfo>,
        pub mc: bool,
        #[rasn(identifier = "undefinedNode")]
        pub undefined_node: bool,
        #[rasn(extension_addition, size("32"))]
        pub set: Option<BitString>,
        #[rasn(extension_addition, identifier = "supportedTunnelledProtocols")]
        pub supported_tunnelled_protocols: Option<SequenceOf<TunnelledProtocol>>,
    }
    impl EndpointType {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            vendor: Option<VendorIdentifier>,
            gatekeeper: Option<GatekeeperInfo>,
            gateway: Option<GatewayInfo>,
            mcu: Option<McuInfo>,
            terminal: Option<TerminalInfo>,
            mc: bool,
            undefined_node: bool,
            set: Option<BitString>,
            supported_tunnelled_protocols: Option<SequenceOf<TunnelledProtocol>>,
        ) -> Self {
            Self {
                non_standard_data,
                vendor,
                gatekeeper,
                gateway,
                mcu,
                terminal,
                mc,
                undefined_node,
                set,
                supported_tunnelled_protocols,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EnumeratedParameter {
        pub id: GenericIdentifier,
        pub content: Option<Content>,
    }
    impl EnumeratedParameter {
        pub fn new(id: GenericIdentifier, content: Option<Content>) -> Self {
            Self { id, content }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ExtendedAliasAddress {
        pub address: AliasAddress,
        #[rasn(identifier = "presentationIndicator")]
        pub presentation_indicator: Option<PresentationIndicator>,
        #[rasn(identifier = "screeningIndicator")]
        pub screening_indicator: Option<ScreeningIndicator>,
    }
    impl ExtendedAliasAddress {
        pub fn new(
            address: AliasAddress,
            presentation_indicator: Option<PresentationIndicator>,
            screening_indicator: Option<ScreeningIndicator>,
        ) -> Self {
            Self {
                address,
                presentation_indicator,
                screening_indicator,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Facility-UUIE")]
    #[non_exhaustive]
    pub struct FacilityUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "alternativeAddress")]
        pub alternative_address: Option<TransportAddress>,
        #[rasn(identifier = "alternativeAliasAddress")]
        pub alternative_alias_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: Option<ConferenceIdentifier>,
        pub reason: FacilityReason,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<AliasAddress>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition)]
        pub conferences: Option<SequenceOf<ConferenceList>>,
        #[rasn(extension_addition, identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: bool,
        #[rasn(extension_addition, identifier = "maintainConnection")]
        pub maintain_connection: bool,
        #[rasn(extension_addition, identifier = "fastConnectRefused")]
        pub fast_connect_refused: Option<()>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "destinationInfo")]
        pub destination_info: Option<EndpointType>,
        #[rasn(extension_addition, identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
    }
    impl FacilityUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            alternative_address: Option<TransportAddress>,
            alternative_alias_address: Option<SequenceOf<AliasAddress>>,
            conference_id: Option<ConferenceIdentifier>,
            reason: FacilityReason,
            call_identifier: CallIdentifier,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            remote_extension_address: Option<AliasAddress>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            conferences: Option<SequenceOf<ConferenceList>>,
            h245_address: Option<TransportAddress>,
            fast_start: Option<SequenceOf<OctetString>>,
            multiple_calls: bool,
            maintain_connection: bool,
            fast_connect_refused: Option<()>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            circuit_info: Option<CircuitInfo>,
            feature_set: Option<FeatureSet>,
            destination_info: Option<EndpointType>,
            h245_security_mode: Option<H245Security>,
        ) -> Self {
            Self {
                protocol_identifier,
                alternative_address,
                alternative_alias_address,
                conference_id,
                reason,
                call_identifier,
                dest_extra_call_info,
                remote_extension_address,
                tokens,
                crypto_tokens,
                conferences,
                h245_address,
                fast_start,
                multiple_calls,
                maintain_connection,
                fast_connect_refused,
                service_control,
                circuit_info,
                feature_set,
                destination_info,
                h245_security_mode,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FacilityReason {
        routeCallToGatekeeper(()),
        callForwarded(()),
        routeCallToMC(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        conferenceListChoice(()),
        #[rasn(extension_addition)]
        startH245(()),
        #[rasn(extension_addition)]
        noH245(()),
        #[rasn(extension_addition)]
        newTokens(()),
        #[rasn(extension_addition)]
        featureSetUpdate(()),
        #[rasn(extension_addition)]
        forwardedElements(()),
        #[rasn(extension_addition)]
        transportedInformation(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FastStartToken(pub ClearToken);
    #[doc = " This octet string contains ASN.1 PER encoded H.248"]
    #[doc = " SignalsDescriptor"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FeatureDescriptor(pub GenericData);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FeatureSet {
        #[rasn(identifier = "replacementFeatureSet")]
        pub replacement_feature_set: bool,
        #[rasn(identifier = "neededFeatures")]
        pub needed_features: Option<SequenceOf<FeatureDescriptor>>,
        #[rasn(identifier = "desiredFeatures")]
        pub desired_features: Option<SequenceOf<FeatureDescriptor>>,
        #[rasn(identifier = "supportedFeatures")]
        pub supported_features: Option<SequenceOf<FeatureDescriptor>>,
    }
    impl FeatureSet {
        pub fn new(
            replacement_feature_set: bool,
            needed_features: Option<SequenceOf<FeatureDescriptor>>,
            desired_features: Option<SequenceOf<FeatureDescriptor>>,
            supported_features: Option<SequenceOf<FeatureDescriptor>>,
        ) -> Self {
            Self {
                replacement_feature_set,
                needed_features,
                desired_features,
                supported_features,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "GSM-UIM")]
    #[non_exhaustive]
    pub struct GSMUIM {
        #[rasn(size("3..=16"))]
        pub imsi: Option<TBCDSTRING>,
        #[rasn(size("3..=16"))]
        pub tmsi: Option<TBCDSTRING>,
        #[rasn(size("3..=16"))]
        pub msisdn: Option<TBCDSTRING>,
        #[rasn(size("16"))]
        pub imei: Option<TBCDSTRING>,
        #[rasn(size("1..=4"))]
        pub hplmn: Option<TBCDSTRING>,
        #[rasn(size("1..=4"))]
        pub vplmn: Option<TBCDSTRING>,
    }
    impl GSMUIM {
        pub fn new(
            imsi: Option<TBCDSTRING>,
            tmsi: Option<TBCDSTRING>,
            msisdn: Option<TBCDSTRING>,
            imei: Option<TBCDSTRING>,
            hplmn: Option<TBCDSTRING>,
            vplmn: Option<TBCDSTRING>,
        ) -> Self {
            Self {
                imsi,
                tmsi,
                msisdn,
                imei,
                hplmn,
                vplmn,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatekeeperConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(extension_addition, identifier = "alternateGatekeeper")]
        pub alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
        #[rasn(extension_addition, identifier = "authenticationMode")]
        pub authentication_mode: Option<AuthenticationMechanism>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "algorithmOID")]
        pub algorithm_oid: Option<ObjectIdentifier>,
        #[rasn(extension_addition)]
        pub integrity: Option<SequenceOf<IntegrityMechanism>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl GatekeeperConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            ras_address: TransportAddress,
            alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
            authentication_mode: Option<AuthenticationMechanism>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            algorithm_oid: Option<ObjectIdentifier>,
            integrity: Option<SequenceOf<IntegrityMechanism>>,
            integrity_check_value: Option<ICV>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                gatekeeper_identifier,
                ras_address,
                alternate_gatekeeper,
                authentication_mode,
                tokens,
                crypto_tokens,
                algorithm_oid,
                integrity,
                integrity_check_value,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=128"))]
    pub struct GatekeeperIdentifier(pub BmpString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatekeeperInfo {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl GatekeeperInfo {
        pub fn new(non_standard_data: Option<NonStandardParameter>) -> Self {
            Self { non_standard_data }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatekeeperReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: GatekeeperRejectReason,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl GatekeeperReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            reject_reason: GatekeeperRejectReason,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                gatekeeper_identifier,
                reject_reason,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum GatekeeperRejectReason {
        resourceUnavailable(()),
        terminalExcluded(()),
        invalidRevision(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        securityDenial(()),
        #[rasn(extension_addition)]
        genericDataReason(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatekeeperRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(identifier = "endpointType")]
        pub endpoint_type: EndpointType,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "callServices")]
        pub call_services: Option<QseriesOptions>,
        #[rasn(identifier = "endpointAlias")]
        pub endpoint_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "authenticationCapability")]
        pub authentication_capability: Option<SequenceOf<AuthenticationMechanism>>,
        #[rasn(extension_addition, identifier = "algorithmOIDs")]
        pub algorithm_oids: Option<SequenceOf<ObjectIdentifier>>,
        #[rasn(extension_addition)]
        pub integrity: Option<SequenceOf<IntegrityMechanism>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "supportsAltGK")]
        pub supports_alt_gk: Option<()>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl GatekeeperRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            ras_address: TransportAddress,
            endpoint_type: EndpointType,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            call_services: Option<QseriesOptions>,
            endpoint_alias: Option<SequenceOf<AliasAddress>>,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            authentication_capability: Option<SequenceOf<AuthenticationMechanism>>,
            algorithm_oids: Option<SequenceOf<ObjectIdentifier>>,
            integrity: Option<SequenceOf<IntegrityMechanism>>,
            integrity_check_value: Option<ICV>,
            supports_alt_gk: Option<()>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                ras_address,
                endpoint_type,
                gatekeeper_identifier,
                call_services,
                endpoint_alias,
                alternate_endpoints,
                tokens,
                crypto_tokens,
                authentication_capability,
                algorithm_oids,
                integrity,
                integrity_check_value,
                supports_alt_gk,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatewayInfo {
        pub protocol: Option<SequenceOf<SupportedProtocols>>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl GatewayInfo {
        pub fn new(
            protocol: Option<SequenceOf<SupportedProtocols>>,
            non_standard_data: Option<NonStandardParameter>,
        ) -> Self {
            Self {
                protocol,
                non_standard_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GenericData {
        pub id: GenericIdentifier,
        #[rasn(size("1..=512"))]
        pub parameters: Option<SequenceOf<EnumeratedParameter>>,
    }
    impl GenericData {
        pub fn new(
            id: GenericIdentifier,
            parameters: Option<SequenceOf<EnumeratedParameter>>,
        ) -> Self {
            Self { id, parameters }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum GenericIdentifier {
        #[rasn(value("0..=16383", extensible))]
        standard(Integer),
        oid(ObjectIdentifier),
        nonStandard(GloballyUniqueID),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GloballyUniqueID(pub FixedOctetString<16usize>);
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER", value("0..=65535"))]
    pub struct AnonymousGroupIDMember(pub u16);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GroupIDMember(pub SequenceOf<AnonymousGroupIDMember>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GroupID {
        pub member: Option<GroupIDMember>,
        #[rasn(size("1..=128"))]
        pub group: Ia5String,
    }
    impl GroupID {
        pub fn new(member: Option<GroupIDMember>, group: Ia5String) -> Self {
            Self { member, group }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H221NonStandard {
        #[rasn(value("0..=255"), identifier = "t35CountryCode")]
        pub t35_country_code: u8,
        #[rasn(value("0..=255"), identifier = "t35Extension")]
        pub t35_extension: u8,
        #[rasn(value("0..=65535"), identifier = "manufacturerCode")]
        pub manufacturer_code: u16,
    }
    impl H221NonStandard {
        pub fn new(t35_country_code: u8, t35_extension: u8, manufacturer_code: u16) -> Self {
            Self {
                t35_country_code,
                t35_extension,
                manufacturer_code,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H245Security {
        nonStandard(NonStandardParameter),
        noSecurity(()),
        tls(SecurityCapabilities),
        ipsec(SecurityCapabilities),
    }
    #[doc = " in seconds"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct H248PackagesDescriptor(pub OctetString);
    #[doc = " This octet string contains ASN.1 PER encoded H.248"]
    #[doc = " PackagesDescriptor"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct H248SignalsDescriptor(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H310Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H310Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H320Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H320Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H321Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H321Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H322Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H322Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H323UUPDUH323MessageBody {
        setup(SetupUUIE),
        callProceeding(CallProceedingUUIE),
        connect(ConnectUUIE),
        alerting(AlertingUUIE),
        information(InformationUUIE),
        releaseComplete(ReleaseCompleteUUIE),
        facility(FacilityUUIE),
        #[rasn(extension_addition)]
        progress(ProgressUUIE),
        #[rasn(extension_addition)]
        empty(()),
        #[rasn(extension_addition)]
        status(StatusUUIE),
        #[rasn(extension_addition)]
        statusInquiry(StatusInquiryUUIE),
        #[rasn(extension_addition)]
        setupAcknowledge(SetupAcknowledgeUUIE),
        #[rasn(extension_addition)]
        notify(NotifyUUIE),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H323UUPDUTunnelledSignallingMessage {
        #[rasn(identifier = "tunnelledProtocolID")]
        pub tunnelled_protocol_id: TunnelledProtocol,
        #[rasn(identifier = "messageContent")]
        pub message_content: SequenceOf<OctetString>,
        #[rasn(identifier = "tunnellingRequired")]
        pub tunnelling_required: Option<()>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl H323UUPDUTunnelledSignallingMessage {
        pub fn new(
            tunnelled_protocol_id: TunnelledProtocol,
            message_content: SequenceOf<OctetString>,
            tunnelling_required: Option<()>,
            non_standard_data: Option<NonStandardParameter>,
        ) -> Self {
            Self {
                tunnelled_protocol_id,
                message_content,
                tunnelling_required,
                non_standard_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "H323-UU-PDU")]
    #[non_exhaustive]
    pub struct H323UUPDU {
        #[rasn(identifier = "h323-message-body")]
        pub h323_message_body: H323UUPDUH323MessageBody,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "h4501SupplementaryService")]
        pub h4501_supplementary_service: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "h245Tunneling")]
        pub h245_tunneling: bool,
        #[rasn(extension_addition, identifier = "h245Control")]
        pub h245_control: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "nonStandardControl")]
        pub non_standard_control: Option<SequenceOf<NonStandardParameter>>,
        #[rasn(extension_addition, identifier = "callLinkage")]
        pub call_linkage: Option<CallLinkage>,
        #[rasn(extension_addition, identifier = "tunnelledSignallingMessage")]
        pub tunnelled_signalling_message: Option<H323UUPDUTunnelledSignallingMessage>,
        #[rasn(extension_addition, identifier = "provisionalRespToH245Tunneling")]
        pub provisional_resp_to_h245_tunneling: Option<()>,
        #[rasn(extension_addition, identifier = "stimulusControl")]
        pub stimulus_control: Option<StimulusControl>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl H323UUPDU {
        pub fn new(
            h323_message_body: H323UUPDUH323MessageBody,
            non_standard_data: Option<NonStandardParameter>,
            h4501_supplementary_service: Option<SequenceOf<OctetString>>,
            h245_tunneling: bool,
            h245_control: Option<SequenceOf<OctetString>>,
            non_standard_control: Option<SequenceOf<NonStandardParameter>>,
            call_linkage: Option<CallLinkage>,
            tunnelled_signalling_message: Option<H323UUPDUTunnelledSignallingMessage>,
            provisional_resp_to_h245_tunneling: Option<()>,
            stimulus_control: Option<StimulusControl>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                h323_message_body,
                non_standard_data,
                h4501_supplementary_service,
                h245_tunneling,
                h245_control,
                non_standard_control,
                call_linkage,
                tunnelled_signalling_message,
                provisional_resp_to_h245_tunneling,
                stimulus_control,
                generic_data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H323UserInformationUserData {
        #[rasn(value("0..=255"), identifier = "protocol-discriminator")]
        pub protocol_discriminator: u8,
        #[rasn(size("1..=131"), identifier = "user-information")]
        pub user_information: OctetString,
    }
    impl H323UserInformationUserData {
        pub fn new(protocol_discriminator: u8, user_information: OctetString) -> Self {
            Self {
                protocol_discriminator,
                user_information,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "H323-UserInformation")]
    #[non_exhaustive]
    pub struct H323UserInformation {
        #[rasn(identifier = "h323-uu-pdu")]
        pub h323_uu_pdu: H323UUPDU,
        #[rasn(identifier = "user-data")]
        pub user_data: Option<H323UserInformationUserData>,
    }
    impl H323UserInformation {
        pub fn new(h323_uu_pdu: H323UUPDU, user_data: Option<H323UserInformationUserData>) -> Self {
            Self {
                h323_uu_pdu,
                user_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H323Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H323Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H324Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H324Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct ICV {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        pub icv: BitString,
    }
    impl ICV {
        pub fn new(algorithm_oid: ObjectIdentifier, icv: BitString) -> Self {
            Self { algorithm_oid, icv }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct InfoRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "replyAddress")]
        pub reply_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "uuiesRequested")]
        pub uuies_requested: Option<UUIEsRequested>,
        #[rasn(extension_addition, identifier = "callLinkage")]
        pub call_linkage: Option<CallLinkage>,
        #[rasn(extension_addition, identifier = "usageInfoRequested")]
        pub usage_info_requested: Option<RasUsageInfoTypes>,
        #[rasn(extension_addition, identifier = "segmentedResponseSupported")]
        pub segmented_response_supported: Option<()>,
        #[rasn(
            extension_addition,
            value("0..=65535"),
            identifier = "nextSegmentRequested"
        )]
        pub next_segment_requested: Option<u16>,
        #[rasn(extension_addition, identifier = "capacityInfoRequested")]
        pub capacity_info_requested: Option<()>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl InfoRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            call_reference_value: CallReferenceValue,
            non_standard_data: Option<NonStandardParameter>,
            reply_address: Option<TransportAddress>,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            uuies_requested: Option<UUIEsRequested>,
            call_linkage: Option<CallLinkage>,
            usage_info_requested: Option<RasUsageInfoTypes>,
            segmented_response_supported: Option<()>,
            next_segment_requested: Option<u16>,
            capacity_info_requested: Option<()>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                call_reference_value,
                non_standard_data,
                reply_address,
                call_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                uuies_requested,
                call_linkage,
                usage_info_requested,
                segmented_response_supported,
                next_segment_requested,
                capacity_info_requested,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct InfoRequestAck {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl InfoRequestAck {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct InfoRequestNak {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "nakReason")]
        pub nak_reason: InfoRequestNakReason,
        #[rasn(identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl InfoRequestNak {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            nak_reason: InfoRequestNakReason,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                nak_reason,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum InfoRequestNakReason {
        notRegistered(()),
        securityDenial(()),
        undefinedReason(()),
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "SEQUENCE")]
    pub struct AnonymousAnonymousInfoRequestResponsePerCallInfoPdu {
        pub h323pdu: H323UUPDU,
        pub sent: bool,
    }
    impl AnonymousAnonymousInfoRequestResponsePerCallInfoPdu {
        pub fn new(h323pdu: H323UUPDU, sent: bool) -> Self {
            Self { h323pdu, sent }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AnonymousInfoRequestResponsePerCallInfoPdu(
        pub SequenceOf<AnonymousAnonymousInfoRequestResponsePerCallInfoPdu>,
    );
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "SEQUENCE")]
    #[non_exhaustive]
    pub struct AnonymousInfoRequestResponsePerCallInfo {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        pub originator: Option<bool>,
        pub audio: Option<SequenceOf<RTPSession>>,
        pub video: Option<SequenceOf<RTPSession>>,
        pub data: Option<SequenceOf<TransportChannelInfo>>,
        pub h245: TransportChannelInfo,
        #[rasn(identifier = "callSignaling")]
        pub call_signaling: TransportChannelInfo,
        #[rasn(identifier = "callType")]
        pub call_type: CallType,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "callModel")]
        pub call_model: CallModel,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "substituteConfIDs")]
        pub substitute_conf_ids: SequenceOf<ConferenceIdentifier>,
        #[rasn(extension_addition)]
        pub pdu: Option<AnonymousInfoRequestResponsePerCallInfoPdu>,
        #[rasn(extension_addition, identifier = "callLinkage")]
        pub call_linkage: Option<CallLinkage>,
        #[rasn(extension_addition, identifier = "usageInformation")]
        pub usage_information: Option<RasUsageInformation>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
    }
    impl AnonymousInfoRequestResponsePerCallInfo {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            call_reference_value: CallReferenceValue,
            conference_id: ConferenceIdentifier,
            originator: Option<bool>,
            audio: Option<SequenceOf<RTPSession>>,
            video: Option<SequenceOf<RTPSession>>,
            data: Option<SequenceOf<TransportChannelInfo>>,
            h245: TransportChannelInfo,
            call_signaling: TransportChannelInfo,
            call_type: CallType,
            band_width: BandWidth,
            call_model: CallModel,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            substitute_conf_ids: SequenceOf<ConferenceIdentifier>,
            pdu: Option<AnonymousInfoRequestResponsePerCallInfoPdu>,
            call_linkage: Option<CallLinkage>,
            usage_information: Option<RasUsageInformation>,
            circuit_info: Option<CircuitInfo>,
        ) -> Self {
            Self {
                non_standard_data,
                call_reference_value,
                conference_id,
                originator,
                audio,
                video,
                data,
                h245,
                call_signaling,
                call_type,
                band_width,
                call_model,
                call_identifier,
                tokens,
                crypto_tokens,
                substitute_conf_ids,
                pdu,
                call_linkage,
                usage_information,
                circuit_info,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct InfoRequestResponsePerCallInfo(
        pub SequenceOf<AnonymousInfoRequestResponsePerCallInfo>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct InfoRequestResponse {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "endpointType")]
        pub endpoint_type: EndpointType,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "endpointAlias")]
        pub endpoint_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "perCallInfo")]
        pub per_call_info: Option<InfoRequestResponsePerCallInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "needResponse")]
        pub need_response: bool,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "irrStatus")]
        pub irr_status: Option<InfoRequestResponseStatus>,
        #[rasn(extension_addition)]
        pub unsolicited: bool,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl InfoRequestResponse {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            request_seq_num: RequestSeqNum,
            endpoint_type: EndpointType,
            endpoint_identifier: EndpointIdentifier,
            ras_address: TransportAddress,
            call_signal_address: SequenceOf<TransportAddress>,
            endpoint_alias: Option<SequenceOf<AliasAddress>>,
            per_call_info: Option<InfoRequestResponsePerCallInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            need_response: bool,
            capacity: Option<CallCapacity>,
            irr_status: Option<InfoRequestResponseStatus>,
            unsolicited: bool,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                non_standard_data,
                request_seq_num,
                endpoint_type,
                endpoint_identifier,
                ras_address,
                call_signal_address,
                endpoint_alias,
                per_call_info,
                tokens,
                crypto_tokens,
                integrity_check_value,
                need_response,
                capacity,
                irr_status,
                unsolicited,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum InfoRequestResponseStatus {
        complete(()),
        incomplete(()),
        #[rasn(value("0..=65535"))]
        segment(u16),
        invalidCall(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Information-UUIE")]
    #[non_exhaustive]
    pub struct InformationUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "fastConnectRefused")]
        pub fast_connect_refused: Option<()>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
    }
    impl InformationUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
            fast_connect_refused: Option<()>,
            circuit_info: Option<CircuitInfo>,
        ) -> Self {
            Self {
                protocol_identifier,
                call_identifier,
                tokens,
                crypto_tokens,
                fast_start,
                fast_connect_refused,
                circuit_info,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum IntegrityMechanism {
        nonStandard(NonStandardParameter),
        digSig(()),
        iso9797(ObjectIdentifier),
        nonIsoIM(NonIsoIntegrityMechanism),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LocationConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: TransportAddress,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "destinationInfo")]
        pub destination_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "destinationType")]
        pub destination_type: Option<EndpointType>,
        #[rasn(extension_addition, identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "alternateTransportAddresses")]
        pub alternate_transport_addresses: Option<AlternateTransportAddresses>,
        #[rasn(extension_addition, identifier = "supportedProtocols")]
        pub supported_protocols: Option<SequenceOf<SupportedProtocols>>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: Option<bool>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
    }
    impl LocationConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            call_signal_address: TransportAddress,
            ras_address: TransportAddress,
            non_standard_data: Option<NonStandardParameter>,
            destination_info: Option<SequenceOf<AliasAddress>>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            destination_type: Option<EndpointType>,
            remote_extension_address: Option<SequenceOf<AliasAddress>>,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            alternate_transport_addresses: Option<AlternateTransportAddresses>,
            supported_protocols: Option<SequenceOf<SupportedProtocols>>,
            multiple_calls: Option<bool>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
            circuit_info: Option<CircuitInfo>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
        ) -> Self {
            Self {
                request_seq_num,
                call_signal_address,
                ras_address,
                non_standard_data,
                destination_info,
                dest_extra_call_info,
                destination_type,
                remote_extension_address,
                alternate_endpoints,
                tokens,
                crypto_tokens,
                integrity_check_value,
                alternate_transport_addresses,
                supported_protocols,
                multiple_calls,
                feature_set,
                generic_data,
                circuit_info,
                service_control,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LocationReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: LocationRejectReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
    }
    impl LocationReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: LocationRejectReason,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
                feature_set,
                generic_data,
                service_control,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum LocationRejectReason {
        notRegistered(()),
        invalidPermission(()),
        requestDenied(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        securityDenial(()),
        #[rasn(extension_addition)]
        aliasesInconsistent(()),
        #[rasn(extension_addition)]
        routeCalltoSCN(SequenceOf<PartyNumber>),
        #[rasn(extension_addition)]
        resourceUnavailable(()),
        #[rasn(extension_addition)]
        genericDataReason(()),
        #[rasn(extension_addition)]
        neededFeatureNotSupported(()),
        #[rasn(extension_addition)]
        hopCountExceeded(()),
        #[rasn(extension_addition)]
        incompleteAddress(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LocationRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: Option<EndpointIdentifier>,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: SequenceOf<AliasAddress>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "replyAddress")]
        pub reply_address: TransportAddress,
        #[rasn(extension_addition, identifier = "sourceInfo")]
        pub source_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "canMapAlias")]
        pub can_map_alias: bool,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "desiredProtocols")]
        pub desired_protocols: Option<SequenceOf<SupportedProtocols>>,
        #[rasn(extension_addition, identifier = "desiredTunnelledProtocol")]
        pub desired_tunnelled_protocol: Option<TunnelledProtocol>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
        #[rasn(extension_addition, value("1..=255"), identifier = "hopCount")]
        pub hop_count: Option<u8>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
    }
    impl LocationRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            endpoint_identifier: Option<EndpointIdentifier>,
            destination_info: SequenceOf<AliasAddress>,
            non_standard_data: Option<NonStandardParameter>,
            reply_address: TransportAddress,
            source_info: Option<SequenceOf<AliasAddress>>,
            can_map_alias: bool,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            desired_protocols: Option<SequenceOf<SupportedProtocols>>,
            desired_tunnelled_protocol: Option<TunnelledProtocol>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
            hop_count: Option<u8>,
            circuit_info: Option<CircuitInfo>,
        ) -> Self {
            Self {
                request_seq_num,
                endpoint_identifier,
                destination_info,
                non_standard_data,
                reply_address,
                source_info,
                can_map_alias,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                desired_protocols,
                desired_tunnelled_protocol,
                feature_set,
                generic_data,
                hop_count,
                circuit_info,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct McuInfo {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition)]
        pub protocol: Option<SequenceOf<SupportedProtocols>>,
    }
    impl McuInfo {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            protocol: Option<SequenceOf<SupportedProtocols>>,
        ) -> Self {
            Self {
                non_standard_data,
                protocol,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MobileUIM {
        #[rasn(identifier = "ansi-41-uim")]
        ansi_41_uim(ANSI41UIM),
        #[rasn(identifier = "gsm-uim")]
        gsm_uim(GSMUIM),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NonIsoIntegrityMechanism {
        #[rasn(identifier = "hMAC-MD5")]
        hMAC_MD5(()),
        #[rasn(identifier = "hMAC-iso10118-2-s")]
        hMAC_iso10118_2_s(EncryptIntAlg),
        #[rasn(identifier = "hMAC-iso10118-2-l")]
        hMAC_iso10118_2_l(EncryptIntAlg),
        #[rasn(identifier = "hMAC-iso10118-3")]
        hMAC_iso10118_3(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NonStandardIdentifier {
        object(ObjectIdentifier),
        h221NonStandard(H221NonStandard),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NonStandardMessage {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: NonStandardParameter,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl NonStandardMessage {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: NonStandardParameter,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct NonStandardParameter {
        #[rasn(identifier = "nonStandardIdentifier")]
        pub non_standard_identifier: NonStandardIdentifier,
        pub data: OctetString,
    }
    impl NonStandardParameter {
        pub fn new(non_standard_identifier: NonStandardIdentifier, data: OctetString) -> Self {
            Self {
                non_standard_identifier,
                data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NonStandardProtocol {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl NonStandardProtocol {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Notify-UUIE")]
    #[non_exhaustive]
    pub struct NotifyUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
    }
    impl NotifyUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        ) -> Self {
            Self {
                protocol_identifier,
                call_identifier,
                tokens,
                crypto_tokens,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(
        delegate,
        size("1..=128"),
        from(
            "\u{23}", "\u{2a}", "\u{2c}", "\u{30}", "\u{31}", "\u{32}", "\u{33}", "\u{34}",
            "\u{35}", "\u{36}", "\u{37}", "\u{38}", "\u{39}"
        )
    )]
    pub struct NumberDigits(pub Ia5String);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PartyNumber {
        e164Number(PublicPartyNumber),
        dataPartyNumber(NumberDigits),
        telexPartyNumber(NumberDigits),
        privateNumber(PrivatePartyNumber),
        nationalStandardPartyNumber(NumberDigits),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PresentationIndicator {
        presentationAllowed(()),
        presentationRestricted(()),
        addressNotAvailable(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct PrivatePartyNumber {
        #[rasn(identifier = "privateTypeOfNumber")]
        pub private_type_of_number: PrivateTypeOfNumber,
        #[rasn(identifier = "privateNumberDigits")]
        pub private_number_digits: NumberDigits,
    }
    impl PrivatePartyNumber {
        pub fn new(
            private_type_of_number: PrivateTypeOfNumber,
            private_number_digits: NumberDigits,
        ) -> Self {
            Self {
                private_type_of_number,
                private_number_digits,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PrivateTypeOfNumber {
        unknown(()),
        level2RegionalNumber(()),
        level1RegionalNumber(()),
        pISNSpecificNumber(()),
        localNumber(()),
        abbreviatedNumber(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Progress-UUIE")]
    #[non_exhaustive]
    pub struct ProgressUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: EndpointType,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: bool,
        #[rasn(extension_addition, identifier = "maintainConnection")]
        pub maintain_connection: bool,
        #[rasn(extension_addition, identifier = "fastConnectRefused")]
        pub fast_connect_refused: Option<()>,
    }
    impl ProgressUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            destination_info: EndpointType,
            h245_address: Option<TransportAddress>,
            call_identifier: CallIdentifier,
            h245_security_mode: Option<H245Security>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
            multiple_calls: bool,
            maintain_connection: bool,
            fast_connect_refused: Option<()>,
        ) -> Self {
            Self {
                protocol_identifier,
                destination_info,
                h245_address,
                call_identifier,
                h245_security_mode,
                tokens,
                crypto_tokens,
                fast_start,
                multiple_calls,
                maintain_connection,
                fast_connect_refused,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ProtocolIdentifier(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct PublicPartyNumber {
        #[rasn(identifier = "publicTypeOfNumber")]
        pub public_type_of_number: PublicTypeOfNumber,
        #[rasn(identifier = "publicNumberDigits")]
        pub public_number_digits: NumberDigits,
    }
    impl PublicPartyNumber {
        pub fn new(
            public_type_of_number: PublicTypeOfNumber,
            public_number_digits: NumberDigits,
        ) -> Self {
            Self {
                public_type_of_number,
                public_number_digits,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PublicTypeOfNumber {
        unknown(()),
        internationalNumber(()),
        nationalNumber(()),
        networkSpecificNumber(()),
        subscriberNumber(()),
        abbreviatedNumber(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Q954Details {
        #[rasn(identifier = "conferenceCalling")]
        pub conference_calling: bool,
        #[rasn(identifier = "threePartyService")]
        pub three_party_service: bool,
    }
    impl Q954Details {
        pub fn new(conference_calling: bool, three_party_service: bool) -> Self {
            Self {
                conference_calling,
                three_party_service,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct QseriesOptions {
        #[rasn(identifier = "q932Full")]
        pub q932_full: bool,
        #[rasn(identifier = "q951Full")]
        pub q951_full: bool,
        #[rasn(identifier = "q952Full")]
        pub q952_full: bool,
        #[rasn(identifier = "q953Full")]
        pub q953_full: bool,
        #[rasn(identifier = "q955Full")]
        pub q955_full: bool,
        #[rasn(identifier = "q956Full")]
        pub q956_full: bool,
        #[rasn(identifier = "q957Full")]
        pub q957_full: bool,
        #[rasn(identifier = "q954Info")]
        pub q954_info: Q954Details,
    }
    impl QseriesOptions {
        pub fn new(
            q932_full: bool,
            q951_full: bool,
            q952_full: bool,
            q953_full: bool,
            q955_full: bool,
            q956_full: bool,
            q957_full: bool,
            q954_info: Q954Details,
        ) -> Self {
            Self {
                q932_full,
                q951_full,
                q952_full,
                q953_full,
                q955_full,
                q956_full,
                q957_full,
                q954_info,
            }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER", value("1..=255"))]
    pub struct AnonymousRTPSessionAssociatedSessionIds(pub u8);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RTPSessionAssociatedSessionIds(
        pub SequenceOf<AnonymousRTPSessionAssociatedSessionIds>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RTPSession {
        #[rasn(identifier = "rtpAddress")]
        pub rtp_address: TransportChannelInfo,
        #[rasn(identifier = "rtcpAddress")]
        pub rtcp_address: TransportChannelInfo,
        pub cname: PrintableString,
        #[rasn(value("1..=4294967295"))]
        pub ssrc: u32,
        #[rasn(value("1..=255"), identifier = "sessionId")]
        pub session_id: u8,
        #[rasn(identifier = "associatedSessionIds")]
        pub associated_session_ids: RTPSessionAssociatedSessionIds,
        #[rasn(extension_addition)]
        pub multicast: Option<()>,
        #[rasn(extension_addition)]
        pub bandwidth: Option<BandWidth>,
    }
    impl RTPSession {
        pub fn new(
            rtp_address: TransportChannelInfo,
            rtcp_address: TransportChannelInfo,
            cname: PrintableString,
            ssrc: u32,
            session_id: u8,
            associated_session_ids: RTPSessionAssociatedSessionIds,
            multicast: Option<()>,
            bandwidth: Option<BandWidth>,
        ) -> Self {
            Self {
                rtp_address,
                rtcp_address,
                cname,
                ssrc,
                session_id,
                associated_session_ids,
                multicast,
                bandwidth,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RasMessage {
        gatekeeperRequest(GatekeeperRequest),
        gatekeeperConfirm(GatekeeperConfirm),
        gatekeeperReject(GatekeeperReject),
        registrationRequest(RegistrationRequest),
        registrationConfirm(RegistrationConfirm),
        registrationReject(RegistrationReject),
        unregistrationRequest(UnregistrationRequest),
        unregistrationConfirm(UnregistrationConfirm),
        unregistrationReject(UnregistrationReject),
        admissionRequest(AdmissionRequest),
        admissionConfirm(AdmissionConfirm),
        admissionReject(AdmissionReject),
        bandwidthRequest(BandwidthRequest),
        bandwidthConfirm(BandwidthConfirm),
        bandwidthReject(BandwidthReject),
        disengageRequest(DisengageRequest),
        disengageConfirm(DisengageConfirm),
        disengageReject(DisengageReject),
        locationRequest(LocationRequest),
        locationConfirm(LocationConfirm),
        locationReject(LocationReject),
        infoRequest(InfoRequest),
        infoRequestResponse(InfoRequestResponse),
        nonStandardMessage(NonStandardMessage),
        unknownMessageResponse(UnknownMessageResponse),
        #[rasn(extension_addition)]
        requestInProgress(RequestInProgress),
        #[rasn(extension_addition)]
        resourcesAvailableIndicate(ResourcesAvailableIndicate),
        #[rasn(extension_addition)]
        resourcesAvailableConfirm(ResourcesAvailableConfirm),
        #[rasn(extension_addition)]
        infoRequestAck(InfoRequestAck),
        #[rasn(extension_addition)]
        infoRequestNak(InfoRequestNak),
        #[rasn(extension_addition)]
        serviceControlIndication(ServiceControlIndication),
        #[rasn(extension_addition)]
        serviceControlResponse(ServiceControlResponse),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RasUsageInfoTypes {
        #[rasn(identifier = "nonStandardUsageTypes")]
        pub non_standard_usage_types: SequenceOf<NonStandardParameter>,
        #[rasn(identifier = "startTime")]
        pub start_time: Option<()>,
        #[rasn(identifier = "endTime")]
        pub end_time: Option<()>,
        #[rasn(identifier = "terminationCause")]
        pub termination_cause: Option<()>,
    }
    impl RasUsageInfoTypes {
        pub fn new(
            non_standard_usage_types: SequenceOf<NonStandardParameter>,
            start_time: Option<()>,
            end_time: Option<()>,
            termination_cause: Option<()>,
        ) -> Self {
            Self {
                non_standard_usage_types,
                start_time,
                end_time,
                termination_cause,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RasUsageInformation {
        #[rasn(identifier = "nonStandardUsageFields")]
        pub non_standard_usage_fields: SequenceOf<NonStandardParameter>,
        #[rasn(identifier = "alertingTime")]
        pub alerting_time: Option<TimeStamp>,
        #[rasn(identifier = "connectTime")]
        pub connect_time: Option<TimeStamp>,
        #[rasn(identifier = "endTime")]
        pub end_time: Option<TimeStamp>,
    }
    impl RasUsageInformation {
        pub fn new(
            non_standard_usage_fields: SequenceOf<NonStandardParameter>,
            alerting_time: Option<TimeStamp>,
            connect_time: Option<TimeStamp>,
            end_time: Option<TimeStamp>,
        ) -> Self {
            Self {
                non_standard_usage_fields,
                alerting_time,
                connect_time,
                end_time,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RasUsageSpecificationWhen {
        pub start: Option<()>,
        pub end: Option<()>,
        #[rasn(identifier = "inIrr")]
        pub in_irr: Option<()>,
    }
    impl RasUsageSpecificationWhen {
        pub fn new(start: Option<()>, end: Option<()>, in_irr: Option<()>) -> Self {
            Self { start, end, in_irr }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RasUsageSpecificationCallStartingPoint {
        pub alerting: Option<()>,
        pub connect: Option<()>,
    }
    impl RasUsageSpecificationCallStartingPoint {
        pub fn new(alerting: Option<()>, connect: Option<()>) -> Self {
            Self { alerting, connect }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RasUsageSpecification {
        pub when: RasUsageSpecificationWhen,
        #[rasn(identifier = "callStartingPoint")]
        pub call_starting_point: Option<RasUsageSpecificationCallStartingPoint>,
        pub required: RasUsageInfoTypes,
    }
    impl RasUsageSpecification {
        pub fn new(
            when: RasUsageSpecificationWhen,
            call_starting_point: Option<RasUsageSpecificationCallStartingPoint>,
            required: RasUsageInfoTypes,
        ) -> Self {
            Self {
                when,
                call_starting_point,
                required,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationConfirmPreGrantedARQ {
        #[rasn(identifier = "makeCall")]
        pub make_call: bool,
        #[rasn(identifier = "useGKCallSignalAddressToMakeCall")]
        pub use_gkcall_signal_address_to_make_call: bool,
        #[rasn(identifier = "answerCall")]
        pub answer_call: bool,
        #[rasn(identifier = "useGKCallSignalAddressToAnswer")]
        pub use_gkcall_signal_address_to_answer: bool,
        #[rasn(
            extension_addition,
            value("1..=65535"),
            identifier = "irrFrequencyInCall"
        )]
        pub irr_frequency_in_call: Option<u16>,
        #[rasn(extension_addition, identifier = "totalBandwidthRestriction")]
        pub total_bandwidth_restriction: Option<BandWidth>,
        #[rasn(extension_addition, identifier = "alternateTransportAddresses")]
        pub alternate_transport_addresses: Option<AlternateTransportAddresses>,
        #[rasn(extension_addition, identifier = "useSpecifiedTransport")]
        pub use_specified_transport: Option<UseSpecifiedTransport>,
    }
    impl RegistrationConfirmPreGrantedARQ {
        pub fn new(
            make_call: bool,
            use_gkcall_signal_address_to_make_call: bool,
            answer_call: bool,
            use_gkcall_signal_address_to_answer: bool,
            irr_frequency_in_call: Option<u16>,
            total_bandwidth_restriction: Option<BandWidth>,
            alternate_transport_addresses: Option<AlternateTransportAddresses>,
            use_specified_transport: Option<UseSpecifiedTransport>,
        ) -> Self {
            Self {
                make_call,
                use_gkcall_signal_address_to_make_call,
                answer_call,
                use_gkcall_signal_address_to_answer,
                irr_frequency_in_call,
                total_bandwidth_restriction,
                alternate_transport_addresses,
                use_specified_transport,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "terminalAlias")]
        pub terminal_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(extension_addition, identifier = "alternateGatekeeper")]
        pub alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
        #[rasn(extension_addition, identifier = "timeToLive")]
        pub time_to_live: Option<TimeToLive>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "willRespondToIRR")]
        pub will_respond_to_irr: bool,
        #[rasn(extension_addition, identifier = "preGrantedARQ")]
        pub pre_granted_arq: Option<RegistrationConfirmPreGrantedARQ>,
        #[rasn(extension_addition, identifier = "maintainConnection")]
        pub maintain_connection: bool,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition, identifier = "supportsAdditiveRegistration")]
        pub supports_additive_registration: Option<()>,
        #[rasn(extension_addition, identifier = "terminalAliasPattern")]
        pub terminal_alias_pattern: Option<SequenceOf<AddressPattern>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: Option<SequenceOf<SupportedPrefix>>,
        #[rasn(extension_addition, identifier = "usageSpec")]
        pub usage_spec: Option<SequenceOf<RasUsageSpecification>>,
        #[rasn(extension_addition, identifier = "featureServerAlias")]
        pub feature_server_alias: Option<AliasAddress>,
        #[rasn(extension_addition, identifier = "capacityReportingSpec")]
        pub capacity_reporting_spec: Option<CapacityReportingSpecification>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl RegistrationConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            call_signal_address: SequenceOf<TransportAddress>,
            terminal_alias: Option<SequenceOf<AliasAddress>>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            endpoint_identifier: EndpointIdentifier,
            alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
            time_to_live: Option<TimeToLive>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            will_respond_to_irr: bool,
            pre_granted_arq: Option<RegistrationConfirmPreGrantedARQ>,
            maintain_connection: bool,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            supports_additive_registration: Option<()>,
            terminal_alias_pattern: Option<SequenceOf<AddressPattern>>,
            supported_prefixes: Option<SequenceOf<SupportedPrefix>>,
            usage_spec: Option<SequenceOf<RasUsageSpecification>>,
            feature_server_alias: Option<AliasAddress>,
            capacity_reporting_spec: Option<CapacityReportingSpecification>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                call_signal_address,
                terminal_alias,
                gatekeeper_identifier,
                endpoint_identifier,
                alternate_gatekeeper,
                time_to_live,
                tokens,
                crypto_tokens,
                integrity_check_value,
                will_respond_to_irr,
                pre_granted_arq,
                maintain_connection,
                service_control,
                supports_additive_registration,
                terminal_alias_pattern,
                supported_prefixes,
                usage_spec,
                feature_server_alias,
                capacity_reporting_spec,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: RegistrationRejectReason,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl RegistrationReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            reject_reason: RegistrationRejectReason,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                reject_reason,
                gatekeeper_identifier,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
                feature_set,
                generic_data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationRejectReasonInvalidTerminalAliases {
        #[rasn(identifier = "terminalAlias")]
        pub terminal_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "terminalAliasPattern")]
        pub terminal_alias_pattern: Option<SequenceOf<AddressPattern>>,
        #[rasn(identifier = "supportedPrefixes")]
        pub supported_prefixes: Option<SequenceOf<SupportedPrefix>>,
    }
    impl RegistrationRejectReasonInvalidTerminalAliases {
        pub fn new(
            terminal_alias: Option<SequenceOf<AliasAddress>>,
            terminal_alias_pattern: Option<SequenceOf<AddressPattern>>,
            supported_prefixes: Option<SequenceOf<SupportedPrefix>>,
        ) -> Self {
            Self {
                terminal_alias,
                terminal_alias_pattern,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RegistrationRejectReason {
        discoveryRequired(()),
        invalidRevision(()),
        invalidCallSignalAddress(()),
        invalidRASAddress(()),
        duplicateAlias(SequenceOf<AliasAddress>),
        invalidTerminalType(()),
        undefinedReason(()),
        transportNotSupported(()),
        #[rasn(extension_addition)]
        transportQOSNotSupported(()),
        #[rasn(extension_addition)]
        resourceUnavailable(()),
        #[rasn(extension_addition)]
        invalidAlias(()),
        #[rasn(extension_addition)]
        securityDenial(()),
        #[rasn(extension_addition)]
        fullRegistrationRequired(()),
        #[rasn(extension_addition)]
        additiveRegistrationNotSupported(()),
        #[rasn(extension_addition)]
        invalidTerminalAliases(RegistrationRejectReasonInvalidTerminalAliases),
        #[rasn(extension_addition)]
        genericDataReason(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "discoveryComplete")]
        pub discovery_complete: bool,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "terminalType")]
        pub terminal_type: EndpointType,
        #[rasn(identifier = "terminalAlias")]
        pub terminal_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "endpointVendor")]
        pub endpoint_vendor: VendorIdentifier,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition, identifier = "timeToLive")]
        pub time_to_live: Option<TimeToLive>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "keepAlive")]
        pub keep_alive: bool,
        #[rasn(extension_addition, identifier = "endpointIdentifier")]
        pub endpoint_identifier: Option<EndpointIdentifier>,
        #[rasn(extension_addition, identifier = "willSupplyUUIEs")]
        pub will_supply_uuies: bool,
        #[rasn(extension_addition, identifier = "maintainConnection")]
        pub maintain_connection: bool,
        #[rasn(extension_addition, identifier = "alternateTransportAddresses")]
        pub alternate_transport_addresses: Option<AlternateTransportAddresses>,
        #[rasn(extension_addition, identifier = "additiveRegistration")]
        pub additive_registration: Option<()>,
        #[rasn(extension_addition, identifier = "terminalAliasPattern")]
        pub terminal_alias_pattern: Option<SequenceOf<AddressPattern>>,
        #[rasn(extension_addition, identifier = "supportsAltGK")]
        pub supports_alt_gk: Option<()>,
        #[rasn(extension_addition, identifier = "usageReportingCapability")]
        pub usage_reporting_capability: Option<RasUsageInfoTypes>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: Option<bool>,
        #[rasn(extension_addition, identifier = "supportedH248Packages")]
        pub supported_h248_packages: Option<SequenceOf<H248PackagesDescriptor>>,
        #[rasn(extension_addition, identifier = "callCreditCapability")]
        pub call_credit_capability: Option<CallCreditCapability>,
        #[rasn(extension_addition, identifier = "capacityReportingCapability")]
        pub capacity_reporting_capability: Option<CapacityReportingCapability>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl RegistrationRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            discovery_complete: bool,
            call_signal_address: SequenceOf<TransportAddress>,
            ras_address: SequenceOf<TransportAddress>,
            terminal_type: EndpointType,
            terminal_alias: Option<SequenceOf<AliasAddress>>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            endpoint_vendor: VendorIdentifier,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            time_to_live: Option<TimeToLive>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            keep_alive: bool,
            endpoint_identifier: Option<EndpointIdentifier>,
            will_supply_uuies: bool,
            maintain_connection: bool,
            alternate_transport_addresses: Option<AlternateTransportAddresses>,
            additive_registration: Option<()>,
            terminal_alias_pattern: Option<SequenceOf<AddressPattern>>,
            supports_alt_gk: Option<()>,
            usage_reporting_capability: Option<RasUsageInfoTypes>,
            multiple_calls: Option<bool>,
            supported_h248_packages: Option<SequenceOf<H248PackagesDescriptor>>,
            call_credit_capability: Option<CallCreditCapability>,
            capacity_reporting_capability: Option<CapacityReportingCapability>,
            capacity: Option<CallCapacity>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                discovery_complete,
                call_signal_address,
                ras_address,
                terminal_type,
                terminal_alias,
                gatekeeper_identifier,
                endpoint_vendor,
                alternate_endpoints,
                time_to_live,
                tokens,
                crypto_tokens,
                integrity_check_value,
                keep_alive,
                endpoint_identifier,
                will_supply_uuies,
                maintain_connection,
                alternate_transport_addresses,
                additive_registration,
                terminal_alias_pattern,
                supports_alt_gk,
                usage_reporting_capability,
                multiple_calls,
                supported_h248_packages,
                call_credit_capability,
                capacity_reporting_capability,
                capacity,
                feature_set,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "ReleaseComplete-UUIE")]
    #[non_exhaustive]
    pub struct ReleaseCompleteUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        pub reason: Option<ReleaseCompleteReason>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "busyAddress")]
        pub busy_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "presentationIndicator")]
        pub presentation_indicator: Option<PresentationIndicator>,
        #[rasn(extension_addition, identifier = "screeningIndicator")]
        pub screening_indicator: Option<ScreeningIndicator>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition, identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
    }
    impl ReleaseCompleteUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            reason: Option<ReleaseCompleteReason>,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            busy_address: Option<SequenceOf<AliasAddress>>,
            presentation_indicator: Option<PresentationIndicator>,
            screening_indicator: Option<ScreeningIndicator>,
            capacity: Option<CallCapacity>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            feature_set: Option<FeatureSet>,
        ) -> Self {
            Self {
                protocol_identifier,
                reason,
                call_identifier,
                tokens,
                crypto_tokens,
                busy_address,
                presentation_indicator,
                screening_indicator,
                capacity,
                service_control,
                feature_set,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ReleaseCompleteReason {
        noBandwidth(()),
        gatekeeperResources(()),
        unreachableDestination(()),
        destinationRejection(()),
        invalidRevision(()),
        noPermission(()),
        unreachableGatekeeper(()),
        gatewayResources(()),
        badFormatAddress(()),
        adaptiveBusy(()),
        inConf(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        facilityCallDeflection(()),
        #[rasn(extension_addition)]
        securityDenied(()),
        #[rasn(extension_addition)]
        calledPartyNotRegistered(()),
        #[rasn(extension_addition)]
        callerNotRegistered(()),
        #[rasn(extension_addition)]
        newConnectionNeeded(()),
        #[rasn(extension_addition)]
        nonStandardReason(NonStandardParameter),
        #[rasn(extension_addition)]
        replaceWithConferenceInvite(ConferenceIdentifier),
        #[rasn(extension_addition)]
        genericDataReason(()),
        #[rasn(extension_addition)]
        neededFeatureNotSupported(()),
        #[rasn(extension_addition)]
        tunnelledSignallingRejected(()),
        #[rasn(extension_addition)]
        invalidCID(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestInProgress {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(value("1..=65535"))]
        pub delay: u16,
    }
    impl RequestInProgress {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            delay: u16,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
                delay,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=65535"))]
    pub struct RequestSeqNum(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ResourcesAvailableConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl ResourcesAvailableConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ResourcesAvailableIndicate {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        pub protocols: SequenceOf<SupportedProtocols>,
        #[rasn(identifier = "almostOutOfResources")]
        pub almost_out_of_resources: bool,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl ResourcesAvailableIndicate {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            endpoint_identifier: EndpointIdentifier,
            protocols: SequenceOf<SupportedProtocols>,
            almost_out_of_resources: bool,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            capacity: Option<CallCapacity>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                endpoint_identifier,
                protocols,
                almost_out_of_resources,
                tokens,
                crypto_tokens,
                integrity_check_value,
                capacity,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ScnConnectionAggregation {
        auto(()),
        none(()),
        h221(()),
        #[rasn(identifier = "bonded-mode1")]
        bonded_mode1(()),
        #[rasn(identifier = "bonded-mode2")]
        bonded_mode2(()),
        #[rasn(identifier = "bonded-mode3")]
        bonded_mode3(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ScnConnectionType {
        unknown(()),
        bChannel(()),
        hybrid2x64(()),
        hybrid384(()),
        hybrid1536(()),
        hybrid1920(()),
        multirate(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    #[non_exhaustive]
    pub enum ScreeningIndicator {
        userProvidedNotScreened = 0,
        userProvidedVerifiedAndPassed = 1,
        userProvidedVerifiedAndFailed = 2,
        networkProvided = 3,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SecurityCapabilities {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<NonStandardParameter>,
        pub encryption: SecurityServiceMode,
        pub authenticaton: SecurityServiceMode,
        pub integrity: SecurityServiceMode,
    }
    impl SecurityCapabilities {
        pub fn new(
            non_standard: Option<NonStandardParameter>,
            encryption: SecurityServiceMode,
            authenticaton: SecurityServiceMode,
            integrity: SecurityServiceMode,
        ) -> Self {
            Self {
                non_standard,
                encryption,
                authenticaton,
                integrity,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum SecurityServiceMode {
        nonStandard(NonStandardParameter),
        none(()),
        default(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ServiceControlDescriptor {
        #[rasn(size("0..=512"))]
        url(Ia5String),
        signal(H248SignalsDescriptor),
        nonStandard(NonStandardParameter),
        callCreditServiceControl(CallCreditServiceControl),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ServiceControlIndicationCallSpecific {
        #[rasn(identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "answeredCall")]
        pub answered_call: bool,
    }
    impl ServiceControlIndicationCallSpecific {
        pub fn new(
            call_identifier: CallIdentifier,
            conference_id: ConferenceIdentifier,
            answered_call: bool,
        ) -> Self {
            Self {
                call_identifier,
                conference_id,
                answered_call,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ServiceControlIndication {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "serviceControl")]
        pub service_control: SequenceOf<ServiceControlSession>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: Option<EndpointIdentifier>,
        #[rasn(identifier = "callSpecific")]
        pub call_specific: Option<ServiceControlIndicationCallSpecific>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl ServiceControlIndication {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            service_control: SequenceOf<ServiceControlSession>,
            endpoint_identifier: Option<EndpointIdentifier>,
            call_specific: Option<ServiceControlIndicationCallSpecific>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                service_control,
                endpoint_identifier,
                call_specific,
                tokens,
                crypto_tokens,
                integrity_check_value,
                feature_set,
                generic_data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ServiceControlResponseResult {
        started(()),
        failed(()),
        stopped(()),
        notAvailable(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ServiceControlResponse {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        pub result: Option<ServiceControlResponseResult>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(identifier = "featureSet")]
        pub feature_set: Option<FeatureSet>,
        #[rasn(identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl ServiceControlResponse {
        pub fn new(
            request_seq_num: RequestSeqNum,
            result: Option<ServiceControlResponseResult>,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            feature_set: Option<FeatureSet>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                result,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
                feature_set,
                generic_data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ServiceControlSessionReason {
        open(()),
        refresh(()),
        close(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ServiceControlSession {
        #[rasn(value("0..=255"), identifier = "sessionId")]
        pub session_id: u8,
        pub contents: Option<ServiceControlDescriptor>,
        pub reason: ServiceControlSessionReason,
    }
    impl ServiceControlSession {
        pub fn new(
            session_id: u8,
            contents: Option<ServiceControlDescriptor>,
            reason: ServiceControlSessionReason,
        ) -> Self {
            Self {
                session_id,
                contents,
                reason,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum SetupUUIEConferenceGoal {
        create(()),
        join(()),
        invite(()),
        #[rasn(extension_addition, identifier = "capability-negotiation")]
        capability_negotiation(()),
        #[rasn(extension_addition)]
        callIndependentSupplementaryService(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SetupUUIEConnectionParameters {
        #[rasn(identifier = "connectionType")]
        pub connection_type: ScnConnectionType,
        #[rasn(value("0..=65535"), identifier = "numberOfScnConnections")]
        pub number_of_scn_connections: u16,
        #[rasn(identifier = "connectionAggregation")]
        pub connection_aggregation: ScnConnectionAggregation,
    }
    impl SetupUUIEConnectionParameters {
        pub fn new(
            connection_type: ScnConnectionType,
            number_of_scn_connections: u16,
            connection_aggregation: ScnConnectionAggregation,
        ) -> Self {
            Self {
                connection_type,
                number_of_scn_connections,
                connection_aggregation,
            }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IA5String", size("1..=32"))]
    pub struct AnonymousSetupUUIELanguage(pub Ia5String);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SetupUUIELanguage(pub SequenceOf<AnonymousSetupUUIELanguage>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Setup-UUIE")]
    #[non_exhaustive]
    pub struct SetupUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(identifier = "sourceAddress")]
        pub source_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "sourceInfo")]
        pub source_info: EndpointType,
        #[rasn(identifier = "destinationAddress")]
        pub destination_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "destCallSignalAddress")]
        pub dest_call_signal_address: Option<TransportAddress>,
        #[rasn(identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "destExtraCRV")]
        pub dest_extra_crv: Option<SequenceOf<CallReferenceValue>>,
        #[rasn(identifier = "activeMC")]
        pub active_mc: bool,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "conferenceGoal")]
        pub conference_goal: SetupUUIEConferenceGoal,
        #[rasn(identifier = "callServices")]
        pub call_services: Option<QseriesOptions>,
        #[rasn(identifier = "callType")]
        pub call_type: CallType,
        #[rasn(extension_addition, identifier = "sourceCallSignalAddress")]
        pub source_call_signal_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<AliasAddress>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "h245SecurityCapability")]
        pub h245_security_capability: Option<SequenceOf<H245Security>>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "mediaWaitForConnect")]
        pub media_wait_for_connect: bool,
        #[rasn(extension_addition, identifier = "canOverlapSend")]
        pub can_overlap_send: bool,
        #[rasn(extension_addition, identifier = "endpointIdentifier")]
        pub endpoint_identifier: Option<EndpointIdentifier>,
        #[rasn(extension_addition, identifier = "multipleCalls")]
        pub multiple_calls: bool,
        #[rasn(extension_addition, identifier = "maintainConnection")]
        pub maintain_connection: bool,
        #[rasn(extension_addition, identifier = "connectionParameters")]
        pub connection_parameters: Option<SetupUUIEConnectionParameters>,
        #[rasn(extension_addition)]
        pub language: Option<SetupUUIELanguage>,
        #[rasn(extension_addition, identifier = "presentationIndicator")]
        pub presentation_indicator: Option<PresentationIndicator>,
        #[rasn(extension_addition, identifier = "screeningIndicator")]
        pub screening_indicator: Option<ScreeningIndicator>,
        #[rasn(extension_addition, identifier = "serviceControl")]
        pub service_control: Option<SequenceOf<ServiceControlSession>>,
        #[rasn(extension_addition, identifier = "symmetricOperationRequired")]
        pub symmetric_operation_required: Option<()>,
        #[rasn(extension_addition)]
        pub capacity: Option<CallCapacity>,
        #[rasn(extension_addition, identifier = "circuitInfo")]
        pub circuit_info: Option<CircuitInfo>,
        #[rasn(extension_addition, identifier = "desiredProtocols")]
        pub desired_protocols: Option<SequenceOf<SupportedProtocols>>,
        #[rasn(extension_addition, identifier = "neededFeatures")]
        pub needed_features: Option<SequenceOf<FeatureDescriptor>>,
        #[rasn(extension_addition, identifier = "desiredFeatures")]
        pub desired_features: Option<SequenceOf<FeatureDescriptor>>,
        #[rasn(extension_addition, identifier = "supportedFeatures")]
        pub supported_features: Option<SequenceOf<FeatureDescriptor>>,
        #[rasn(extension_addition, identifier = "parallelH245Control")]
        pub parallel_h245_control: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "additionalSourceAddresses")]
        pub additional_source_addresses: Option<SequenceOf<ExtendedAliasAddress>>,
    }
    impl SetupUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            h245_address: Option<TransportAddress>,
            source_address: Option<SequenceOf<AliasAddress>>,
            source_info: EndpointType,
            destination_address: Option<SequenceOf<AliasAddress>>,
            dest_call_signal_address: Option<TransportAddress>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            dest_extra_crv: Option<SequenceOf<CallReferenceValue>>,
            active_mc: bool,
            conference_id: ConferenceIdentifier,
            conference_goal: SetupUUIEConferenceGoal,
            call_services: Option<QseriesOptions>,
            call_type: CallType,
            source_call_signal_address: Option<TransportAddress>,
            remote_extension_address: Option<AliasAddress>,
            call_identifier: CallIdentifier,
            h245_security_capability: Option<SequenceOf<H245Security>>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
            media_wait_for_connect: bool,
            can_overlap_send: bool,
            endpoint_identifier: Option<EndpointIdentifier>,
            multiple_calls: bool,
            maintain_connection: bool,
            connection_parameters: Option<SetupUUIEConnectionParameters>,
            language: Option<SetupUUIELanguage>,
            presentation_indicator: Option<PresentationIndicator>,
            screening_indicator: Option<ScreeningIndicator>,
            service_control: Option<SequenceOf<ServiceControlSession>>,
            symmetric_operation_required: Option<()>,
            capacity: Option<CallCapacity>,
            circuit_info: Option<CircuitInfo>,
            desired_protocols: Option<SequenceOf<SupportedProtocols>>,
            needed_features: Option<SequenceOf<FeatureDescriptor>>,
            desired_features: Option<SequenceOf<FeatureDescriptor>>,
            supported_features: Option<SequenceOf<FeatureDescriptor>>,
            parallel_h245_control: Option<SequenceOf<OctetString>>,
            additional_source_addresses: Option<SequenceOf<ExtendedAliasAddress>>,
        ) -> Self {
            Self {
                protocol_identifier,
                h245_address,
                source_address,
                source_info,
                destination_address,
                dest_call_signal_address,
                dest_extra_call_info,
                dest_extra_crv,
                active_mc,
                conference_id,
                conference_goal,
                call_services,
                call_type,
                source_call_signal_address,
                remote_extension_address,
                call_identifier,
                h245_security_capability,
                tokens,
                crypto_tokens,
                fast_start,
                media_wait_for_connect,
                can_overlap_send,
                endpoint_identifier,
                multiple_calls,
                maintain_connection,
                connection_parameters,
                language,
                presentation_indicator,
                screening_indicator,
                service_control,
                symmetric_operation_required,
                capacity,
                circuit_info,
                desired_protocols,
                needed_features,
                desired_features,
                supported_features,
                parallel_h245_control,
                additional_source_addresses,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "SetupAcknowledge-UUIE")]
    #[non_exhaustive]
    pub struct SetupAcknowledgeUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
    }
    impl SetupAcknowledgeUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        ) -> Self {
            Self {
                protocol_identifier,
                call_identifier,
                tokens,
                crypto_tokens,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Status-UUIE")]
    #[non_exhaustive]
    pub struct StatusUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
    }
    impl StatusUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        ) -> Self {
            Self {
                protocol_identifier,
                call_identifier,
                tokens,
                crypto_tokens,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "StatusInquiry-UUIE")]
    #[non_exhaustive]
    pub struct StatusInquiryUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
    }
    impl StatusInquiryUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        ) -> Self {
            Self {
                protocol_identifier,
                call_identifier,
                tokens,
                crypto_tokens,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct StimulusControl {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<NonStandardParameter>,
        #[rasn(identifier = "isText")]
        pub is_text: Option<()>,
        #[rasn(identifier = "h248Message")]
        pub h248_message: Option<OctetString>,
    }
    impl StimulusControl {
        pub fn new(
            non_standard: Option<NonStandardParameter>,
            is_text: Option<()>,
            h248_message: Option<OctetString>,
        ) -> Self {
            Self {
                non_standard,
                is_text,
                h248_message,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SupportedPrefix {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub prefix: AliasAddress,
    }
    impl SupportedPrefix {
        pub fn new(non_standard_data: Option<NonStandardParameter>, prefix: AliasAddress) -> Self {
            Self {
                non_standard_data,
                prefix,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum SupportedProtocols {
        nonStandardData(NonStandardParameter),
        h310(H310Caps),
        h320(H320Caps),
        h321(H321Caps),
        h322(H322Caps),
        h323(H323Caps),
        h324(H324Caps),
        voice(VoiceCaps),
        #[rasn(identifier = "t120-only")]
        t120_only(T120OnlyCaps),
        #[rasn(extension_addition)]
        nonStandardProtocol(NonStandardProtocol),
        #[rasn(extension_addition)]
        t38FaxAnnexbOnly(T38FaxAnnexbOnlyCaps),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct T120OnlyCaps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl T120OnlyCaps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct T38FaxAnnexbOnlyCaps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
        #[rasn(identifier = "t38FaxProtocol")]
        pub t38_fax_protocol: DataProtocolCapability,
        #[rasn(identifier = "t38FaxProfile")]
        pub t38_fax_profile: T38FaxProfile,
    }
    impl T38FaxAnnexbOnlyCaps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
            t38_fax_protocol: DataProtocolCapability,
            t38_fax_profile: T38FaxProfile,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
                t38_fax_protocol,
                t38_fax_profile,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(
        delegate,
        identifier = "TBCD-STRING",
        from(
            "\u{23}", "\u{2a}", "\u{30}", "\u{31}", "\u{32}", "\u{33}", "\u{34}", "\u{35}",
            "\u{36}", "\u{37}", "\u{38}", "\u{39}", "\u{61}", "\u{62}", "\u{63}"
        )
    )]
    pub struct TBCDSTRING(pub Ia5String);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalInfo {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl TerminalInfo {
        pub fn new(non_standard_data: Option<NonStandardParameter>) -> Self {
            Self { non_standard_data }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=4294967295"))]
    pub struct TimeToLive(pub u32);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct TransportAddressIpAddress {
        #[rasn(size("4"))]
        pub ip: OctetString,
        #[rasn(value("0..=65535"))]
        pub port: u16,
    }
    impl TransportAddressIpAddress {
        pub fn new(ip: OctetString, port: u16) -> Self {
            Self { ip, port }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "OCTET_STRING")]
    pub struct AnonymousTransportAddressIpSourceRouteRoute(pub FixedOctetString<4usize>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TransportAddressIpSourceRouteRoute(
        pub SequenceOf<AnonymousTransportAddressIpSourceRouteRoute>,
    );
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TransportAddressIpSourceRouteRouting {
        strict(()),
        loose(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TransportAddressIpSourceRoute {
        #[rasn(size("4"))]
        pub ip: OctetString,
        #[rasn(value("0..=65535"))]
        pub port: u16,
        pub route: TransportAddressIpSourceRouteRoute,
        pub routing: TransportAddressIpSourceRouteRouting,
    }
    impl TransportAddressIpSourceRoute {
        pub fn new(
            ip: OctetString,
            port: u16,
            route: TransportAddressIpSourceRouteRoute,
            routing: TransportAddressIpSourceRouteRouting,
        ) -> Self {
            Self {
                ip,
                port,
                route,
                routing,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct TransportAddressIpxAddress {
        #[rasn(size("6"))]
        pub node: OctetString,
        #[rasn(size("4"))]
        pub netnum: OctetString,
        #[rasn(size("2"))]
        pub port: OctetString,
    }
    impl TransportAddressIpxAddress {
        pub fn new(node: OctetString, netnum: OctetString, port: OctetString) -> Self {
            Self { node, netnum, port }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TransportAddressIp6Address {
        #[rasn(size("16"))]
        pub ip: OctetString,
        #[rasn(value("0..=65535"))]
        pub port: u16,
    }
    impl TransportAddressIp6Address {
        pub fn new(ip: OctetString, port: u16) -> Self {
            Self { ip, port }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TransportAddress {
        ipAddress(TransportAddressIpAddress),
        ipSourceRoute(TransportAddressIpSourceRoute),
        ipxAddress(TransportAddressIpxAddress),
        ip6Address(TransportAddressIp6Address),
        #[rasn(size("16"))]
        netBios(OctetString),
        #[rasn(size("1..=20"))]
        nsap(OctetString),
        nonStandardAddress(NonStandardParameter),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TransportChannelInfo {
        #[rasn(identifier = "sendAddress")]
        pub send_address: Option<TransportAddress>,
        #[rasn(identifier = "recvAddress")]
        pub recv_address: Option<TransportAddress>,
    }
    impl TransportChannelInfo {
        pub fn new(
            send_address: Option<TransportAddress>,
            recv_address: Option<TransportAddress>,
        ) -> Self {
            Self {
                send_address,
                recv_address,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TransportQOS {
        endpointControlled(()),
        gatekeeperControlled(()),
        noControl(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TunnelledProtocolId {
        tunnelledProtocolObjectID(ObjectIdentifier),
        tunnelledProtocolAlternateID(TunnelledProtocolAlternateIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TunnelledProtocol {
        pub id: TunnelledProtocolId,
        #[rasn(size("1..=64"), identifier = "subIdentifier")]
        pub sub_identifier: Option<Ia5String>,
    }
    impl TunnelledProtocol {
        pub fn new(id: TunnelledProtocolId, sub_identifier: Option<Ia5String>) -> Self {
            Self { id, sub_identifier }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TunnelledProtocolAlternateIdentifier {
        #[rasn(size("1..=64"), identifier = "protocolType")]
        pub protocol_type: Ia5String,
        #[rasn(size("1..=64"), identifier = "protocolVariant")]
        pub protocol_variant: Option<Ia5String>,
    }
    impl TunnelledProtocolAlternateIdentifier {
        pub fn new(protocol_type: Ia5String, protocol_variant: Option<Ia5String>) -> Self {
            Self {
                protocol_type,
                protocol_variant,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UUIEsRequested {
        pub setup: bool,
        #[rasn(identifier = "callProceeding")]
        pub call_proceeding: bool,
        pub connect: bool,
        pub alerting: bool,
        pub information: bool,
        #[rasn(identifier = "releaseComplete")]
        pub release_complete: bool,
        pub facility: bool,
        pub progress: bool,
        pub empty: bool,
        #[rasn(extension_addition)]
        pub status: bool,
        #[rasn(extension_addition, identifier = "statusInquiry")]
        pub status_inquiry: bool,
        #[rasn(extension_addition, identifier = "setupAcknowledge")]
        pub setup_acknowledge: bool,
        #[rasn(extension_addition)]
        pub notify: bool,
    }
    impl UUIEsRequested {
        pub fn new(
            setup: bool,
            call_proceeding: bool,
            connect: bool,
            alerting: bool,
            information: bool,
            release_complete: bool,
            facility: bool,
            progress: bool,
            empty: bool,
            status: bool,
            status_inquiry: bool,
            setup_acknowledge: bool,
            notify: bool,
        ) -> Self {
            Self {
                setup,
                call_proceeding,
                connect,
                alerting,
                information,
                release_complete,
                facility,
                progress,
                empty,
                status,
                status_inquiry,
                setup_acknowledge,
                notify,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnknownMessageResponse {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "messageNotUnderstood")]
        pub message_not_understood: OctetString,
    }
    impl UnknownMessageResponse {
        pub fn new(
            request_seq_num: RequestSeqNum,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            message_not_understood: OctetString,
        ) -> Self {
            Self {
                request_seq_num,
                tokens,
                crypto_tokens,
                integrity_check_value,
                message_not_understood,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UnregRejectReason {
        notCurrentlyRegistered(()),
        callInProgress(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        permissionDenied(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UnregRequestReason {
        reregistrationRequired(()),
        ttlExpired(()),
        securityDenial(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        maintenance(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnregistrationConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl UnregistrationConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnregistrationReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: UnregRejectReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl UnregistrationReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: UnregRejectReason,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnregistrationRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "endpointAlias")]
        pub endpoint_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: Option<EndpointIdentifier>,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition)]
        pub reason: Option<UnregRequestReason>,
        #[rasn(extension_addition, identifier = "endpointAliasPattern")]
        pub endpoint_alias_pattern: Option<SequenceOf<AddressPattern>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: Option<SequenceOf<SupportedPrefix>>,
        #[rasn(extension_addition, identifier = "alternateGatekeeper")]
        pub alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
        #[rasn(extension_addition, identifier = "genericData")]
        pub generic_data: Option<SequenceOf<GenericData>>,
    }
    impl UnregistrationRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            call_signal_address: SequenceOf<TransportAddress>,
            endpoint_alias: Option<SequenceOf<AliasAddress>>,
            non_standard_data: Option<NonStandardParameter>,
            endpoint_identifier: Option<EndpointIdentifier>,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            reason: Option<UnregRequestReason>,
            endpoint_alias_pattern: Option<SequenceOf<AddressPattern>>,
            supported_prefixes: Option<SequenceOf<SupportedPrefix>>,
            alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
            generic_data: Option<SequenceOf<GenericData>>,
        ) -> Self {
            Self {
                request_seq_num,
                call_signal_address,
                endpoint_alias,
                non_standard_data,
                endpoint_identifier,
                alternate_endpoints,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                reason,
                endpoint_alias_pattern,
                supported_prefixes,
                alternate_gatekeeper,
                generic_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UseSpecifiedTransport {
        tcp(()),
        annexE(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VendorIdentifier {
        pub vendor: H221NonStandard,
        #[rasn(size("1..=256"), identifier = "productId")]
        pub product_id: Option<OctetString>,
        #[rasn(size("1..=256"), identifier = "versionId")]
        pub version_id: Option<OctetString>,
    }
    impl VendorIdentifier {
        pub fn new(
            vendor: H221NonStandard,
            product_id: Option<OctetString>,
            version_id: Option<OctetString>,
        ) -> Self {
            Self {
                vendor,
                product_id,
                version_id,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VoiceCaps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl VoiceCaps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
}
