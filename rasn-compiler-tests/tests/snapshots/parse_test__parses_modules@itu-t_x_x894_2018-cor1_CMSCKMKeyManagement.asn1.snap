---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x894_2018-cor1_CMSCKMKeyManagement.asn1
---
Warnings:
LinkerError in ASN grammar: No syntax definition for information object class found!
LinkerError in ASN grammar: Failed to resolve supertype AlgorithmIdentifier of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype AlgorithmIdentifier of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype AlgorithmIdentifier of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod cmsckmkey_management {
    extern crate alloc;
    use super::algorithm_information_2009::*;
    use super::ansi_x9_42::DomainParameters;
    use super::ansi_x9_62::ECDomainParameters;
    use super::cmsobject_identifiers::{
        ID_CKM_KEY_AGREE_HASH, ID_CKM_KEY_AGREE_MULTIPLE_ENCRYPT, ID_CKM_KEY_TRANSPORT,
        ID_CKM_RECIP_INFO, ID_CKM_SYMMETRIC,
    };
    use super::cryptographic_message_syntax_2010::{
        ContentEncryptionAlgorithmIdentifier, DigestAlgorithmIdentifier, EncryptedKey,
        UserKeyingMaterial,
    };
    use super::pkix_common_types_2009::*;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CombinerAlgorithmIdentifier(pub AlgorithmIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ConstructionAlgorithms {
        pub combiner: CombinerAlgorithmIdentifier,
        #[rasn(identifier = "keyEncryptionAlgorithm")]
        pub key_encryption_algorithm: KeyEncryptionAlgorithmIdentifier,
    }
    impl ConstructionAlgorithms {
        pub fn new(
            combiner: CombinerAlgorithmIdentifier,
            key_encryption_algorithm: KeyEncryptionAlgorithmIdentifier,
        ) -> Self {
            Self {
                combiner,
                key_encryption_algorithm,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1.."))]
    pub struct DomainMaintenanceLevel(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct DomainName(pub PrintableString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum DomainParams {
        #[rasn(tag(context, 0))]
        dhParams(DomainParameters),
        #[rasn(tag(context, 1))]
        ecParams(ECDomainParameters),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct EncryptedRecipientID {
        pub algorithm: Option<ContentEncryptionAlgorithmIdentifier>,
        #[rasn(tag(context, 0), identifier = "keyID")]
        pub key_id: Option<OctetString>,
        pub ciphertext: OctetString,
    }
    impl EncryptedRecipientID {
        pub fn new(
            algorithm: Option<ContentEncryptionAlgorithmIdentifier>,
            key_id: Option<OctetString>,
            ciphertext: OctetString,
        ) -> Self {
            Self {
                algorithm,
                key_id,
                ciphertext,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct KeyConstructRecipientInfo {
        pub version: Version,
        pub did: Option<KeyConstructionDomain>,
        #[rasn(tag(context, 0))]
        pub ckmid: KeyConstructionRecipient,
        pub ukm: Option<UserKeyingMaterial>,
        #[rasn(identifier = "keyConstructionAlgorithm")]
        pub key_construction_algorithm: KeyConstructionAlgorithmIdentifier,
        #[rasn(identifier = "encryptedRandom")]
        pub encrypted_random: EncryptedKey,
    }
    impl KeyConstructRecipientInfo {
        pub fn new(
            version: Version,
            did: Option<KeyConstructionDomain>,
            ckmid: KeyConstructionRecipient,
            ukm: Option<UserKeyingMaterial>,
            key_construction_algorithm: KeyConstructionAlgorithmIdentifier,
            encrypted_random: EncryptedKey,
        ) -> Self {
            Self {
                version,
                did,
                ckmid,
                ukm,
                key_construction_algorithm,
                encrypted_random,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct KeyConstructionAlgorithmIdentifier(pub AlgorithmIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct KeyConstructionDomain {
        #[rasn(identifier = "domainName")]
        pub domain_name: DomainName,
        #[rasn(identifier = "domainMaintenanceLevel")]
        pub domain_maintenance_level: DomainMaintenanceLevel,
        #[rasn(identifier = "domainParams")]
        pub domain_params: Option<DomainParams>,
    }
    impl KeyConstructionDomain {
        pub fn new(
            domain_name: DomainName,
            domain_maintenance_level: DomainMaintenanceLevel,
            domain_params: Option<DomainParams>,
        ) -> Self {
            Self {
                domain_name,
                domain_maintenance_level,
                domain_params,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct KeyConstructionLabel(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct KeyConstructionLabels(pub SequenceOf<KeyConstructionLabel>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum KeyConstructionRecipient {
        #[rasn(tag(context, 0))]
        unencrypted(KeyConstructionLabels),
        #[rasn(tag(context, 1))]
        encrypted(EncryptedRecipientID),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct KeyEncryptionAlgorithmIdentifier(pub AlgorithmIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1.."))]
    pub struct Version(pub Integer);
}
