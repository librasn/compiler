---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x501_1997-TC2_BasicAccessControl.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to resolve supertype DirectoryString of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod basic_access_control {
    extern crate alloc;
    use super::directory_abstract_service::Filter;
    use super::information_framework::*;
    use super::selected_attribute_types::{
        DirectoryString, NameAndOptionalUID, DIRECTORY_STRING_FIRST_COMPONENT_MATCH,
    };
    use super::upper_bounds::UB_TAG;
    use super::useful_definitions::{
        DIRECTORY_ABSTRACT_SERVICE, ID_ACA, ID_AC_SCHEME, INFORMATION_FRAMEWORK,
        SELECTED_ATTRIBUTE_TYPES, UPPER_BOUNDS,
    };
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ACIItemItemOrUserFirstItemFirst {
        #[rasn(identifier = "protectedItems")]
        pub protected_items: ProtectedItems,
        #[rasn(identifier = "itemPermissions")]
        pub item_permissions: SetOf<ItemPermission>,
    }
    impl ACIItemItemOrUserFirstItemFirst {
        pub fn new(
            protected_items: ProtectedItems,
            item_permissions: SetOf<ItemPermission>,
        ) -> Self {
            Self {
                protected_items,
                item_permissions,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ACIItemItemOrUserFirstUserFirst {
        #[rasn(identifier = "userClasses")]
        pub user_classes: UserClasses,
        #[rasn(identifier = "userPermissions")]
        pub user_permissions: SetOf<UserPermission>,
    }
    impl ACIItemItemOrUserFirstUserFirst {
        pub fn new(user_classes: UserClasses, user_permissions: SetOf<UserPermission>) -> Self {
            Self {
                user_classes,
                user_permissions,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ACIItemItemOrUserFirst {
        #[rasn(tag(context, 0))]
        itemFirst(ACIItemItemOrUserFirstItemFirst),
        #[rasn(tag(context, 1))]
        userFirst(ACIItemItemOrUserFirstUserFirst),
    }
    #[doc = " types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ACIItem {
        #[rasn(value("0.."), identifier = "identificationTag")]
        pub identification_tag: DirectoryString,
        pub precedence: Precedence,
        #[rasn(identifier = "authenticationLevel")]
        pub authentication_level: AuthenticationLevel,
        #[rasn(identifier = "itemOrUserFirst")]
        pub item_or_user_first: ACIItemItemOrUserFirst,
    }
    impl ACIItem {
        pub fn new(
            identification_tag: DirectoryString,
            precedence: Precedence,
            authentication_level: AuthenticationLevel,
            item_or_user_first: ACIItemItemOrUserFirst,
        ) -> Self {
            Self {
                identification_tag,
                precedence,
                authentication_level,
                item_or_user_first,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct AttributeTypeAndValue {
        #[rasn(identifier = "type")]
        pub r_type: Any,
        pub value: Any,
    }
    impl AttributeTypeAndValue {
        pub fn new(r_type: Any, value: Any) -> Self {
            Self { r_type, value }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum AuthenticationLevelBasicLevelsLevel {
        none = 0,
        simple = 1,
        strong = 2,
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct AuthenticationLevelBasicLevels {
        pub level: AuthenticationLevelBasicLevelsLevel,
        #[rasn(identifier = "localQualifier")]
        pub local_qualifier: Option<Integer>,
        #[rasn(default = "authentication_level_basic_levels_signed_default")]
        pub signed: bool,
    }
    impl AuthenticationLevelBasicLevels {
        pub fn new(
            level: AuthenticationLevelBasicLevelsLevel,
            local_qualifier: Option<Integer>,
            signed: bool,
        ) -> Self {
            Self {
                level,
                local_qualifier,
                signed,
            }
        }
    }
    fn authentication_level_basic_levels_signed_default() -> bool {
        false
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AuthenticationLevel {
        basicLevels(AuthenticationLevelBasicLevels),
        other(Any),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GrantsAndDenials(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ItemPermission {
        pub precedence: Option<Precedence>,
        #[rasn(identifier = "userClasses")]
        pub user_classes: UserClasses,
        #[rasn(identifier = "grantsAndDenials")]
        pub grants_and_denials: GrantsAndDenials,
    }
    impl ItemPermission {
        pub fn new(
            precedence: Option<Precedence>,
            user_classes: UserClasses,
            grants_and_denials: GrantsAndDenials,
        ) -> Self {
            Self {
                precedence,
                user_classes,
                grants_and_denials,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MaxValueCount {
        #[rasn(identifier = "type")]
        pub r_type: AttributeType,
        #[rasn(identifier = "maxCount")]
        pub max_count: Integer,
    }
    impl MaxValueCount {
        pub fn new(r_type: AttributeType, max_count: Integer) -> Self {
            Self { r_type, max_count }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=255"))]
    pub struct Precedence(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ProtectedItems {
        #[rasn(tag(context, 0))]
        pub entry: Option<()>,
        #[rasn(tag(context, 1), identifier = "allUserAttributeTypes")]
        pub all_user_attribute_types: Option<()>,
        #[rasn(size("1.."), tag(context, 2), identifier = "attributeType")]
        pub attribute_type: Option<SetOf<AttributeType>>,
        #[rasn(size("1.."), tag(context, 3), identifier = "allAttributeValues")]
        pub all_attribute_values: Option<SetOf<AttributeType>>,
        #[rasn(tag(context, 4), identifier = "allUserAttributeTypesAndValues")]
        pub all_user_attribute_types_and_values: Option<()>,
        #[rasn(size("1.."), tag(context, 5), identifier = "attributeValue")]
        pub attribute_value: Option<SetOf<AttributeTypeAndValue>>,
        #[rasn(size("1.."), tag(context, 6), identifier = "selfValue")]
        pub self_value: Option<SetOf<AttributeType>>,
        #[rasn(tag(context, 7), identifier = "rangeOfValues")]
        pub range_of_values: Option<Filter>,
        #[rasn(size("1.."), tag(context, 8), identifier = "maxValueCount")]
        pub max_value_count: Option<SetOf<MaxValueCount>>,
        #[rasn(tag(context, 9), identifier = "maxImmSub")]
        pub max_imm_sub: Option<Integer>,
        #[rasn(size("1.."), tag(context, 10), identifier = "restrictedBy")]
        pub restricted_by: Option<SetOf<RestrictedValue>>,
        #[rasn(size("1.."), tag(context, 11))]
        pub contexts: Option<SetOf<ContextAssertion>>,
        #[rasn(tag(context, 12))]
        pub classes: Option<Refinement>,
    }
    impl ProtectedItems {
        pub fn new(
            entry: Option<()>,
            all_user_attribute_types: Option<()>,
            attribute_type: Option<SetOf<AttributeType>>,
            all_attribute_values: Option<SetOf<AttributeType>>,
            all_user_attribute_types_and_values: Option<()>,
            attribute_value: Option<SetOf<AttributeTypeAndValue>>,
            self_value: Option<SetOf<AttributeType>>,
            range_of_values: Option<Filter>,
            max_value_count: Option<SetOf<MaxValueCount>>,
            max_imm_sub: Option<Integer>,
            restricted_by: Option<SetOf<RestrictedValue>>,
            contexts: Option<SetOf<ContextAssertion>>,
            classes: Option<Refinement>,
        ) -> Self {
            Self {
                entry,
                all_user_attribute_types,
                attribute_type,
                all_attribute_values,
                all_user_attribute_types_and_values,
                attribute_value,
                self_value,
                range_of_values,
                max_value_count,
                max_imm_sub,
                restricted_by,
                contexts,
                classes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct RestrictedValue {
        #[rasn(identifier = "type")]
        pub r_type: AttributeType,
        #[rasn(identifier = "valuesIn")]
        pub values_in: AttributeType,
    }
    impl RestrictedValue {
        pub fn new(r_type: AttributeType, values_in: AttributeType) -> Self {
            Self { r_type, values_in }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct UserClasses {
        #[rasn(tag(context, 0), identifier = "allUsers")]
        pub all_users: Option<()>,
        #[rasn(tag(context, 1), identifier = "thisEntry")]
        pub this_entry: Option<()>,
        #[rasn(size("1.."), tag(context, 2))]
        pub name: Option<SetOf<NameAndOptionalUID>>,
        #[rasn(size("1.."), tag(context, 3), identifier = "userGroup")]
        pub user_group: Option<SetOf<NameAndOptionalUID>>,
        #[rasn(size("1.."), tag(context, 4))]
        pub subtree: Option<SetOf<SubtreeSpecification>>,
    }
    impl UserClasses {
        pub fn new(
            all_users: Option<()>,
            this_entry: Option<()>,
            name: Option<SetOf<NameAndOptionalUID>>,
            user_group: Option<SetOf<NameAndOptionalUID>>,
            subtree: Option<SetOf<SubtreeSpecification>>,
        ) -> Self {
            Self {
                all_users,
                this_entry,
                name,
                user_group,
                subtree,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct UserPermission {
        pub precedence: Option<Precedence>,
        #[rasn(identifier = "protectedItems")]
        pub protected_items: ProtectedItems,
        #[rasn(identifier = "grantsAndDenials")]
        pub grants_and_denials: GrantsAndDenials,
    }
    impl UserPermission {
        pub fn new(
            precedence: Option<Precedence>,
            protected_items: ProtectedItems,
            grants_and_denials: GrantsAndDenials,
        ) -> Self {
            Self {
                precedence,
                protected_items,
                grants_and_denials,
            }
        }
    }
    #[doc = " access control schemes -"]
    pub static BASIC_ACCESS_CONTROL_SCHEME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AC_SCHEME, &[1u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " object identifier assignments"]
    #[doc = " attributes"]
    pub static ID_ACA_ACCESS_CONTROL_SCHEME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_ACA, &[1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_ACA_ENTRY_ACI: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_ACA, &[5u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_ACA_PRESCRIPTIVE_ACI: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_ACA, &[4u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_ACA_SUBENTRY_ACI: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_ACA, &[6u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static RULE_AND_BASIC_ACCESS_CONTROL: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AC_SCHEME, &[4u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static RULE_AND_SIMPLE_ACCESS_CONTROL: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AC_SCHEME, &[5u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static RULE_BASED_ACCESS_CONTROL: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AC_SCHEME, &[3u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static SIMPLIFIED_ACCESS_CONTROL_SCHEME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AC_SCHEME, &[2u32]].concat())
            .unwrap()
            .to_owned()
    });
}
