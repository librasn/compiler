---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x501_1997-TC1_UsefulDefinitions.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod useful_definitions {
    extern crate alloc;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " EXPORTS All"]
    #[doc = " The types and values defined in this module are exported for use in the other ASN.1 modules contained"]
    #[doc = " within the Directory Specifications, and for the use of other applications which will use them to access"]
    #[doc = " Directory services. Other applications may use them for their own purposes, but this will not constrain"]
    #[doc = " extensions and modifications needed to maintain or improve the Directory service."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ID(pub ObjectIdentifier);
    pub static ALGORITHM_OBJECT_IDENTIFIERS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[8u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static AUTHENTICATION_FRAMEWORK: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[7u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static BASIC_ACCESS_CONTROL: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[24u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static CERTIFICATE_EXTENSIONS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[26u32, 0u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DAP: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[11u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_ABSTRACT_SERVICE: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[2u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_IDMPROTOCOLS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[31u32, 4u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_MANAGEMENT: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[27u32, 1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_OBJECT_IDENTIFIERS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[9u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_OPERATIONAL_BINDING_TYPES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[25u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_SECURITY_EXCHANGES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[29u32, 1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_SHADOW_ABSTRACT_SERVICE: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[15u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_SHADOW_OIDS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[14u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DISP: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[16u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DISTRIBUTED_DIRECTORY_OIDS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[13u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DISTRIBUTED_OPERATIONS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[3u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DOP: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[17u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DS: LazyLock<ID> = LazyLock::new(|| ID(Oid::const_new(&[2u32, 5u32]).to_owned()));
    pub static DSA_OPERATIONAL_ATTRIBUTE_TYPES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[22u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DSP: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[12u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ENHANCED_SECURITY: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[28u32, 1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static HIERARCHICAL_OPERATIONAL_BINDINGS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[20u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static I_DMPROTOCOL_SPECIFICATION: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[30u32, 4u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_AC: LazyLock<ID> = LazyLock::new(|| ID(APPLICATION_CONTEXT));
    pub static ID_AC_SCHEME: LazyLock<ID> = LazyLock::new(|| ID(ACCESS_CONTROL_SCHEMES));
    pub static ID_ACA: LazyLock<ID> = LazyLock::new(|| ID(ACCESS_CONTROL_ATTRIBUTE));
    pub static ID_AR: LazyLock<ID> = LazyLock::new(|| ID(ADMINISTRATIVE_ROLES));
    pub static ID_AS: LazyLock<ID> = LazyLock::new(|| ID(ABSTRACT_SYNTAX));
    pub static ID_AT: LazyLock<ID> = LazyLock::new(|| ID(ATTRIBUTE_TYPE));
    pub static ID_AVC: LazyLock<ID> = LazyLock::new(|| ID(ATTRIBUTE_VALUE_CONTEXT));
    pub static ID_CAT: LazyLock<ID> = LazyLock::new(|| ID(CONTROL_ATTRIBUTE_TYPE));
    pub static ID_CE: LazyLock<ID> = LazyLock::new(|| ID(CERTIFICATE_EXTENSION));
    pub static ID_CONTRACT: LazyLock<ID> = LazyLock::new(|| ID(CONTRACT));
    pub static ID_DOA: LazyLock<ID> = LazyLock::new(|| ID(DSA_OPERATIONAL_ATTRIBUTE));
    pub static ID_IDM: LazyLock<ID> = LazyLock::new(|| ID(IDM_PROTOCOL));
    pub static ID_KMR: LazyLock<ID> = LazyLock::new(|| ID(KNOWLEDGE_MATCHING_RULE));
    pub static ID_MGT: LazyLock<ID> = LazyLock::new(|| ID(MANAGEMENT_OBJECT));
    pub static ID_MR: LazyLock<ID> = LazyLock::new(|| ID(MATCHING_RULE));
    pub static ID_MRE: LazyLock<ID> = LazyLock::new(|| ID(MATCHING_RESTRICTION));
    pub static ID_NF: LazyLock<ID> = LazyLock::new(|| ID(NAME_FORM));
    pub static ID_NOT: LazyLock<ID> = LazyLock::new(|| ID(NOTIFICATION));
    pub static ID_OA: LazyLock<ID> = LazyLock::new(|| ID(OPERATIONAL_ATTRIBUTE_TYPE));
    pub static ID_OB: LazyLock<ID> = LazyLock::new(|| ID(OPERATIONAL_BINDING));
    #[doc = " synonyms"]
    pub static ID_OC: LazyLock<ID> = LazyLock::new(|| ID(OBJECT_CLASS));
    pub static ID_PACKAGE: LazyLock<ID> = LazyLock::new(|| ID(PACKAGE));
    pub static ID_PR: LazyLock<ID> = LazyLock::new(|| ID(PROBLEM));
    pub static ID_ROS_OBJECT: LazyLock<ID> = LazyLock::new(|| ID(ROS_OBJECT));
    pub static ID_SC: LazyLock<ID> = LazyLock::new(|| ID(SUBENTRY));
    pub static ID_SE: LazyLock<ID> = LazyLock::new(|| ID(SECURITY_EXCHANGE));
    pub static ID_SOA: LazyLock<ID> = LazyLock::new(|| ID(SCHEMA_OPERATIONAL_ATTRIBUTE));
    pub static ID_SOC: LazyLock<ID> = LazyLock::new(|| ID(SCHEMA_OBJECT_CLASS));
    pub static INFORMATION_FRAMEWORK: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[1u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static OP_BINDING_MANAGEMENT: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[18u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static OP_BINDING_OIDS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[19u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static PROTOCOL_OBJECT_IDENTIFIERS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[4u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static SCHEMA_ADMINISTRATION: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[23u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static SELECTED_ATTRIBUTE_TYPES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[5u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static SELECTED_OBJECT_CLASSES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[6u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static UPPER_BOUNDS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[10u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " modules"]
    pub static USEFUL_DEFINITIONS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[0u32, 3u32]].concat())
            .unwrap()
            .to_owned())
    });
}
