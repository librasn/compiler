---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_h_h235_2003_H235-SECURITY-MESSAGES.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod h235_security_messages {
    extern crate alloc;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AuthenticationBES {
        default(()),
        radius(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AuthenticationMechanism {
        dhExch(()),
        pwdSymEnc(()),
        pwdHash(()),
        certSign(()),
        ipsec(()),
        tls(()),
        nonStandard(NonStandardParameter),
        #[rasn(extension_addition)]
        authenticationBES(AuthenticationBES),
    }
    #[doc = " EXPORTS All"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("8..=128"))]
    pub struct ChallengeString(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ClearToken {
        #[rasn(identifier = "tokenOID")]
        pub token_oid: ObjectIdentifier,
        #[rasn(identifier = "timeStamp")]
        pub time_stamp: Option<TimeStamp>,
        pub password: Option<Password>,
        pub dhkey: Option<DHset>,
        pub challenge: Option<ChallengeString>,
        pub random: Option<RandomVal>,
        pub certificate: Option<TypedCertificate>,
        #[rasn(identifier = "generalID")]
        pub general_id: Option<Identifier>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<NonStandardParameter>,
        #[rasn(extension_addition)]
        pub eckasdhkey: Option<ECKASDH>,
        #[rasn(extension_addition, identifier = "sendersID")]
        pub senders_id: Option<Identifier>,
        #[rasn(extension_addition, identifier = "h235Key")]
        pub h235_key: Option<H235Key>,
    }
    impl ClearToken {
        pub fn new(
            token_oid: ObjectIdentifier,
            time_stamp: Option<TimeStamp>,
            password: Option<Password>,
            dhkey: Option<DHset>,
            challenge: Option<ChallengeString>,
            random: Option<RandomVal>,
            certificate: Option<TypedCertificate>,
            general_id: Option<Identifier>,
            non_standard: Option<NonStandardParameter>,
            eckasdhkey: Option<ECKASDH>,
            senders_id: Option<Identifier>,
            h235_key: Option<H235Key>,
        ) -> Self {
            Self {
                token_oid,
                time_stamp,
                password,
                dhkey,
                challenge,
                random,
                certificate,
                general_id,
                non_standard,
                eckasdhkey,
                senders_id,
                h235_key,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CryptoTokenCryptoEncryptedTokenTokenParamS {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl CryptoTokenCryptoEncryptedTokenTokenParamS {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoTokenCryptoEncryptedTokenToken {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: CryptoTokenCryptoEncryptedTokenTokenParamS,
        #[rasn(identifier = "encryptedData")]
        pub encrypted_data: OctetString,
    }
    impl CryptoTokenCryptoEncryptedTokenToken {
        pub fn new(
            algorithm_oid: ObjectIdentifier,
            param_s: CryptoTokenCryptoEncryptedTokenTokenParamS,
            encrypted_data: OctetString,
        ) -> Self {
            Self {
                algorithm_oid,
                param_s,
                encrypted_data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoTokenCryptoEncryptedToken {
        #[rasn(identifier = "tokenOID")]
        pub token_oid: ObjectIdentifier,
        pub token: CryptoTokenCryptoEncryptedTokenToken,
    }
    impl CryptoTokenCryptoEncryptedToken {
        pub fn new(
            token_oid: ObjectIdentifier,
            token: CryptoTokenCryptoEncryptedTokenToken,
        ) -> Self {
            Self { token_oid, token }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CryptoTokenCryptoSignedTokenTokenParamS {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl CryptoTokenCryptoSignedTokenTokenParamS {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoTokenCryptoSignedTokenToken {
        #[rasn(identifier = "toBeSigned")]
        pub to_be_signed: EncodedGeneralToken,
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: CryptoTokenCryptoSignedTokenTokenParamS,
        pub signature: BitString,
    }
    impl CryptoTokenCryptoSignedTokenToken {
        pub fn new(
            to_be_signed: EncodedGeneralToken,
            algorithm_oid: ObjectIdentifier,
            param_s: CryptoTokenCryptoSignedTokenTokenParamS,
            signature: BitString,
        ) -> Self {
            Self {
                to_be_signed,
                algorithm_oid,
                param_s,
                signature,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoTokenCryptoSignedToken {
        #[rasn(identifier = "tokenOID")]
        pub token_oid: ObjectIdentifier,
        pub token: CryptoTokenCryptoSignedTokenToken,
    }
    impl CryptoTokenCryptoSignedToken {
        pub fn new(token_oid: ObjectIdentifier, token: CryptoTokenCryptoSignedTokenToken) -> Self {
            Self { token_oid, token }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CryptoTokenCryptoHashedTokenTokenParamS {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl CryptoTokenCryptoHashedTokenTokenParamS {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoTokenCryptoHashedTokenToken {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: CryptoTokenCryptoHashedTokenTokenParamS,
        pub hash: BitString,
    }
    impl CryptoTokenCryptoHashedTokenToken {
        pub fn new(
            algorithm_oid: ObjectIdentifier,
            param_s: CryptoTokenCryptoHashedTokenTokenParamS,
            hash: BitString,
        ) -> Self {
            Self {
                algorithm_oid,
                param_s,
                hash,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoTokenCryptoHashedToken {
        #[rasn(identifier = "tokenOID")]
        pub token_oid: ObjectIdentifier,
        #[rasn(identifier = "hashedVals")]
        pub hashed_vals: ClearToken,
        pub token: CryptoTokenCryptoHashedTokenToken,
    }
    impl CryptoTokenCryptoHashedToken {
        pub fn new(
            token_oid: ObjectIdentifier,
            hashed_vals: ClearToken,
            token: CryptoTokenCryptoHashedTokenToken,
        ) -> Self {
            Self {
                token_oid,
                hashed_vals,
                token,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CryptoTokenCryptoPwdEncrParamS {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl CryptoTokenCryptoPwdEncrParamS {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoTokenCryptoPwdEncr {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: CryptoTokenCryptoPwdEncrParamS,
        #[rasn(identifier = "encryptedData")]
        pub encrypted_data: OctetString,
    }
    impl CryptoTokenCryptoPwdEncr {
        pub fn new(
            algorithm_oid: ObjectIdentifier,
            param_s: CryptoTokenCryptoPwdEncrParamS,
            encrypted_data: OctetString,
        ) -> Self {
            Self {
                algorithm_oid,
                param_s,
                encrypted_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CryptoToken {
        cryptoEncryptedToken(CryptoTokenCryptoEncryptedToken),
        cryptoSignedToken(CryptoTokenCryptoSignedToken),
        cryptoHashedToken(CryptoTokenCryptoHashedToken),
        cryptoPwdEncr(CryptoTokenCryptoPwdEncr),
    }
    #[doc = " if local octet representations of these bit strings are used they shall"]
    #[doc = " utilize standard Network Octet ordering (e.g. Big Endian)"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DHset {
        #[rasn(size("0..=2048"))]
        pub halfkey: BitString,
        #[rasn(size("0..=2048"), identifier = "modSize")]
        pub mod_size: BitString,
        #[rasn(size("0..=2048"))]
        pub generator: BitString,
    }
    impl DHset {
        pub fn new(halfkey: BitString, mod_size: BitString, generator: BitString) -> Self {
            Self {
                halfkey,
                mod_size,
                generator,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct ECGDSASignature {
        #[rasn(size("0..=511"))]
        pub r: BitString,
        #[rasn(size("0..=511"))]
        pub s: BitString,
    }
    impl ECGDSASignature {
        pub fn new(r: BitString, s: BitString) -> Self {
            Self { r, s }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct ECKASDHEckasdhp {
        #[rasn(identifier = "public-key")]
        pub public_key: ECpoint,
        #[rasn(size("0..=511"))]
        pub modulus: BitString,
        pub base: ECpoint,
        #[rasn(size("0..=511"), identifier = "weierstrassA")]
        pub weierstrass_a: BitString,
        #[rasn(size("0..=511"), identifier = "weierstrassB")]
        pub weierstrass_b: BitString,
    }
    impl ECKASDHEckasdhp {
        pub fn new(
            public_key: ECpoint,
            modulus: BitString,
            base: ECpoint,
            weierstrass_a: BitString,
            weierstrass_b: BitString,
        ) -> Self {
            Self {
                public_key,
                modulus,
                base,
                weierstrass_a,
                weierstrass_b,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct ECKASDHEckasdh2 {
        #[rasn(identifier = "public-key")]
        pub public_key: ECpoint,
        #[rasn(size("0..=511"), identifier = "fieldSize")]
        pub field_size: BitString,
        pub base: ECpoint,
        #[rasn(size("0..=511"), identifier = "weierstrassA")]
        pub weierstrass_a: BitString,
        #[rasn(size("0..=511"), identifier = "weierstrassB")]
        pub weierstrass_b: BitString,
    }
    impl ECKASDHEckasdh2 {
        pub fn new(
            public_key: ECpoint,
            field_size: BitString,
            base: ECpoint,
            weierstrass_a: BitString,
            weierstrass_b: BitString,
        ) -> Self {
            Self {
                public_key,
                field_size,
                base,
                weierstrass_a,
                weierstrass_b,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ECKASDH {
        eckasdhp(ECKASDHEckasdhp),
        eckasdh2(ECKASDHEckasdh2),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ECpoint {
        #[rasn(size("0..=511"))]
        pub x: Option<BitString>,
        #[rasn(size("0..=511"))]
        pub y: Option<BitString>,
    }
    impl ECpoint {
        pub fn new(x: Option<BitString>, y: Option<BitString>) -> Self {
            Self { x, y }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EncodedGeneralToken(pub Any);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EncodedKeySignedMaterial(pub Any);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EncodedKeySyncMaterial(pub Any);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EncodedPwdCertToken(pub Any);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EncodedReturnSig(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H235CertificateSignatureSignatureParamS {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl H235CertificateSignatureSignatureParamS {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct H235CertificateSignatureSignature {
        #[rasn(identifier = "toBeSigned")]
        pub to_be_signed: EncodedReturnSig,
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: H235CertificateSignatureSignatureParamS,
        pub signature: BitString,
    }
    impl H235CertificateSignatureSignature {
        pub fn new(
            to_be_signed: EncodedReturnSig,
            algorithm_oid: ObjectIdentifier,
            param_s: H235CertificateSignatureSignatureParamS,
            signature: BitString,
        ) -> Self {
            Self {
                to_be_signed,
                algorithm_oid,
                param_s,
                signature,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H235CertificateSignature {
        pub certificate: TypedCertificate,
        #[rasn(identifier = "responseRandom")]
        pub response_random: RandomVal,
        #[rasn(identifier = "requesterRandom")]
        pub requester_random: Option<RandomVal>,
        pub signature: H235CertificateSignatureSignature,
    }
    impl H235CertificateSignature {
        pub fn new(
            certificate: TypedCertificate,
            response_random: RandomVal,
            requester_random: Option<RandomVal>,
            signature: H235CertificateSignatureSignature,
        ) -> Self {
            Self {
                certificate,
                response_random,
                requester_random,
                signature,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H235KeySharedSecretParamS {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl H235KeySharedSecretParamS {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct H235KeySharedSecret {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: H235KeySharedSecretParamS,
        #[rasn(identifier = "encryptedData")]
        pub encrypted_data: OctetString,
    }
    impl H235KeySharedSecret {
        pub fn new(
            algorithm_oid: ObjectIdentifier,
            param_s: H235KeySharedSecretParamS,
            encrypted_data: OctetString,
        ) -> Self {
            Self {
                algorithm_oid,
                param_s,
                encrypted_data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H235KeyCertProtectedKeyParamS {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl H235KeyCertProtectedKeyParamS {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct H235KeyCertProtectedKey {
        #[rasn(identifier = "toBeSigned")]
        pub to_be_signed: EncodedKeySignedMaterial,
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: H235KeyCertProtectedKeyParamS,
        pub signature: BitString,
    }
    impl H235KeyCertProtectedKey {
        pub fn new(
            to_be_signed: EncodedKeySignedMaterial,
            algorithm_oid: ObjectIdentifier,
            param_s: H235KeyCertProtectedKeyParamS,
            signature: BitString,
        ) -> Self {
            Self {
                to_be_signed,
                algorithm_oid,
                param_s,
                signature,
            }
        }
    }
    #[doc = " These allow the passing of session keys within the H.245 OLC structure."]
    #[doc = " They are encoded as standalone ASN.1 and based as an OCTET STRING within H.245"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H235Key {
        secureChannel(KeyMaterial),
        sharedSecret(H235KeySharedSecret),
        certProtectedKey(H235KeyCertProtectedKey),
        #[rasn(extension_addition)]
        secureSharedSecret(V3KeySyncMaterial),
    }
    #[doc = " initial value for 64-bit block ciphers"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct IV16(pub FixedOctetString<16usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct IV8(pub FixedOctetString<8usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=128"))]
    pub struct Identifier(pub BmpString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=2048"))]
    pub struct KeyMaterial(pub BitString);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct KeySignedMaterialEncrptvalParamS {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl KeySignedMaterialEncrptvalParamS {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct KeySignedMaterialEncrptval {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: KeySignedMaterialEncrptvalParamS,
        #[rasn(identifier = "encryptedData")]
        pub encrypted_data: OctetString,
    }
    impl KeySignedMaterialEncrptval {
        pub fn new(
            algorithm_oid: ObjectIdentifier,
            param_s: KeySignedMaterialEncrptvalParamS,
            encrypted_data: OctetString,
        ) -> Self {
            Self {
                algorithm_oid,
                param_s,
                encrypted_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct KeySignedMaterial {
        #[rasn(identifier = "generalId")]
        pub general_id: Identifier,
        pub mrandom: RandomVal,
        pub srandom: Option<RandomVal>,
        #[rasn(identifier = "timeStamp")]
        pub time_stamp: Option<TimeStamp>,
        pub encrptval: KeySignedMaterialEncrptval,
    }
    impl KeySignedMaterial {
        pub fn new(
            general_id: Identifier,
            mrandom: RandomVal,
            srandom: Option<RandomVal>,
            time_stamp: Option<TimeStamp>,
            encrptval: KeySignedMaterialEncrptval,
        ) -> Self {
            Self {
                general_id,
                mrandom,
                srandom,
                time_stamp,
                encrptval,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct KeySyncMaterial {
        #[rasn(identifier = "generalID")]
        pub general_id: Identifier,
        #[rasn(identifier = "keyMaterial")]
        pub key_material: KeyMaterial,
    }
    impl KeySyncMaterial {
        pub fn new(general_id: Identifier, key_material: KeyMaterial) -> Self {
            Self {
                general_id,
                key_material,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct NonStandardParameter {
        #[rasn(identifier = "nonStandardIdentifier")]
        pub non_standard_identifier: ObjectIdentifier,
        pub data: OctetString,
    }
    impl NonStandardParameter {
        pub fn new(non_standard_identifier: ObjectIdentifier, data: OctetString) -> Self {
            Self {
                non_standard_identifier,
                data,
            }
        }
    }
    #[doc = " initial value for 128-bit block ciphers"]
    #[doc = " signing algorithm used must select one of these types of parameters"]
    #[doc = " needed by receiving end of signature."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Params {
        #[rasn(identifier = "ranInt")]
        pub ran_int: Option<Integer>,
        pub iv8: Option<IV8>,
        #[rasn(extension_addition)]
        pub iv16: Option<IV16>,
        #[rasn(extension_addition)]
        pub iv: Option<OctetString>,
        #[rasn(extension_addition, identifier = "clearSalt")]
        pub clear_salt: Option<OctetString>,
    }
    impl Params {
        pub fn new(
            ran_int: Option<Integer>,
            iv8: Option<IV8>,
            iv16: Option<IV16>,
            iv: Option<OctetString>,
            clear_salt: Option<OctetString>,
        ) -> Self {
            Self {
                ran_int,
                iv8,
                iv16,
                iv,
                clear_salt,
            }
        }
    }
    #[doc = " 32-bit Integer"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=128"))]
    pub struct Password(pub BmpString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PwdCertToken(pub ClearToken);
    #[doc = " seconds since 00:00 1/1/1970 UTC"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RandomVal(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct ReturnSig {
        #[rasn(identifier = "generalId")]
        pub general_id: Identifier,
        #[rasn(identifier = "responseRandom")]
        pub response_random: RandomVal,
        #[rasn(identifier = "requestRandom")]
        pub request_random: Option<RandomVal>,
        pub certificate: Option<TypedCertificate>,
    }
    impl ReturnSig {
        pub fn new(
            general_id: Identifier,
            response_random: RandomVal,
            request_random: Option<RandomVal>,
            certificate: Option<TypedCertificate>,
        ) -> Self {
            Self {
                general_id,
                response_random,
                request_random,
                certificate,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=4294967295"))]
    pub struct TimeStamp(pub u32);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TypedCertificate {
        #[rasn(identifier = "type")]
        pub r_type: ObjectIdentifier,
        pub certificate: OctetString,
    }
    impl TypedCertificate {
        pub fn new(r_type: ObjectIdentifier, certificate: OctetString) -> Self {
            Self {
                r_type,
                certificate,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct V3KeySyncMaterial {
        #[rasn(identifier = "generalID")]
        pub general_id: Option<Identifier>,
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: Option<ObjectIdentifier>,
        #[rasn(identifier = "paramS")]
        pub param_s: Params,
        #[rasn(identifier = "encryptedSessionKey")]
        pub encrypted_session_key: Option<OctetString>,
        #[rasn(identifier = "encryptedSaltingKey")]
        pub encrypted_salting_key: Option<OctetString>,
        #[rasn(identifier = "clearSaltingKey")]
        pub clear_salting_key: Option<OctetString>,
        #[rasn(identifier = "paramSsalt")]
        pub param_ssalt: Option<Params>,
        #[rasn(identifier = "keyDerivationOID")]
        pub key_derivation_oid: Option<ObjectIdentifier>,
    }
    impl V3KeySyncMaterial {
        pub fn new(
            general_id: Option<Identifier>,
            algorithm_oid: Option<ObjectIdentifier>,
            param_s: Params,
            encrypted_session_key: Option<OctetString>,
            encrypted_salting_key: Option<OctetString>,
            clear_salting_key: Option<OctetString>,
            param_ssalt: Option<Params>,
            key_derivation_oid: Option<ObjectIdentifier>,
        ) -> Self {
            Self {
                general_id,
                algorithm_oid,
                param_s,
                encrypted_session_key,
                encrypted_salting_key,
                clear_salting_key,
                param_ssalt,
                key_derivation_oid,
            }
        }
    }
}
