---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_h_h460.9_2002_QOS-MONITORING-EXTENDED-VOIP-REPORT.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to link value with 'GenericIdentifier'


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod qos_monitoring_extended_voip_report {
    extern crate alloc;
    use super::h323_messages::GenericIdentifier;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BurstMetrics {
        #[rasn(value("0..=255"))]
        pub gmin: Option<u8>,
        #[rasn(value("0..=255"), identifier = "burstLossDensity")]
        pub burst_loss_density: Option<u8>,
        #[rasn(value("0..=255"), identifier = "gapLossDensity")]
        pub gap_loss_density: Option<u8>,
        #[rasn(value("0..=65535"), identifier = "burstDuration")]
        pub burst_duration: Option<u16>,
        #[rasn(value("0..=65535"), identifier = "gapDuration")]
        pub gap_duration: Option<u16>,
    }
    impl BurstMetrics {
        pub fn new(
            gmin: Option<u8>,
            burst_loss_density: Option<u8>,
            gap_loss_density: Option<u8>,
            burst_duration: Option<u16>,
            gap_duration: Option<u16>,
        ) -> Self {
            Self {
                gmin,
                burst_loss_density,
                gap_loss_density,
                burst_duration,
                gap_duration,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ExtendedRTPMetrics {
        #[rasn(value("0..=255"), identifier = "networkPacketLossRate")]
        pub network_packet_loss_rate: Option<u8>,
        #[rasn(value("0..=255"), identifier = "jitterBufferDiscardRate")]
        pub jitter_buffer_discard_rate: Option<u8>,
        #[rasn(identifier = "burstMetrics")]
        pub burst_metrics: Option<BurstMetrics>,
        #[rasn(value("0..=65535"), identifier = "rtcpRoundTripDelay")]
        pub rtcp_round_trip_delay: Option<u16>,
        #[rasn(value("0..=65535"), identifier = "endSystemDelay")]
        pub end_system_delay: Option<u16>,
        #[rasn(value("-127..=10"), identifier = "signalLevel")]
        pub signal_level: Option<i8>,
        #[rasn(value("-127..=0"), identifier = "noiseLevel")]
        pub noise_level: Option<i8>,
        #[rasn(value("0..=127"), identifier = "residualEchoReturnLoss")]
        pub residual_echo_return_loss: Option<u8>,
        #[rasn(value("0..=100"), identifier = "rFactor")]
        pub r_factor: Option<u8>,
        #[rasn(value("0..=100"), identifier = "extRFactor")]
        pub ext_rfactor: Option<u8>,
        #[rasn(value("10..=50"), identifier = "estimatedMOSLQ")]
        pub estimated_moslq: Option<u8>,
        #[rasn(value("10..=50"), identifier = "estimatedMOSCQ")]
        pub estimated_moscq: Option<u8>,
        #[rasn(identifier = "plcType")]
        pub plc_type: Option<PLCtypes>,
        #[rasn(identifier = "jitterBufferParms")]
        pub jitter_buffer_parms: Option<JitterBufferParms>,
    }
    impl ExtendedRTPMetrics {
        pub fn new(
            network_packet_loss_rate: Option<u8>,
            jitter_buffer_discard_rate: Option<u8>,
            burst_metrics: Option<BurstMetrics>,
            rtcp_round_trip_delay: Option<u16>,
            end_system_delay: Option<u16>,
            signal_level: Option<i8>,
            noise_level: Option<i8>,
            residual_echo_return_loss: Option<u8>,
            r_factor: Option<u8>,
            ext_rfactor: Option<u8>,
            estimated_moslq: Option<u8>,
            estimated_moscq: Option<u8>,
            plc_type: Option<PLCtypes>,
            jitter_buffer_parms: Option<JitterBufferParms>,
        ) -> Self {
            Self {
                network_packet_loss_rate,
                jitter_buffer_discard_rate,
                burst_metrics,
                rtcp_round_trip_delay,
                end_system_delay,
                signal_level,
                noise_level,
                residual_echo_return_loss,
                r_factor,
                ext_rfactor,
                estimated_moslq,
                estimated_moscq,
                plc_type,
                jitter_buffer_parms,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct JitterBufferParms {
        #[rasn(identifier = "jitterBufferType")]
        pub jitter_buffer_type: Option<JitterBufferTypes>,
        #[rasn(value("0..=15"), identifier = "jitterBufferAdaptRate")]
        pub jitter_buffer_adapt_rate: Option<u8>,
        #[rasn(value("0..=65535"), identifier = "jitterBufferNominalSize")]
        pub jitter_buffer_nominal_size: Option<u16>,
        #[rasn(value("0..=65535"), identifier = "jitterBufferMaxSize")]
        pub jitter_buffer_max_size: Option<u16>,
        #[rasn(value("0..=65535"), identifier = "jitterBufferAbsoluteMax")]
        pub jitter_buffer_absolute_max: Option<u16>,
    }
    impl JitterBufferParms {
        pub fn new(
            jitter_buffer_type: Option<JitterBufferTypes>,
            jitter_buffer_adapt_rate: Option<u8>,
            jitter_buffer_nominal_size: Option<u16>,
            jitter_buffer_max_size: Option<u16>,
            jitter_buffer_absolute_max: Option<u16>,
        ) -> Self {
            Self {
                jitter_buffer_type,
                jitter_buffer_adapt_rate,
                jitter_buffer_nominal_size,
                jitter_buffer_max_size,
                jitter_buffer_absolute_max,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum JitterBufferTypes {
        unknown(()),
        reserved(()),
        nonadaptive(()),
        adaptive(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PLCtypes {
        unspecified(()),
        disabled(()),
        enhanced(()),
        standard(()),
    }
    pub static QOS_MONITORING_EXTENDED_RTPMETRICS: LazyLock<GenericIdentifier> =
        LazyLock::new(|| GenericIdentifier(GenericIdentifier(GenericIdentifier::standard(2))));
}
