---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_t_t424_1996_Temporal-Relationships.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod temporal_relationships {
    extern crate alloc;
    use super::document_profile_descriptor::DateAndTime;
    use super::identifiers_and_expressions::ObjectOrClassIdentifier;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum CyclicNumberOfCycles {
        indefinite(Indefinite),
        a(Integer),
    }
    #[doc = "  only digits and spaces are used"]
    #[doc = "  the first digit is either 2 for a logical object class or 3 for a logical object"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set)]
    pub struct Cyclic {
        #[rasn(tag(context, 0), identifier = "number-of-cycles")]
        pub number_of_cycles: CyclicNumberOfCycles,
        #[rasn(tag(context, 1), identifier = "cycle-start-time")]
        pub cycle_start_time: Option<TimeDelay>,
        #[rasn(tag(context, 2), identifier = "cycle-duration")]
        pub cycle_duration: Option<IndefiniteOrTimeDelay>,
    }
    impl Cyclic {
        pub fn new(
            number_of_cycles: CyclicNumberOfCycles,
            cycle_start_time: Option<TimeDelay>,
            cycle_duration: Option<IndefiniteOrTimeDelay>,
        ) -> Self {
            Self {
                number_of_cycles,
                cycle_start_time,
                cycle_duration,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "Document-Presentation-Time")]
    pub struct DocumentPresentationTime(pub DateAndTime);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct Indefinite(pub ());
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "Indefinite-or-Time-Delay")]
    pub enum IndefiniteOrTimeDelay {
        #[rasn(tag(context, 0))]
        indefinite(()),
        #[rasn(tag(context, 1))]
        fixed(TimeDelay),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "Node-Identifier")]
    pub struct NodeIdentifier(pub PrintableString);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum PresentationTimeTiming {
        #[rasn(tag(context, 0), identifier = "fixed-timing")]
        fixed_timing(Integer),
        #[rasn(tag(context, 1), identifier = "variable-timing")]
        variable_timing(TimeSpec),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum PresentationTimeDurationFixedDuration {
        #[rasn(identifier = "indefinite-or-time-delay")]
        indefinite_or_time_delay(IndefiniteOrTimeDelay),
        #[rasn(identifier = "object-or-class-identifier")]
        object_or_class_identifier(ObjectOrClassIdentifier),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum PresentationTimeDuration {
        #[rasn(tag(context, 2), identifier = "fixed-duration")]
        fixed_duration(PresentationTimeDurationFixedDuration),
        #[rasn(tag(context, 3), identifier = "rule-A")]
        rule_A(RuleSpec),
        #[rasn(tag(context, 4), identifier = "rule-B")]
        rule_B(RuleSpec),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set, identifier = "Presentation-Time")]
    pub struct PresentationTime {
        pub timing: Option<PresentationTimeTiming>,
        pub duration: Option<PresentationTimeDuration>,
        #[rasn(tag(context, 5))]
        pub cyclic: Option<Cyclic>,
    }
    impl PresentationTime {
        pub fn new(
            timing: Option<PresentationTimeTiming>,
            duration: Option<PresentationTimeDuration>,
            cyclic: Option<Cyclic>,
        ) -> Self {
            Self {
                timing,
                duration,
                cyclic,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set, identifier = "Rule-Spec")]
    pub struct RuleSpec {
        #[rasn(tag(context, 0), identifier = "minimum-duration")]
        pub minimum_duration: Option<Integer>,
        #[rasn(tag(context, 1), identifier = "maximum-duration")]
        pub maximum_duration: Option<Integer>,
    }
    impl RuleSpec {
        pub fn new(minimum_duration: Option<Integer>, maximum_duration: Option<Integer>) -> Self {
            Self {
                minimum_duration,
                maximum_duration,
            }
        }
    }
    #[doc = "  The value 'null' is represented by an empty set"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "Synchronization-Type")]
    pub struct SynchronizationType(pub Integer);
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set, identifier = "SET")]
    pub struct AnonymousTemporalRelationsSubordinateNodes {
        #[rasn(tag(context, 0), identifier = "node-identifier")]
        pub node_identifier: NodeIdentifier,
        #[rasn(tag(context, 1), identifier = "start-time")]
        pub start_time: Option<TimeDelay>,
        #[rasn(tag(context, 2))]
        pub duration: Option<IndefiniteOrTimeDelay>,
        #[rasn(tag(context, 3))]
        pub cyclic: Option<Cyclic>,
        #[rasn(tag(context, 4), identifier = "end-time")]
        pub end_time: Option<TimeDelay>,
        #[rasn(tag(context, 5), identifier = "application-comments")]
        pub application_comments: Option<OctetString>,
    }
    impl AnonymousTemporalRelationsSubordinateNodes {
        pub fn new(
            node_identifier: NodeIdentifier,
            start_time: Option<TimeDelay>,
            duration: Option<IndefiniteOrTimeDelay>,
            cyclic: Option<Cyclic>,
            end_time: Option<TimeDelay>,
            application_comments: Option<OctetString>,
        ) -> Self {
            Self {
                node_identifier,
                start_time,
                duration,
                cyclic,
                end_time,
                application_comments,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TemporalRelationsSubordinateNodes(
        pub SequenceOf<AnonymousTemporalRelationsSubordinateNodes>,
    );
    #[doc = "  see ITU-T Rec. T.415 | ISO/IEC 8613-5"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set, identifier = "Temporal-Relations")]
    pub struct TemporalRelations {
        #[rasn(tag(context, 0), identifier = "synchronization-type")]
        pub synchronization_type: SynchronizationType,
        #[rasn(tag(context, 1), identifier = "subordinate-nodes")]
        pub subordinate_nodes: TemporalRelationsSubordinateNodes,
    }
    impl TemporalRelations {
        pub fn new(
            synchronization_type: SynchronizationType,
            subordinate_nodes: TemporalRelationsSubordinateNodes,
        ) -> Self {
            Self {
                synchronization_type,
                subordinate_nodes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "Time-Delay")]
    pub struct TimeDelay(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(tag(context, 0), identifier = "Time-Scaling")]
    pub struct TimeScaling {
        pub a: Integer,
        pub b: Integer,
    }
    impl TimeScaling {
        pub fn new(a: Integer, b: Integer) -> Self {
            Self { a, b }
        }
    }
    #[doc = "  The value 'null' is represented by an empty set"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(set, identifier = "Time-Spec")]
    pub struct TimeSpec {
        #[rasn(tag(context, 0), identifier = "start-offset")]
        pub start_offset: Option<Integer>,
        #[rasn(tag(context, 1), identifier = "end-offset")]
        pub end_offset: Option<Integer>,
        #[rasn(tag(context, 2), identifier = "start-separation")]
        pub start_separation: Option<Integer>,
        #[rasn(tag(context, 3), identifier = "end-separation")]
        pub end_separation: Option<Integer>,
    }
    impl TimeSpec {
        pub fn new(
            start_offset: Option<Integer>,
            end_offset: Option<Integer>,
            start_separation: Option<Integer>,
            end_separation: Option<Integer>,
        ) -> Self {
            Self {
                start_offset,
                end_offset,
                start_separation,
                end_separation,
            }
        }
    }
}
