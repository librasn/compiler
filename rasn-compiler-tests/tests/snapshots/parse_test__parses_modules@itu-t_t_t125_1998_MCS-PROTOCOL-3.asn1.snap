---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_t_t125_1998_MCS-PROTOCOL-3.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod mcs_protocol_3 {
    extern crate alloc;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " created by Channel-Convene"]
    #[doc = " deleted by Channel-Disband"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AssignedChannelId(pub DynamicChannelId);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AttachUserConfirm {
        pub result: Result,
        pub initiator: Option<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl AttachUserConfirm {
        pub fn new(
            result: Result,
            initiator: Option<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                result,
                initiator,
                non_standard,
            }
        }
    }
    #[doc = " Part 5:  Attach/Detach user"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AttachUserRequest {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl AttachUserRequest {
        pub fn new(non_standard: Option<SequenceOf<NonStandardParameter>>) -> Self {
            Self { non_standard }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CapabilitiesNotificationIndication {
        #[rasn(identifier = "v2NodePresent")]
        pub v2_node_present: bool,
        #[rasn(identifier = "addList")]
        pub add_list: Option<SeqOfIndicationCapabilities>,
        #[rasn(identifier = "removeList")]
        pub remove_list: Option<SeqOfIndicationCapabilities>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl CapabilitiesNotificationIndication {
        pub fn new(
            v2_node_present: bool,
            add_list: Option<SeqOfIndicationCapabilities>,
            remove_list: Option<SeqOfIndicationCapabilities>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                v2_node_present,
                add_list,
                remove_list,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CapabilitiesNotificationRequest {
        #[rasn(identifier = "v2NodePresent")]
        pub v2_node_present: bool,
        #[rasn(identifier = "addList")]
        pub add_list: Option<SeqOfRequestCapabilities>,
        #[rasn(identifier = "removeList")]
        pub remove_list: Option<SeqOfRequestCapabilities>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl CapabilitiesNotificationRequest {
        pub fn new(
            v2_node_present: bool,
            add_list: Option<SeqOfRequestCapabilities>,
            remove_list: Option<SeqOfRequestCapabilities>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                v2_node_present,
                add_list,
                remove_list,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum CapabilityClass {
        null(()),
        #[rasn(value("0.."))]
        unsignedMin(Integer),
        #[rasn(value("0.."))]
        unsignedMax(Integer),
    }
    #[doc = " Part 9:  Capabilities notification"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum CapabilityID {
        #[rasn(value("0..=65535"))]
        standardID(u16),
        nonstandardID(Key),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelAdmitIndication {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: PrivateChannelId,
        #[rasn(identifier = "userIds")]
        pub user_ids: SetOf<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelAdmitIndication {
        pub fn new(
            initiator: UserId,
            channel_id: PrivateChannelId,
            user_ids: SetOf<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                user_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelAdmitRequest {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: PrivateChannelId,
        #[rasn(identifier = "userIds")]
        pub user_ids: SetOf<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelAdmitRequest {
        pub fn new(
            initiator: UserId,
            channel_id: PrivateChannelId,
            user_ids: SetOf<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                user_ids,
                non_standard,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelAttributesStatic {
        #[rasn(identifier = "channelId")]
        pub channel_id: StaticChannelId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelAttributesStatic {
        pub fn new(
            channel_id: StaticChannelId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                channel_id,
                non_standard,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelAttributesUserId {
        pub joined: bool,
        #[rasn(identifier = "userId")]
        pub user_id: UserId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelAttributesUserId {
        pub fn new(
            joined: bool,
            user_id: UserId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                joined,
                user_id,
                non_standard,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelAttributesPrivate {
        pub joined: bool,
        #[rasn(identifier = "channelId")]
        pub channel_id: PrivateChannelId,
        pub manager: UserId,
        pub admitted: SetOf<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelAttributesPrivate {
        pub fn new(
            joined: bool,
            channel_id: PrivateChannelId,
            manager: UserId,
            admitted: SetOf<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                joined,
                channel_id,
                manager,
                admitted,
                non_standard,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelAttributesAssigned {
        #[rasn(identifier = "channelId")]
        pub channel_id: AssignedChannelId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelAttributesAssigned {
        pub fn new(
            channel_id: AssignedChannelId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                channel_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ChannelAttributes {
        #[rasn(identifier = "static")]
        R_static(ChannelAttributesStatic),
        userId(ChannelAttributesUserId),
        private(ChannelAttributesPrivate),
        assigned(ChannelAttributesAssigned),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelConveneConfirm {
        pub result: Result,
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: Option<PrivateChannelId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelConveneConfirm {
        pub fn new(
            result: Result,
            initiator: UserId,
            channel_id: Option<PrivateChannelId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                result,
                initiator,
                channel_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelConveneRequest {
        pub initiator: UserId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelConveneRequest {
        pub fn new(
            initiator: UserId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelDisbandIndication {
        #[rasn(identifier = "channelId")]
        pub channel_id: PrivateChannelId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelDisbandIndication {
        pub fn new(
            channel_id: PrivateChannelId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                channel_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelDisbandRequest {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: PrivateChannelId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelDisbandRequest {
        pub fn new(
            initiator: UserId,
            channel_id: PrivateChannelId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelExpelIndication {
        #[rasn(identifier = "channelId")]
        pub channel_id: PrivateChannelId,
        #[rasn(identifier = "userIds")]
        pub user_ids: SetOf<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelExpelIndication {
        pub fn new(
            channel_id: PrivateChannelId,
            user_ids: SetOf<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                channel_id,
                user_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelExpelRequest {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: PrivateChannelId,
        #[rasn(identifier = "userIds")]
        pub user_ids: SetOf<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelExpelRequest {
        pub fn new(
            initiator: UserId,
            channel_id: PrivateChannelId,
            user_ids: SetOf<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                user_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=65535"))]
    pub struct ChannelId(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelJoinConfirm {
        pub result: Result,
        pub initiator: UserId,
        pub requested: ChannelId,
        #[rasn(identifier = "channelId")]
        pub channel_id: Option<ChannelId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelJoinConfirm {
        pub fn new(
            result: Result,
            initiator: UserId,
            requested: ChannelId,
            channel_id: Option<ChannelId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                result,
                initiator,
                requested,
                channel_id,
                non_standard,
            }
        }
    }
    #[doc = " Part 6:  Channel management"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelJoinRequest {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: ChannelId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelJoinRequest {
        pub fn new(
            initiator: UserId,
            channel_id: ChannelId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ChannelLeaveRequest {
        #[rasn(identifier = "channelIds")]
        pub channel_ids: SetOf<ChannelId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ChannelLeaveRequest {
        pub fn new(
            channel_ids: SetOf<ChannelId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                channel_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DataPriority {
        top(()),
        high(()),
        medium(()),
        low(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DetachUserIndication {
        pub reason: Reason,
        #[rasn(identifier = "userIds")]
        pub user_ids: SetOf<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl DetachUserIndication {
        pub fn new(
            reason: Reason,
            user_ids: SetOf<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                reason,
                user_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DetachUserRequest {
        pub reason: Reason,
        #[rasn(identifier = "userIds")]
        pub user_ids: SetOf<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl DetachUserRequest {
        pub fn new(
            reason: Reason,
            user_ids: SetOf<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                reason,
                user_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum Diagnostic {
        #[rasn(identifier = "dc-inconsistent-merge")]
        dc_inconsistent_merge(()),
        #[rasn(identifier = "dc-forbidden-PDU-downward")]
        dc_forbidden_PDU_downward(()),
        #[rasn(identifier = "dc-forbidden-PDU-upward")]
        dc_forbidden_PDU_upward(()),
        #[rasn(identifier = "dc-invalid-BER-encoding")]
        dc_invalid_BER_encoding(()),
        #[rasn(identifier = "dc-invalid-PER-encoding")]
        dc_invalid_PER_encoding(()),
        #[rasn(identifier = "dc-misrouted-user")]
        dc_misrouted_user(()),
        #[rasn(identifier = "dc-unrequested-confirm")]
        dc_unrequested_confirm(()),
        #[rasn(identifier = "dc-wrong-transport-priority")]
        dc_wrong_transport_priority(()),
        #[rasn(identifier = "dc-channel-id-conflict")]
        dc_channel_id_conflict(()),
        #[rasn(identifier = "dc-token-id-conflict")]
        dc_token_id_conflict(()),
        #[rasn(identifier = "dc-not-user-id-channel")]
        dc_not_user_id_channel(()),
        #[rasn(identifier = "dc-too-many-channels")]
        dc_too_many_channels(()),
        #[rasn(identifier = "dc-too-many-tokens")]
        dc_too_many_tokens(()),
        #[rasn(identifier = "dc-too-many-users")]
        dc_too_many_users(()),
    }
    #[doc = " Part 4:  Disconnect provider"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DisconnectProviderUltimatum {
        pub reason: Reason,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl DisconnectProviderUltimatum {
        pub fn new(reason: Reason, non_standard: Option<SequenceOf<NonStandardParameter>>) -> Self {
            Self {
                reason,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DomainMCSPDU {
        plumbDomainIndication(PlumbDomainIndication),
        erectDomainRequest(ErectDomainRequest),
        mergeChannelsRequest(MergeChannelsRequest),
        mergeChannelsConfirm(MergeChannelsConfirm),
        purgeChannelsIndication(PurgeChannelsIndication),
        mergeTokensRequest(MergeTokensRequest),
        mergeTokensConfirm(MergeTokensConfirm),
        purgeTokensIndication(PurgeTokensIndication),
        disconnectProviderUltimatum(DisconnectProviderUltimatum),
        rejectMCSPDUUltimatum(RejectMCSPDUUltimatum),
        attachUserRequest(AttachUserRequest),
        attachUserConfirm(AttachUserConfirm),
        detachUserRequest(DetachUserRequest),
        detachUserIndication(DetachUserIndication),
        channelJoinRequest(ChannelJoinRequest),
        channelJoinConfirm(ChannelJoinConfirm),
        channelLeaveRequest(ChannelLeaveRequest),
        channelConveneRequest(ChannelConveneRequest),
        channelConveneConfirm(ChannelConveneConfirm),
        channelDisbandRequest(ChannelDisbandRequest),
        channelDisbandIndication(ChannelDisbandIndication),
        channelAdmitRequest(ChannelAdmitRequest),
        channelAdmitIndication(ChannelAdmitIndication),
        channelExpelRequest(ChannelExpelRequest),
        channelExpelIndication(ChannelExpelIndication),
        sendDataRequest(SendDataRequest),
        sendDataIndication(SendDataIndication),
        uniformSendDataRequest(UniformSendDataRequest),
        uniformSendDataIndication(UniformSendDataIndication),
        tokenGrabRequest(TokenGrabRequest),
        tokenGrabConfirm(TokenGrabConfirm),
        tokenInhibitRequest(TokenInhibitRequest),
        tokenInhibitConfirm(TokenInhibitConfirm),
        tokenGiveRequest(TokenGiveRequest),
        tokenGiveIndication(TokenGiveIndication),
        tokenGiveResponse(TokenGiveResponse),
        tokenGiveConfirm(TokenGiveConfirm),
        tokenPleaseRequest(TokenPleaseRequest),
        tokenPleaseIndication(TokenPleaseIndication),
        tokenReleaseRequest(TokenReleaseRequest),
        tokenReleaseConfirm(TokenReleaseConfirm),
        tokenTestRequest(TokenTestRequest),
        tokenTestConfirm(TokenTestConfirm),
        nonStandard(NonStandardPDU),
    }
    #[doc = " those known permanently"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1001..=65535"))]
    pub struct DynamicChannelId(pub ChannelId);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ErectDomainRequest {
        #[rasn(value("0.."), identifier = "subHeight")]
        pub sub_height: Integer,
        #[rasn(value("0.."), identifier = "subInterval")]
        pub sub_interval: Integer,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ErectDomainRequest {
        pub fn new(
            sub_height: Integer,
            sub_interval: Integer,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                sub_height,
                sub_interval,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ExtendedParameterAccept {
        #[rasn(identifier = "extendedParameters")]
        pub extended_parameters: ExtendedParameters,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ExtendedParameterAccept {
        pub fn new(
            extended_parameters: ExtendedParameters,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                extended_parameters,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ExtendedParameterMCSPDU {
        extendedParameterPropose(ExtendedParameterPropose),
        extendedParameterAccept(ExtendedParameterAccept),
        nonStandard(NonStandardPDU),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ExtendedParameterPropose {
        #[rasn(identifier = "targetExtendedParameters")]
        pub target_extended_parameters: ExtendedParameters,
        #[rasn(identifier = "minimumExtendedParameters")]
        pub minimum_extended_parameters: ExtendedParameters,
        #[rasn(identifier = "maximumExtendedParameters")]
        pub maximum_extended_parameters: ExtendedParameters,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ExtendedParameterPropose {
        pub fn new(
            target_extended_parameters: ExtendedParameters,
            minimum_extended_parameters: ExtendedParameters,
            maximum_extended_parameters: ExtendedParameters,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                target_extended_parameters,
                minimum_extended_parameters,
                maximum_extended_parameters,
                non_standard,
            }
        }
    }
    #[doc = " Part 2:  Extended parameter"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ExtendedParameters {
        #[rasn(identifier = "unreliableDataSupported")]
        pub unreliable_data_supported: bool,
        #[rasn(value("0..=65535"), identifier = "domainReferenceID")]
        pub domain_reference_id: u16,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl ExtendedParameters {
        pub fn new(
            unreliable_data_supported: bool,
            domain_reference_id: u16,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                unreliable_data_supported,
                domain_reference_id,
                non_standard,
            }
        }
    }
    #[doc = " Part 1:  Fundamental MCS types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("4..=255"))]
    pub struct H221NonStandardIdentifier(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct IndicationCapability {
        #[rasn(identifier = "capabilityID")]
        pub capability_id: CapabilityID,
        #[rasn(identifier = "capabilityClass")]
        pub capability_class: CapabilityClass,
        #[rasn(identifier = "summitProviderSupported")]
        pub summit_provider_supported: bool,
        #[rasn(identifier = "intermediateNodeSupported")]
        pub intermediate_node_supported: bool,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl IndicationCapability {
        pub fn new(
            capability_id: CapabilityID,
            capability_class: CapabilityClass,
            summit_provider_supported: bool,
            intermediate_node_supported: bool,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                capability_id,
                capability_class,
                summit_provider_supported,
                intermediate_node_supported,
                non_standard,
            }
        }
    }
    #[doc = " First four octets shall be country"]
    #[doc = " code and Manufacturer code, assigned"]
    #[doc = " as specified in Annex A/H.221 for"]
    #[doc = " NS-cap and NS-comm"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum Key {
        object(ObjectIdentifier),
        h221NonStandard(H221NonStandardIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MergeChannelsConfirm {
        #[rasn(identifier = "mergeChannels")]
        pub merge_channels: SetOf<ChannelAttributes>,
        #[rasn(identifier = "purgeChannelIds")]
        pub purge_channel_ids: SetOf<ChannelId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl MergeChannelsConfirm {
        pub fn new(
            merge_channels: SetOf<ChannelAttributes>,
            purge_channel_ids: SetOf<ChannelId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                merge_channels,
                purge_channel_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MergeChannelsRequest {
        #[rasn(identifier = "mergeChannels")]
        pub merge_channels: SetOf<ChannelAttributes>,
        #[rasn(identifier = "purgeChannelIds")]
        pub purge_channel_ids: SetOf<ChannelId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl MergeChannelsRequest {
        pub fn new(
            merge_channels: SetOf<ChannelAttributes>,
            purge_channel_ids: SetOf<ChannelId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                merge_channels,
                purge_channel_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MergeTokensConfirm {
        #[rasn(identifier = "mergeTokens")]
        pub merge_tokens: SetOf<TokenAttributes>,
        #[rasn(identifier = "purgeTokenIds")]
        pub purge_token_ids: SetOf<TokenId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl MergeTokensConfirm {
        pub fn new(
            merge_tokens: SetOf<TokenAttributes>,
            purge_token_ids: SetOf<TokenId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                merge_tokens,
                purge_token_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MergeTokensRequest {
        #[rasn(identifier = "mergeTokens")]
        pub merge_tokens: SetOf<TokenAttributes>,
        #[rasn(identifier = "purgeTokenIds")]
        pub purge_token_ids: SetOf<TokenId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl MergeTokensRequest {
        pub fn new(
            merge_tokens: SetOf<TokenAttributes>,
            purge_token_ids: SetOf<TokenId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                merge_tokens,
                purge_token_ids,
                non_standard,
            }
        }
    }
    #[doc = " Part 11:  MCSPDU repertoire"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NonStandardPDU {
        pub data: NonStandardParameter,
    }
    impl NonStandardPDU {
        pub fn new(data: NonStandardParameter) -> Self {
            Self { data }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct NonStandardParameter {
        pub key: Key,
        pub data: OctetString,
    }
    impl NonStandardParameter {
        pub fn new(key: Key, data: OctetString) -> Self {
            Self { key, data }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum ParticipationIndicator {
        global(()),
        #[rasn(value("1..=2"))]
        partial(u8),
    }
    #[doc = " Part 3:  Merge domain"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct PlumbDomainIndication {
        #[rasn(value("0.."), identifier = "heightLimit")]
        pub height_limit: Integer,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl PlumbDomainIndication {
        pub fn new(
            height_limit: Integer,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                height_limit,
                non_standard,
            }
        }
    }
    #[doc = " created by Attach-User"]
    #[doc = " deleted by Detach-User"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PrivateChannelId(pub DynamicChannelId);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct PurgeChannelsIndication {
        #[rasn(identifier = "detachChannelIds")]
        pub detach_channel_ids: SetOf<ChannelId>,
        #[rasn(identifier = "purgeChannelIds")]
        pub purge_channel_ids: SetOf<ChannelId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl PurgeChannelsIndication {
        pub fn new(
            detach_channel_ids: SetOf<ChannelId>,
            purge_channel_ids: SetOf<ChannelId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                detach_channel_ids,
                purge_channel_ids,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct PurgeTokensIndication {
        #[rasn(identifier = "purgeTokenIds")]
        pub purge_token_ids: SetOf<TokenId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl PurgeTokensIndication {
        pub fn new(
            purge_token_ids: SetOf<TokenId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                purge_token_ids,
                non_standard,
            }
        }
    }
    #[doc = " Part 10:  Status codes"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum Reason {
        #[rasn(identifier = "rn-domain-disconnected")]
        rn_domain_disconnected(()),
        #[rasn(identifier = "rn-provider-initiated")]
        rn_provider_initiated(()),
        #[rasn(identifier = "rn-token-purged")]
        rn_token_purged(()),
        #[rasn(identifier = "rn-user-requested")]
        rn_user_requested(()),
        #[rasn(identifier = "rn-channel-purged")]
        rn_channel_purged(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RejectMCSPDUUltimatum {
        pub diagnostic: Diagnostic,
        #[rasn(identifier = "initialOctets")]
        pub initial_octets: OctetString,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl RejectMCSPDUUltimatum {
        pub fn new(
            diagnostic: Diagnostic,
            initial_octets: OctetString,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                diagnostic,
                initial_octets,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestCapability {
        #[rasn(identifier = "capabilityID")]
        pub capability_id: CapabilityID,
        #[rasn(identifier = "capabilityClass")]
        pub capability_class: CapabilityClass,
        #[rasn(identifier = "participationIndicator")]
        pub participation_indicator: ParticipationIndicator,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl RequestCapability {
        pub fn new(
            capability_id: CapabilityID,
            capability_class: CapabilityClass,
            participation_indicator: ParticipationIndicator,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                capability_id,
                capability_class,
                participation_indicator,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum Result {
        #[rasn(identifier = "rt-successful")]
        rt_successful(()),
        #[rasn(identifier = "rt-domain-merging")]
        rt_domain_merging(()),
        #[rasn(identifier = "rt-domain-not-hierarchical")]
        rt_domain_not_hierarchical(()),
        #[rasn(identifier = "rt-no-such-channel")]
        rt_no_such_channel(()),
        #[rasn(identifier = "rt-no-such-domain")]
        rt_no_such_domain(()),
        #[rasn(identifier = "rt-no-such-user")]
        rt_no_such_user(()),
        #[rasn(identifier = "rt-not-admitted")]
        rt_not_admitted(()),
        #[rasn(identifier = "rt-other-user-id")]
        rt_other_user_id(()),
        #[rasn(identifier = "rt-parameters-unacceptable")]
        rt_parameters_unacceptable(()),
        #[rasn(identifier = "rt-token-not-available")]
        rt_token_not_available(()),
        #[rasn(identifier = "rt-token-not-possessed")]
        rt_token_not_possessed(()),
        #[rasn(identifier = "rt-too-many-channels")]
        rt_too_many_channels(()),
        #[rasn(identifier = "rt-too-many-tokens")]
        rt_too_many_tokens(()),
        #[rasn(identifier = "rt-too-many-users")]
        rt_too_many_users(()),
        #[rasn(identifier = "rt-unspecified-failure")]
        rt_unspecified_failure(()),
        #[rasn(identifier = "rt-user-rejected")]
        rt_user_rejected(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Segmentation(pub FixedBitString<2usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SendDataIndication {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: ChannelId,
        pub reliability: bool,
        #[rasn(value("0..=65535"), identifier = "domainReferenceID")]
        pub domain_reference_id: Option<u16>,
        #[rasn(identifier = "dataPriority")]
        pub data_priority: DataPriority,
        pub segmentation: Segmentation,
        #[rasn(identifier = "userData")]
        pub user_data: OctetString,
        #[rasn(identifier = "totalDataSize")]
        pub total_data_size: Option<Integer>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl SendDataIndication {
        pub fn new(
            initiator: UserId,
            channel_id: ChannelId,
            reliability: bool,
            domain_reference_id: Option<u16>,
            data_priority: DataPriority,
            segmentation: Segmentation,
            user_data: OctetString,
            total_data_size: Option<Integer>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                reliability,
                domain_reference_id,
                data_priority,
                segmentation,
                user_data,
                total_data_size,
                non_standard,
            }
        }
    }
    #[doc = " Part 7:  Data transfer"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SendDataRequest {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: ChannelId,
        pub reliability: bool,
        #[rasn(value("0..=65535"), identifier = "domainReferenceID")]
        pub domain_reference_id: Option<u16>,
        #[rasn(identifier = "dataPriority")]
        pub data_priority: DataPriority,
        pub segmentation: Segmentation,
        #[rasn(identifier = "userData")]
        pub user_data: OctetString,
        #[rasn(identifier = "totalDataSize")]
        pub total_data_size: Option<Integer>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl SendDataRequest {
        pub fn new(
            initiator: UserId,
            channel_id: ChannelId,
            reliability: bool,
            domain_reference_id: Option<u16>,
            data_priority: DataPriority,
            segmentation: Segmentation,
            user_data: OctetString,
            total_data_size: Option<Integer>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                reliability,
                domain_reference_id,
                data_priority,
                segmentation,
                user_data,
                total_data_size,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SeqOfIndicationCapabilities(pub SequenceOf<IndicationCapability>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SeqOfRequestCapabilities(pub SequenceOf<RequestCapability>);
    #[doc = " range is 16 bits"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=1000"))]
    pub struct StaticChannelId(pub ChannelId);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenAttributesGrabbed {
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        pub grabber: UserId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenAttributesGrabbed {
        pub fn new(
            token_id: TokenId,
            grabber: UserId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                token_id,
                grabber,
                non_standard,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenAttributesInhibited {
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        pub inhibitors: SetOf<UserId>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenAttributesInhibited {
        pub fn new(
            token_id: TokenId,
            inhibitors: SetOf<UserId>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                token_id,
                inhibitors,
                non_standard,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenAttributesGiving {
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        pub grabber: UserId,
        pub recipient: UserId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenAttributesGiving {
        pub fn new(
            token_id: TokenId,
            grabber: UserId,
            recipient: UserId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                token_id,
                grabber,
                recipient,
                non_standard,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenAttributesUngivable {
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        pub grabber: UserId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenAttributesUngivable {
        pub fn new(
            token_id: TokenId,
            grabber: UserId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                token_id,
                grabber,
                non_standard,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenAttributesGiven {
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        pub recipient: UserId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenAttributesGiven {
        pub fn new(
            token_id: TokenId,
            recipient: UserId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                token_id,
                recipient,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TokenAttributes {
        grabbed(TokenAttributesGrabbed),
        inhibited(TokenAttributesInhibited),
        giving(TokenAttributesGiving),
        ungivable(TokenAttributesUngivable),
        given(TokenAttributesGiven),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenGiveConfirm {
        pub result: Result,
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "tokenStatus")]
        pub token_status: TokenStatus,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenGiveConfirm {
        pub fn new(
            result: Result,
            initiator: UserId,
            token_id: TokenId,
            token_status: TokenStatus,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                result,
                initiator,
                token_id,
                token_status,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenGiveIndication {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        pub recipient: UserId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenGiveIndication {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            recipient: UserId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                recipient,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenGiveRequest {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        pub recipient: UserId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenGiveRequest {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            recipient: UserId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                recipient,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenGiveResponse {
        pub result: Result,
        pub recipient: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenGiveResponse {
        pub fn new(
            result: Result,
            recipient: UserId,
            token_id: TokenId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                result,
                recipient,
                token_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenGrabConfirm {
        pub result: Result,
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "tokenStatus")]
        pub token_status: TokenStatus,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenGrabConfirm {
        pub fn new(
            result: Result,
            initiator: UserId,
            token_id: TokenId,
            token_status: TokenStatus,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                result,
                initiator,
                token_id,
                token_status,
                non_standard,
            }
        }
    }
    #[doc = " Part 8:  Token management"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenGrabRequest {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenGrabRequest {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                non_standard,
            }
        }
    }
    #[doc = " created by Channel-Join zero"]
    #[doc = " deleted by last Channel-Leave"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=65535"))]
    pub struct TokenId(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenInhibitConfirm {
        pub result: Result,
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "tokenStatus")]
        pub token_status: TokenStatus,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenInhibitConfirm {
        pub fn new(
            result: Result,
            initiator: UserId,
            token_id: TokenId,
            token_status: TokenStatus,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                result,
                initiator,
                token_id,
                token_status,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenInhibitRequest {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenInhibitRequest {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenPleaseIndication {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenPleaseIndication {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenPleaseRequest {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenPleaseRequest {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenReleaseConfirm {
        pub result: Result,
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "tokenStatus")]
        pub token_status: TokenStatus,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenReleaseConfirm {
        pub fn new(
            result: Result,
            initiator: UserId,
            token_id: TokenId,
            token_status: TokenStatus,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                result,
                initiator,
                token_id,
                token_status,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenReleaseRequest {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenReleaseRequest {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                non_standard,
            }
        }
    }
    #[doc = " all are known permanently"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TokenStatus {
        notInUse(()),
        selfGrabbed(()),
        otherGrabbed(()),
        selfInhibited(()),
        otherInhibited(()),
        selfRecipient(()),
        selfGiving(()),
        otherGiving(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenTestConfirm {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "tokenStatus")]
        pub token_status: TokenStatus,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenTestConfirm {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            token_status: TokenStatus,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                token_status,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TokenTestRequest {
        pub initiator: UserId,
        #[rasn(identifier = "tokenId")]
        pub token_id: TokenId,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl TokenTestRequest {
        pub fn new(
            initiator: UserId,
            token_id: TokenId,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                token_id,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UniformSendDataIndication {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: ChannelId,
        pub reliability: bool,
        #[rasn(value("0..=65535"), identifier = "domainReferenceID")]
        pub domain_reference_id: Option<u16>,
        #[rasn(identifier = "dataPriority")]
        pub data_priority: DataPriority,
        pub segmentation: Segmentation,
        #[rasn(identifier = "userData")]
        pub user_data: OctetString,
        #[rasn(identifier = "totalDataSize")]
        pub total_data_size: Option<Integer>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl UniformSendDataIndication {
        pub fn new(
            initiator: UserId,
            channel_id: ChannelId,
            reliability: bool,
            domain_reference_id: Option<u16>,
            data_priority: DataPriority,
            segmentation: Segmentation,
            user_data: OctetString,
            total_data_size: Option<Integer>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                reliability,
                domain_reference_id,
                data_priority,
                segmentation,
                user_data,
                total_data_size,
                non_standard,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UniformSendDataRequest {
        pub initiator: UserId,
        #[rasn(identifier = "channelId")]
        pub channel_id: ChannelId,
        pub reliability: bool,
        #[rasn(value("0..=65535"), identifier = "domainReferenceID")]
        pub domain_reference_id: Option<u16>,
        #[rasn(identifier = "dataPriority")]
        pub data_priority: DataPriority,
        pub segmentation: Segmentation,
        #[rasn(identifier = "userData")]
        pub user_data: OctetString,
        #[rasn(identifier = "totalDataSize")]
        pub total_data_size: Option<Integer>,
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
    }
    impl UniformSendDataRequest {
        pub fn new(
            initiator: UserId,
            channel_id: ChannelId,
            reliability: bool,
            domain_reference_id: Option<u16>,
            data_priority: DataPriority,
            segmentation: Segmentation,
            user_data: OctetString,
            total_data_size: Option<Integer>,
            non_standard: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                initiator,
                channel_id,
                reliability,
                domain_reference_id,
                data_priority,
                segmentation,
                user_data,
                total_data_size,
                non_standard,
            }
        }
    }
    #[doc = " those created and deleted"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct UserId(pub DynamicChannelId);
}
