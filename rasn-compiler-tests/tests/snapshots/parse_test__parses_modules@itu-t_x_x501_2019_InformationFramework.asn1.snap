---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x501_2019_InformationFramework.asn1
---
Warnings:
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
SyntaxMismatch in ASN grammar: Syntax mismatch while resolving information object.
SyntaxMismatch in ASN grammar: Syntax mismatch while resolving information object.
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!
NotYetInplemented in ASN grammar: Not yet implemented!


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod information_framework {
    extern crate alloc;
    use super::directory_abstract_service::TypeAndContextAssertion;
    use super::selected_attribute_types::{
        UnboundedDirectoryString, BOOLEAN_MATCH, COMMON_NAME, DN, GENERALIZED_TIME,
        GENERALIZED_TIME_MATCH, GENERALIZED_TIME_ORDERING_MATCH, INTEGER_FIRST_COMPONENT_MATCH,
        INTEGER_MATCH, INTEGER_ORDERING_MATCH, OBJECT_IDENTIFIER_FIRST_COMPONENT_MATCH, OID,
        SUBTREE_SPEC,
    };
    use super::service_administration::SearchRule;
    use super::useful_definitions::{ID_AR, ID_AT, ID_MR, ID_NF, ID_OA, ID_OC, ID_SC};
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeType(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct AttributeTypeAndValue {
        #[rasn(identifier = "type")]
        pub r_type: ObjectIdentifier,
        pub value: Any,
    }
    impl AttributeTypeAndValue {
        pub fn new(r_type: ObjectIdentifier, value: Any) -> Self {
            Self { r_type, value }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct AttributeTypeAssertion {
        #[rasn(identifier = "type")]
        pub r_type: ObjectIdentifier,
        #[rasn(size("1.."), identifier = "assertedContexts")]
        pub asserted_contexts: Option<SequenceOf<ContextAssertion>>,
    }
    impl AttributeTypeAssertion {
        pub fn new(
            r_type: ObjectIdentifier,
            asserted_contexts: Option<SequenceOf<ContextAssertion>>,
        ) -> Self {
            Self {
                r_type,
                asserted_contexts,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    #[non_exhaustive]
    pub enum AttributeUsage {
        userApplications = 0,
        directoryOperation = 1,
        distributedOperation = 2,
        dSAOperation = 3,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeValue(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AttributeValueAssertionAssertedContexts {
        #[rasn(tag(context, 0))]
        allContexts(()),
        #[rasn(size("1.."), tag(context, 1))]
        selectedContexts(SetOf<ContextAssertion>),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct AttributeValueAssertion {
        #[rasn(identifier = "type")]
        pub r_type: ObjectIdentifier,
        pub assertion: Any,
        #[rasn(identifier = "assertedContexts")]
        pub asserted_contexts: Option<AttributeValueAssertionAssertedContexts>,
    }
    impl AttributeValueAssertion {
        pub fn new(
            r_type: ObjectIdentifier,
            assertion: Any,
            asserted_contexts: Option<AttributeValueAssertionAssertedContexts>,
        ) -> Self {
            Self {
                r_type,
                assertion,
                asserted_contexts,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0.."))]
    pub struct BaseDistance(pub Integer);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    #[non_exhaustive]
    pub enum AnonymousChopSpecificationSpecificExclusions {
        #[rasn(tag(context, 0))]
        chopBefore(LocalName),
        #[rasn(tag(context, 1))]
        chopAfter(LocalName),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct ChopSpecificationSpecificExclusions(
        pub SetOf<AnonymousChopSpecificationSpecificExclusions>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct ChopSpecification {
        #[rasn(tag(context, 1), identifier = "specificExclusions")]
        pub specific_exclusions: Option<ChopSpecificationSpecificExclusions>,
        #[rasn(tag(context, 2), default = "chop_specification_minimum_default")]
        pub minimum: BaseDistance,
        #[rasn(tag(context, 3))]
        pub maximum: Option<BaseDistance>,
    }
    impl ChopSpecification {
        pub fn new(
            specific_exclusions: Option<ChopSpecificationSpecificExclusions>,
            minimum: BaseDistance,
            maximum: Option<BaseDistance>,
        ) -> Self {
            Self {
                specific_exclusions,
                minimum,
                maximum,
            }
        }
    }
    fn chop_specification_minimum_default() -> BaseDistance {
        BaseDistance(Integer::from(0i128))
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$CONTEXT$&Type")]
    pub struct AnonymousContextContextValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct ContextContextValues(pub SetOf<AnonymousContextContextValues>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct Context {
        #[rasn(identifier = "contextType")]
        pub context_type: ObjectIdentifier,
        #[rasn(identifier = "contextValues")]
        pub context_values: ContextContextValues,
        #[rasn(default = "context_fallback_default")]
        pub fallback: bool,
    }
    impl Context {
        pub fn new(
            context_type: ObjectIdentifier,
            context_values: ContextContextValues,
            fallback: bool,
        ) -> Self {
            Self {
                context_type,
                context_values,
                fallback,
            }
        }
    }
    fn context_fallback_default() -> bool {
        false
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "IOFR$CONTEXT$&Assertion")]
    pub struct AnonymousContextAssertionContextValues(pub Any);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct ContextAssertionContextValues(pub SetOf<AnonymousContextAssertionContextValues>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct ContextAssertion {
        #[rasn(identifier = "contextType")]
        pub context_type: ObjectIdentifier,
        #[rasn(identifier = "contextValues")]
        pub context_values: ContextAssertionContextValues,
    }
    impl ContextAssertion {
        pub fn new(
            context_type: ObjectIdentifier,
            context_values: ContextAssertionContextValues,
        ) -> Self {
            Self {
                context_type,
                context_values,
            }
        }
    }
    #[doc = " DIT content rule data type and CONTENT-RULE class"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct DITContentRule {
        #[rasn(identifier = "structuralObjectClass")]
        pub structural_object_class: ObjectIdentifier,
        #[rasn(size("1.."))]
        pub auxiliaries: Option<SetOf<Any>>,
        #[rasn(size("1.."), tag(context, 1))]
        pub mandatory: Option<SetOf<Any>>,
        #[rasn(size("1.."), tag(context, 2))]
        pub optional: Option<SetOf<Any>>,
        #[rasn(size("1.."), tag(context, 3))]
        pub precluded: Option<SetOf<Any>>,
    }
    impl DITContentRule {
        pub fn new(
            structural_object_class: ObjectIdentifier,
            auxiliaries: Option<SetOf<Any>>,
            mandatory: Option<SetOf<Any>>,
            optional: Option<SetOf<Any>>,
            precluded: Option<SetOf<Any>>,
        ) -> Self {
            Self {
                structural_object_class,
                auxiliaries,
                mandatory,
                optional,
                precluded,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct DITContextUse {
        #[rasn(identifier = "attributeType")]
        pub attribute_type: ObjectIdentifier,
        #[rasn(size("1.."), tag(context, 1), identifier = "mandatoryContexts")]
        pub mandatory_contexts: Option<SetOf<Any>>,
        #[rasn(size("1.."), tag(context, 2), identifier = "optionalContexts")]
        pub optional_contexts: Option<SetOf<Any>>,
    }
    impl DITContextUse {
        pub fn new(
            attribute_type: ObjectIdentifier,
            mandatory_contexts: Option<SetOf<Any>>,
            optional_contexts: Option<SetOf<Any>>,
        ) -> Self {
            Self {
                attribute_type,
                mandatory_contexts,
                optional_contexts,
            }
        }
    }
    #[doc = " STRUCTURE-RULE class and DIT structure rule data types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct DITStructureRule {
        #[rasn(identifier = "ruleIdentifier")]
        pub rule_identifier: RuleIdentifier,
        #[rasn(identifier = "nameForm")]
        pub name_form: ObjectIdentifier,
        #[rasn(size("1.."), identifier = "superiorStructureRules")]
        pub superior_structure_rules: Option<SetOf<RuleIdentifier>>,
    }
    impl DITStructureRule {
        pub fn new(
            rule_identifier: RuleIdentifier,
            name_form: ObjectIdentifier,
            superior_structure_rules: Option<SetOf<RuleIdentifier>>,
        ) -> Self {
            Self {
                rule_identifier,
                name_form,
                superior_structure_rules,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DistinguishedName(pub RDNSequence);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct HierarchyBelow(pub bool);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct HierarchyLevel(pub Integer);
    #[doc = " empty sequence specifies whole administrative area"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct LocalName(pub RDNSequence);
    #[doc = " naming data types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Name {
        rdnSequence(RDNSequence),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ObjectClassKind {
        #[rasn(identifier = "abstract")]
        R_abstract = 0,
        structural = 1,
        auxiliary = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RDNSequence(pub SequenceOf<RelativeDistinguishedName>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    #[non_exhaustive]
    pub enum Refinement {
        #[rasn(tag(context, 0))]
        item(ObjectIdentifier),
        #[rasn(size("1.."), tag(context, 1))]
        and(SetOf<Refinement>),
        #[rasn(size("1.."), tag(context, 2))]
        or(SetOf<Refinement>),
        #[rasn(tag(context, 3))]
        not(Box<Refinement>),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct RelativeDistinguishedName(pub SetOf<AttributeTypeAndValue>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RuleIdentifier(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct SearchRuleDescription {
        #[rasn(size("1.."), tag(context, 28))]
        pub name: Option<SetOf<UnboundedDirectoryString>>,
        #[rasn(tag(context, 29))]
        pub description: Option<UnboundedDirectoryString>,
    }
    impl SearchRuleDescription {
        pub fn new(
            name: Option<SetOf<UnboundedDirectoryString>>,
            description: Option<UnboundedDirectoryString>,
        ) -> Self {
            Self { name, description }
        }
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, identifier = "CHOICE")]
    #[non_exhaustive]
    pub enum AnonymousSubtreeSpecificationSpecificExclusions {
        #[rasn(tag(context, 0))]
        chopBefore(LocalName),
        #[rasn(tag(context, 1))]
        chopAfter(LocalName),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct SubtreeSpecificationSpecificExclusions(
        pub SetOf<AnonymousSubtreeSpecificationSpecificExclusions>,
    );
    #[doc = " subtree data types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct SubtreeSpecification {
        #[rasn(tag(context, 0), default = "subtree_specification_base_default")]
        pub base: LocalName,
        #[rasn(tag(context, 4), identifier = "specificationFilter")]
        pub specification_filter: Option<Refinement>,
        #[rasn(tag(context, 1), identifier = "specificExclusions")]
        pub specific_exclusions: Option<SubtreeSpecificationSpecificExclusions>,
        #[rasn(tag(context, 2), default = "subtree_specification_minimum_default")]
        pub minimum: BaseDistance,
        #[rasn(tag(context, 3))]
        pub maximum: Option<BaseDistance>,
    }
    impl SubtreeSpecification {
        pub fn new(
            base: LocalName,
            specification_filter: Option<Refinement>,
            specific_exclusions: Option<SubtreeSpecificationSpecificExclusions>,
            minimum: BaseDistance,
            maximum: Option<BaseDistance>,
        ) -> Self {
            Self {
                base,
                specification_filter,
                specific_exclusions,
                minimum,
                maximum,
            }
        }
    }
    fn subtree_specification_base_default() -> LocalName {
        LocalName(RDNSequence(alloc::vec![]))
    }
    fn subtree_specification_minimum_default() -> BaseDistance {
        BaseDistance(Integer::from(0i128))
    }
    pub static ID_AR_ACCESS_CONTROL_INNER_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[3u32]].concat()).unwrap().to_owned());
    pub static ID_AR_ACCESS_CONTROL_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[2u32]].concat()).unwrap().to_owned());
    #[doc = " administrative roles"]
    pub static ID_AR_AUTONOMOUS_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_AR_COLLECTIVE_ATTRIBUTE_INNER_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[6u32]].concat()).unwrap().to_owned());
    pub static ID_AR_COLLECTIVE_ATTRIBUTE_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[5u32]].concat()).unwrap().to_owned());
    pub static ID_AR_CONTEXT_DEFAULT_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[7u32]].concat()).unwrap().to_owned());
    pub static ID_AR_PWD_ADMIN_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[9u32]].concat()).unwrap().to_owned());
    pub static ID_AR_SERVICE_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[8u32]].concat()).unwrap().to_owned());
    pub static ID_AR_SUBSCHEMA_ADMIN_SPECIFIC_AREA: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AR, &[4u32]].concat()).unwrap().to_owned());
    pub static ID_AT_ALIASED_ENTRY_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[1u32]].concat()).unwrap().to_owned());
    #[doc = " attributes"]
    pub static ID_AT_OBJECT_CLASS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_AT, &[0u32]].concat()).unwrap().to_owned());
    pub static ID_AT_PWD_ATTRIBUTE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[84u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_DISTINGUISHED_NAME_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[1u32]].concat()).unwrap().to_owned());
    #[doc = " matching rules"]
    pub static ID_MR_OBJECT_IDENTIFIER_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_MR, &[0u32]].concat()).unwrap().to_owned());
    #[doc = "  Name forms"]
    pub static ID_NF_SUBENTRY_NAME_FORM: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_NF, &[16u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_ACCESS_CONTROL_SUBENTRY_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_OA, &[11u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_OA_ADMINISTRATIVE_ROLE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[5u32]].concat()).unwrap().to_owned());
    #[doc = " id-oa-pwdStartTime                  OBJECT IDENTIFIER ::= {id-oa 22} X.520|Part6"]
    #[doc = " id-oa-pwdExpiryTime                 OBJECT IDENTIFIER ::= {id-oa 23} X.520|Part6"]
    #[doc = " id-oa-pwdEndTime                    OBJECT IDENTIFIER ::= {id-oa 24} X.520|Part6"]
    #[doc = " id-oa-pwdFails                      OBJECT IDENTIFIER ::= {id-oa 25} X.520|Part6"]
    #[doc = " id-oa-pwdFailureTime                OBJECT IDENTIFIER ::= {id-oa 26} X.520|Part6"]
    #[doc = " id-oa-pwdGracesUsed                 OBJECT IDENTIFIER ::= {id-oa 27} X.520|Part6"]
    #[doc = " id-oa-userPwdHistory                OBJECT IDENTIFIER ::= {id-oa 28} X.520|Part6"]
    #[doc = " id-oa-userPwdRecentlyExpired        OBJECT IDENTIFIER ::= {id-oa 29} X.520|Part6"]
    #[doc = " id-oa-pwdModifyEntryAllowed         OBJECT IDENTIFIER ::= {id-oa 30} X.520|Part6"]
    #[doc = " id-oa-pwdChangeAllowed              OBJECT IDENTIFIER ::= {id-oa 31} X.520|Part6"]
    #[doc = " id-oa-pwdMaxAge                     OBJECT IDENTIFIER ::= {id-oa 32} X.520|Part6"]
    #[doc = " id-oa-pwdExpiryAge                  OBJECT IDENTIFIER ::= {id-oa 33} X.520|Part6"]
    #[doc = " id-oa-pwdMinLength                  OBJECT IDENTIFIER ::= {id-oa 34} X.520|Part6"]
    #[doc = " id-oa-pwdVocabulary                 OBJECT IDENTIFIER ::= {id-oa 35} X.520|Part6"]
    #[doc = " id-oa-pwdAlphabet                   OBJECT IDENTIFIER ::= {id-oa 36} X.520|Part6"]
    #[doc = " id-oa-pwdDictionaries               OBJECT IDENTIFIER ::= {id-oa 37} X.520|Part6"]
    #[doc = " id-oa-pwdExpiryWarning              OBJECT IDENTIFIER ::= {id-oa 38} X.520|Part6"]
    #[doc = " id-oa-pwdGraces                     OBJECT IDENTIFIER ::= {id-oa 39} X.520|Part6"]
    #[doc = " id-oa-pwdFailureDuration            OBJECT IDENTIFIER ::= {id-oa 40} X.520|Part6"]
    #[doc = " id-oa-pwdLockoutDuration            OBJECT IDENTIFIER ::= {id-oa 41} X.520|Part6"]
    #[doc = " id-oa-pwdMaxFailures                OBJECT IDENTIFIER ::= {id-oa 42} X.520|Part6"]
    #[doc = " id-oa-pwdMaxTimeInHistory           OBJECT IDENTIFIER ::= {id-oa 43} X.520|Part6"]
    #[doc = " id-oa-pwdMinTimeInHistory           OBJECT IDENTIFIER ::= {id-oa 44} X.520|Part6"]
    #[doc = " id-oa-pwdHistorySlots               OBJECT IDENTIFIER ::= {id-oa 45} X.520|Part6"]
    #[doc = " id-oa-pwdRecentlyExpiredDuration    OBJECT IDENTIFIER ::= {id-oa 46} X.520|Part6"]
    #[doc = " id-oa-pwdEncAlg                     OBJECT IDENTIFIER ::= {id-oa 47} X.520|Part6"]
    pub static ID_OA_ALL_ATTRIBUTE_TYPES: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[48u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_COLLECTIVE_ATTRIBUTE_SUBENTRY_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_OA, &[12u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_OA_COLLECTIVE_EXCLUSIONS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[7u32]].concat()).unwrap().to_owned());
    pub static ID_OA_CONTEXT_ASSERTION_DEFAULT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[14u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_CONTEXT_DEFAULT_SUBENTRY_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_OA, &[13u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_OA_CREATE_TIMESTAMP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_OA_CREATORS_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[3u32]].concat()).unwrap().to_owned());
    #[doc = " operational attributes"]
    pub static ID_OA_EXCLUDE_ALL_COLLECTIVE_ATTRIBUTES: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[0u32]].concat()).unwrap().to_owned());
    pub static ID_OA_HAS_SUBORDINATES: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[9u32]].concat()).unwrap().to_owned());
    pub static ID_OA_HIERARCHY_BELOW: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[18u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_HIERARCHY_LEVEL: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[17u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_HIERARCHY_PARENT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[19u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_HIERARCHY_TOP: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[20u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_MODIFIERS_NAME: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[4u32]].concat()).unwrap().to_owned());
    pub static ID_OA_MODIFY_TIMESTAMP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[2u32]].concat()).unwrap().to_owned());
    pub static ID_OA_PWD_ADMIN_SUBENTRY_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[21u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_SEARCH_RULES: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[16u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_SERVICE_ADMIN_SUBENTRY_LIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_OA, &[15u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_OA_SUBSCHEMA_SUBENTRY_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OA, &[10u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OA_SUBSCHEMA_TIMESTAMP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[8u32]].concat()).unwrap().to_owned());
    pub static ID_OA_SUBTREE_SPECIFICATION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OA, &[6u32]].concat()).unwrap().to_owned());
    pub static ID_OC_ALIAS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OC, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_OC_CHILD: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OC, &[29u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_OC_PARENT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_OC, &[28u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " object identifier assignments"]
    #[doc = " object classes"]
    pub static ID_OC_TOP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_OC, &[0u32]].concat()).unwrap().to_owned());
    pub static ID_SC_ACCESS_CONTROL_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[1u32]].concat()).unwrap().to_owned());
    pub static ID_SC_COLLECTIVE_ATTRIBUTE_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[2u32]].concat()).unwrap().to_owned());
    pub static ID_SC_CONTEXT_ASSERTION_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[3u32]].concat()).unwrap().to_owned());
    pub static ID_SC_PWD_ADMIN_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[5u32]].concat()).unwrap().to_owned());
    pub static ID_SC_SERVICE_ADMIN_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[4u32]].concat()).unwrap().to_owned());
    #[doc = " subentry classes"]
    pub static ID_SC_SUBENTRY: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_SC, &[0u32]].concat()).unwrap().to_owned());
}
