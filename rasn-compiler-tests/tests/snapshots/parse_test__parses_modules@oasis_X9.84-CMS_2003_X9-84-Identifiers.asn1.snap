---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/oasis_X9.84-CMS_2003_X9-84-Identifiers.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod x9_84_identifiers {
    extern crate alloc;
    use super::x9_84_biometrics::*;
    use super::x9_84_cms::*;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Any(pub Any);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=65535"))]
    pub struct BirInt16(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct NoIV(pub ());
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OID(pub ObjectIdentifier);
    #[doc = " Alias"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RelOID(pub ObjectIdentifier);
    #[doc = " X9.84 biometric technologies "]
    pub static BIOMETRIC: LazyLock<OID> =
        LazyLock::new(|| OID(Oid::new(&[&***X9_84, &[1u32]].concat()).unwrap().to_owned()));
    pub static BODY_ODOR: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[1u32]).to_owned()));
    pub static CBEFF_OWNER: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***FORMAT_OWNER, &[0u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static CERTIFICATE_EXTENSIONS: LazyLock<OID> =
        LazyLock::new(|| OID(Oid::new(&[&***X9_84, &[5u32]].concat()).unwrap().to_owned()));
    #[doc = " ANS X9.52 Triple DES Modes of Operation "]
    pub static DES_EDE3_CBC: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[1u32, 2u32, 840u32, 113549u32, 3u32, 7u32]).to_owned());
    pub static DNA: LazyLock<RelOID> = LazyLock::new(|| RelOID(Oid::const_new(&[2u32]).to_owned()));
    #[doc = " No initialization vector"]
    #[doc = " X9.57 DSA signature generated with SHA-1 hash (DSA X9.30)"]
    pub static DSA_WITH_SHA1: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::const_new(&[1u32, 2u32, 840u32, 10040u32, 4u32, 3u32]).to_owned())
    });
    pub static EAR_SHAPE: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[3u32]).to_owned()));
    #[doc = " X9.62 ECDSA signature with SHA-1"]
    pub static ECDSA_WITH_SHA1: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::const_new(&[1u32, 2u32, 840u32, 10045u32, 4u32, 1u32]).to_owned())
    });
    pub static FACIAL_FEATURES: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[4u32]).to_owned()));
    pub static FINGER_GEOMETRY: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[6u32]).to_owned()));
    pub static FINGER_IMAGE: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[5u32]).to_owned()));
    #[doc = " X9.84 vendor specific formats "]
    pub static FORMAT_OWNER: LazyLock<OID> =
        LazyLock::new(|| OID(Oid::new(&[&***X9_84, &[4u32]].concat()).unwrap().to_owned()));
    pub static GAIT: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[19u32]).to_owned()));
    pub static HAND_GEOMETRY: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[7u32]).to_owned()));
    #[doc = "  X9.71 HMAC with SHA-1 algorithm"]
    pub static HMAC_WITH_SHA1: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::const_new(&[1u32, 3u32, 6u32, 1u32, 5u32, 5u32, 8u32, 1u32, 2u32]).to_owned())
    });
    pub static IBIA_A3_VISION: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[16u32]).to_owned()));
    pub static IBIA_BIOSCRYPT: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[2u32]).to_owned()));
    pub static IBIA_CYBER_SIGN: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[7u32]).to_owned()));
    pub static IBIA_DERMALOG: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[13u32]).to_owned()));
    pub static IBIA_FINGERPRINT_CARDS_AB: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[9u32]).to_owned()));
    pub static IBIA_IDENTIX: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[12u32]).to_owned()));
    pub static IBIA_INFINEON_TECHNOLOGIES_AG: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[4u32]).to_owned()));
    pub static IBIA_IRIDIAN_TECHNOLOGIES: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[5u32]).to_owned()));
    pub static IBIA_LOGICO: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[14u32]).to_owned()));
    pub static IBIA_NEC: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[17u32]).to_owned()));
    pub static IBIA_NIST: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[15u32]).to_owned()));
    pub static IBIA_OWNER: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***FORMAT_OWNER, &[1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static IBIA_PRECISE_BIOMETRIC: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[11u32]).to_owned()));
    #[doc = " Application constrained"]
    #[doc = " Relative object identifier representations of the identical"]
    #[doc = " IBIA vendor specific formats defined as OBJECT IDENTIFIER"]
    #[doc = " values above are used to identify these formats when they must"]
    #[doc = " comply with the fixed format requirements of the BioAPI 1.1"]
    #[doc = " specification and are associated with a two byte integer value."]
    pub static IBIA_SAFLINK: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[1u32]).to_owned()));
    pub static IBIA_STMICROELECTRONICS: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[18u32]).to_owned()));
    pub static IBIA_SECU_GEN: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[10u32]).to_owned()));
    pub static IBIA_VERIDICOM: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[6u32]).to_owned()));
    pub static IBIA_VISIONICS: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[3u32]).to_owned()));
    pub static IBIA_E_CRYP: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[8u32]).to_owned()));
    pub static ID_BODY_ODOR: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[1u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " RSA PKCS #7 Content type"]
    pub static ID_DATA: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::const_new(&[1u32, 2u32, 840u32, 113549u32, 1u32, 7u32, 1u32]).to_owned())
    });
    pub static ID_DNA: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[2u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_EAR_SHAPE: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_FACIAL_FEATURES: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[4u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_FINGER_GEOMETRY: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[6u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_FINGER_IMAGE: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[5u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_GAIT: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[19u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_HAND_GEOMETRY: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[7u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_IRIS_FEATURES: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_KEYSTROKE_DYNAMICS: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[9u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_LIP_MOVEMENT: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[18u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_PALM: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[10u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_RETINA: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[11u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " Security object identifiers"]
    #[doc = " FIPS 180-1 and FIPS 180-2 Secure Hash Algorithm "]
    pub static ID_SHA1: LazyLock<OID> =
        LazyLock::new(|| OID(Oid::const_new(&[1u32, 3u32, 14u32, 3u32, 2u32, 26u32]).to_owned()));
    pub static ID_SHA256: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***SHA2_ALGORITHM, &[1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_SHA384: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***SHA2_ALGORITHM, &[2u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_SHA512: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***SHA2_ALGORITHM, &[3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_SIGNATURE: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[12u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_SPEECH_PATTERN: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[13u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_THERMAL_FACE_IMAGE: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[16u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_THERMAL_HAND_IMAGE: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[17u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_THERMAL_IMAGE: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[14u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_UNKNOWN_TYPE: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[0u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_VEIN_PATTERN: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***BIOMETRIC, &[15u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_X984_BIO_INFO: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***CBEFF_OWNER, &[0u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static IRIS_FEATURES: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[8u32]).to_owned()));
    pub static KEYSTROKE_DYNAMICS: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[9u32]).to_owned()));
    pub static LIP_MOVEMENT: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[18u32]).to_owned()));
    #[doc = " X9.84 biometric matching methods "]
    pub static MATCHING_METHOD: LazyLock<OID> =
        LazyLock::new(|| OID(Oid::new(&[&***X9_84, &[3u32]].concat()).unwrap().to_owned()));
    pub static PALM: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[10u32]).to_owned()));
    #[doc = " X9.84 biometric processing algorithms "]
    pub static PROCESSING_ALGORITHM: LazyLock<OID> =
        LazyLock::new(|| OID(Oid::new(&[&***X9_84, &[2u32]].concat()).unwrap().to_owned()));
    pub static RETINA: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[11u32]).to_owned()));
    pub static RSA_ENCRYPTION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::const_new(&[1u32, 2u32, 840u32, 113549u32, 1u32, 1u32, 1u32]).to_owned()
    });
    #[doc = " RSA PKCS #1 signature generated with SHA-1 hash & encryption scheme"]
    pub static SHA1_WITH_RSAENCRYPTION: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::const_new(&[1u32, 2u32, 840u32, 113549u32, 1u32, 1u32, 5u32]).to_owned())
    });
    pub static SHA2_ALGORITHM: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::const_new(&[2u32, 16u32, 840u32, 1u32, 101u32, 3u32, 4u32, 2u32]).to_owned())
    });
    pub static SIGNATURE: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[12u32]).to_owned()));
    pub static SPEECH_PATTERN: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[13u32]).to_owned()));
    pub static THERMAL_FACE_IMAGE: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[16u32]).to_owned()));
    pub static THERMAL_HAND_IMAGE: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[17u32]).to_owned()));
    pub static THERMAL_IMAGE: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[14u32]).to_owned()));
    #[doc = " X9.84 biometric technology object identifier fragments "]
    pub static UNKNOWN_TYPE: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[0u32]).to_owned()));
    pub static VEIN_PATTERN: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[15u32]).to_owned()));
    #[doc = " Alias"]
    #[doc = " x9-84                          { 1 3 133 16 840 9 84         }"]
    #[doc = " x9-84-Module                   { 1 3 133 16 840 9 84 0       }"]
    #[doc = " x9-84-Biometrics               { 1 3 133 16 840 9 84 0  1    }"]
    #[doc = " x9-84-CMS                      { 1 3 133 16 840 9 84 0  2    }"]
    #[doc = " x9-84-Identifiers              { 1 3 133 16 840 9 84 0  3    }"]
    #[doc = " biometric                      { 1 3 133 16 840 9 84 1       }"]
    #[doc = " id-unknown-Type                { 1 3 133 16 840 9 84 1  0    }"]
    #[doc = " id-body-Odor                   { 1 3 133 16 840 9 84 1  1    }"]
    #[doc = " id-dna                         { 1 3 133 16 840 9 84 1  2    }"]
    #[doc = " id-ear-Shape                   { 1 3 133 16 840 9 84 1  3    }"]
    #[doc = " id-facial-Features             { 1 3 133 16 840 9 84 1  4    }"]
    #[doc = " id-finger-Image                { 1 3 133 16 840 9 84 1  5    }"]
    #[doc = " id-finger-Geometry             { 1 3 133 16 840 9 84 1  6    }"]
    #[doc = " id-hand-Geometry               { 1 3 133 16 840 9 84 1  7    }"]
    #[doc = " id-iris-Features               { 1 3 133 16 840 9 84 1  8    }"]
    #[doc = " id-keystroke-Dynamics          { 1 3 133 16 840 9 84 1  9    }"]
    #[doc = " id-palm                        { 1 3 133 16 840 9 84 1 10    }"]
    #[doc = " id-retina                      { 1 3 133 16 840 9 84 1 11    }"]
    #[doc = " id-signature                   { 1 3 133 16 840 9 84 1 12    }"]
    #[doc = " id-speech-Pattern              { 1 3 133 16 840 9 84 1 13    }"]
    #[doc = " id-thermal-Image               { 1 3 133 16 840 9 84 1 14    }"]
    #[doc = " id-vein-Pattern                { 1 3 133 16 840 9 84 1 15    }"]
    #[doc = " id-thermal-Face-Image          { 1 3 133 16 840 9 84 1 16    }"]
    #[doc = " id-thermal-Hand-Image          { 1 3 133 16 840 9 84 1 17    }"]
    #[doc = " id-lip-Movement                { 1 3 133 16 840 9 84 1 18    }"]
    #[doc = " id-gait                        { 1 3 133 16 840 9 84 1 19    }"]
    #[doc = " processing-algorithm           { 1 3 133 16 840 9 84 2       }"]
    #[doc = " matching-method                { 1 3 133 16 840 9 84 3       }"]
    #[doc = " format-Owner                   { 1 3 133 16 840 9 84 4       }"]
    #[doc = " cbeff-Owner                    { 1 3 133 16 840 9 84 4  0    }"]
    #[doc = " ibia-Owner                     { 1 3 133 16 840 9 84 4  1    }"]
    #[doc = " id-ibia-SAFLINK                { 1 3 133 16 840 9 84 4  1  1 }"]
    #[doc = " id-ibia-Bioscrypt              { 1 3 133 16 840 9 84 4  1  2 }"]
    #[doc = " id-ibia-Visionics              { 1 3 133 16 840 9 84 4  1  3 }"]
    #[doc = " id-ibia-InfineonTechnologiesAG { 1 3 133 16 840 9 84 4  1  4 }"]
    #[doc = " id-ibia-IridianTechnologies    { 1 3 133 16 840 9 84 4  1  5 }"]
    #[doc = " id-ibia-Veridicom              { 1 3 133 16 840 9 84 4  1  6 }"]
    #[doc = " id-ibia-CyberSIGN              { 1 3 133 16 840 9 84 4  1  7 }"]
    #[doc = " id-ibia-eCryp                  { 1 3 133 16 840 9 84 4  1  8 }"]
    #[doc = " id-ibia-FingerprintCardsAB     { 1 3 133 16 840 9 84 4  1  9 }"]
    #[doc = " id-ibia-SecuGen                { 1 3 133 16 840 9 84 4  1 10 }"]
    #[doc = " id-ibia-PreciseBiometric       { 1 3 133 16 840 9 84 4  1 11 }"]
    #[doc = " id-ibia-Identix                { 1 3 133 16 840 9 84 4  1 12 }"]
    #[doc = " id-ibia-DERMALOG               { 1 3 133 16 840 9 84 4  1 13 }"]
    #[doc = " id-ibia-LOGICO                 { 1 3 133 16 840 9 84 4  1 14 }"]
    #[doc = " id-ibia-NIST                   { 1 3 133 16 840 9 84 4  1 15 }"]
    #[doc = " id-ibia-A3Vision               { 1 3 133 16 840 9 84 4  1 16 }"]
    #[doc = " id-ibia-NEC                    { 1 3 133 16 840 9 84 4  1 17 }"]
    #[doc = " id-ibia-STMicroelectronics     { 1 3 133 16 840 9 84 4  1 18 }"]
    #[doc = " x9-Owner                       { 1 3 133 16 840 9 84 4  2    }"]
    #[doc = " certificate-Extensions         { 1 3 133 16 840 9 84 5       }"]
    #[doc = " x968-biometricTemplates        { 1 3 133 16 840 9 84 5  0    }"]
    #[doc = " x509-biometricTemplates        { 1 3 133 16 840 9 84 5  1    }"]
    #[doc = " X9.84 arc; base object identifier "]
    pub static X9_84: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::const_new(&[1u32, 3u32, 133u32, 16u32, 840u32, 9u32, 84u32]).to_owned())
    });
    pub static X9_84_BIOMETRICS: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***X9_84_MODULE, &[1u32, 1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static X9_84_CMS: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***X9_84_MODULE, &[2u32, 1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static X9_84_IDENTIFIERS: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***X9_84_MODULE, &[3u32, 1u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " X9.84 ASN.1 modules "]
    pub static X9_84_MODULE: LazyLock<OID> =
        LazyLock::new(|| OID(Oid::new(&[&***X9_84, &[0u32]].concat()).unwrap().to_owned()));
    pub static X9_OWNER: LazyLock<OID> = LazyLock::new(|| {
        OID(Oid::new(&[&***FORMAT_OWNER, &[2u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static X984_BIO_INFO: LazyLock<RelOID> =
        LazyLock::new(|| RelOID(Oid::const_new(&[0u32]).to_owned()));
}
