---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x692_2008_LegacyProtocol-ASN1-Module.asn1
---
Warnings:
Unidentified generating bindings for : A type name is needed to stringify sequence value LinkedStructLikeValue([("a", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "A", constraints: [] }), Explicit(LinkedNestedValue { supertypes: ["A"], value: LinkedIntValue { integer_type: Uint8, value: 5 } })), ("b-flag", Boolean(Boolean { constraints: [] }), Explicit(Boolean(true))), ("c-len", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(7)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint8, value: 2 })), ("b", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "B", constraints: [] }), Explicit(LinkedNestedValue { supertypes: ["B"], value: LinkedStructLikeValue([("b1", Enumerated(Enumerated { members: [Enumeral { name: "e0", description: None, index: 0 }, Enumeral { name: "e1", description: None, index: 1 }, Enumeral { name: "e2", description: None, index: 2 }, Enumeral { name: "e3", description: None, index: 3 }], extensible: None, constraints: [] }), Explicit(ElsewhereDeclaredValue { parent: None, identifier: "e1" })), ("b2", Boolean(Boolean { constraints: [] }), Explicit(Boolean(true))), ("b3", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(3)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint8, value: 1 }))]) })), ("c", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "C", constraints: [] }), Explicit(LinkedNestedValue { supertypes: ["C"], value: LinkedArrayLikeValue([LinkedNestedValue { supertypes: ["C-elem"], value: LinkedStructLikeValue([("c1", BitString(BitString { constraints: [Subtype(ElementSetSpecs { set: Element(SizeConstraint(Element(SingleValue { value: Integer(4), extensible: false }))), extensible: false })], distinguished_values: None }), Explicit(BitString([false, true, false, true]))), ("c2", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(1024)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint16, value: 1 }))]) }, LinkedNestedValue { supertypes: ["C-elem"], value: LinkedStructLikeValue([("c1", BitString(BitString { constraints: [Subtype(ElementSetSpecs { set: Element(SizeConstraint(Element(SingleValue { value: Integer(4), extensible: false }))), extensible: false })], distinguished_values: None }), Explicit(BitString([true, true, true, true]))), ("c2", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(1024)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint16, value: 2 }))]) }]) })), ("d", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "D", constraints: [] }), Explicit(LinkedNestedValue { supertypes: ["D"], value: LinkedArrayLikeValue([LinkedNestedValue { supertypes: ["D-elem"], value: LinkedStructLikeValue([("d1", Boolean(Boolean { constraints: [] }), Explicit(Boolean(true))), ("d2", Enumerated(Enumerated { members: [Enumeral { name: "f0", description: None, index: 0 }, Enumeral { name: "f1", description: None, index: 1 }, Enumeral { name: "f2", description: None, index: 2 }, Enumeral { name: "f3", description: None, index: 3 }, Enumeral { name: "f4", description: None, index: 4 }, Enumeral { name: "f5", description: None, index: 5 }, Enumeral { name: "f6", description: None, index: 6 }, Enumeral { name: "f7", description: None, index: 7 }], extensible: None, constraints: [] }), Explicit(ElsewhereDeclaredValue { parent: None, identifier: "f3" })), ("d3", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(7)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint8, value: 5 }))]) }]) }))])


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod legacy_protocol_asn1_module {
    extern crate alloc;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " determined by end of PDU"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=7"))]
    pub struct A(pub u8);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum BB1 {
        e0 = 0,
        e1 = 1,
        e2 = 2,
        e3 = 3,
    }
    #[doc = " Values 5..7 are reserved for future use."]
    #[doc = " Version 1 systems should treat 5 to 7 as 4."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct B {
        pub b1: BB1,
        pub b2: bool,
        #[rasn(value("0..=3"))]
        pub b3: u8,
    }
    impl B {
        pub fn new(b1: BB1, b2: bool, b3: u8) -> Self {
            Self { b1, b2, b3 }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("0..=7"))]
    pub struct C(pub SequenceOf<CElem>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "C-elem")]
    pub struct CElem {
        #[rasn(size("4"))]
        pub c1: BitString,
        #[rasn(value("0..=1024"))]
        pub c2: u16,
    }
    impl CElem {
        pub fn new(c1: BitString, c2: u16) -> Self {
            Self { c1, c2 }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("0..=20"))]
    pub struct D(pub SequenceOf<DElem>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum DElemD2 {
        f0 = 0,
        f1 = 1,
        f2 = 2,
        f3 = 3,
        f4 = 4,
        f5 = 5,
        f6 = 6,
        f7 = 7,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "D-elem")]
    pub struct DElem {
        pub d1: bool,
        pub d2: DElemD2,
        #[rasn(value("0..=7"))]
        pub d3: u8,
    }
    impl DElem {
        pub fn new(d1: bool, d2: DElemD2, d3: u8) -> Self {
            Self { d1, d2, d3 }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum LegacyProtocolMessagesMessageId {
        message1 = 0,
        message2 = 1,
        message3 = 2,
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum LegacyProtocolMessagesMessages {
        message1(Message1),
        message2(Message2),
        message3(Message3),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct LegacyProtocolMessages {
        #[rasn(identifier = "message-id")]
        pub message_id: LegacyProtocolMessagesMessageId,
        pub messages: LegacyProtocolMessagesMessages,
    }
    impl LegacyProtocolMessages {
        pub fn new(
            message_id: LegacyProtocolMessagesMessageId,
            messages: LegacyProtocolMessagesMessages,
        ) -> Self {
            Self {
                message_id,
                messages,
            }
        }
    }
    #[doc = " The CHOICE is constrained by the value of message-id."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct Message1 {
        pub a: A,
        #[rasn(identifier = "b-flag")]
        pub b_flag: bool,
        #[rasn(value("0..=7"), identifier = "c-len")]
        pub c_len: u8,
        pub b: Option<B>,
        pub c: C,
        pub d: Option<D>,
    }
    impl Message1 {
        pub fn new(a: A, b_flag: bool, c_len: u8, b: Option<B>, c: C, d: Option<D>) -> Self {
            Self {
                a,
                b_flag,
                c_len,
                b,
                c,
                d,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct Message2 {}
    impl Message2 {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for Message2 {
        fn default() -> Self {
            Self {}
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct Message3 {}
    impl Message3 {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for Message3 {
        fn default() -> Self {
            Self {}
        }
    }
    pub static MAX_C_LEN: LazyLock<Integer> = LazyLock::new(|| Integer::from(7i128));
    pub static MAX_D_LEN: LazyLock<Integer> = LazyLock::new(|| Integer::from(20i128));
}
