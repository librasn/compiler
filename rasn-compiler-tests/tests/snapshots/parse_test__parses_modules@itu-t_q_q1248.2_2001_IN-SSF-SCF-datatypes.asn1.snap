---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_q_q1248.2_2001_IN-SSF-SCF-datatypes.asn1
---
Warnings:
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minUSIServiceIndicatorLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minUSIInformationLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfTriggers
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfTriggers
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfTriggers
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minServiceInteractionIndicatorsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minScfIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minSFBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minSDSSinformationLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minSCIBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minRouteingNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxNbOfRoutes
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxNbOfRoutes
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minRouteListLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minRouteListLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minRequestedUTSINum
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minUSIServiceIndicatorLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfInfoItems
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfInfoItems
LinkerError in ASN grammar: Failed to resolve argument Integer4 of parameterized implementation.
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minRedirectingPartyIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minReasonLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minQoSParameterLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minOriginalCalledPartyIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minMinAcceptableATMTrafficDescriptorLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minMidCallControlInfoNum
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfCounters
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minISDNAccessRelatedInfoLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minIPSSPCapabilitiesLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxAlternativeIdentities
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minIPAvailableLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfTriggers
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfInServiceCompatibilityIndLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.highLayerCompatibilityLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxGlobalCallReferenceLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfGenericNumbers
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minGenericNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minGenericNameLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minGenericIdentifierLength
LinkerError in ASN grammar: Failed to resolve supertype InformationToSend of parameterized implementation.
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minForwardGVNSLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minSFBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minFCIBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minEventTypeChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minEventSpecificInformationChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minEndToEndTDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minMidCallControlInfoNum
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxBearerCapabilityLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDisplayInformationLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfAddresses
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDestinationIndexLength
LinkerError in ASN grammar: Failed to resolve argument InformationToSend of parameterized implementation.
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCumulativeTransitDelayLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfCounters
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minConnectionIdentifierLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minEventTypeChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCauseLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCarrierLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCallingPartySubaddressLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCallingPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCallingGeodeticLocationLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCalledPartySubaddressLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCalledDirectoryNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfCSs
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCallResultLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxCallReferenceLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.numOfCSAs
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxCNInfoLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minCDVTDescriptorLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxBearerCapabilityLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minBackwardGVNSLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minAALPLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minMidCallControlInfoNum
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.maxAlternativeIdentities
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minAlternativeATMTrafficDescriptorLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minAdditionalATMCellRateLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minATMCellRateLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minAESACallingPartyLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minAESACalledPartyLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minAChBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference b2.&.minAALPLength


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod in_ssf_scf_datatypes {
    extern crate alloc;
    use super::in_common_classes::*;
    use super::in_common_datatypes::{Extensions, Integer4};
    use super::in_object_identifiers::{
        COMMON_CLASSES, COMMON_DATATYPES, SCF_SRF_CLASSES, SCF_SRF_DATATYPES, SSF_SCF_CLASSES,
        TC_MESSAGES,
    };
    use super::in_scf_srf_classes::*;
    use super::in_scf_srf_datatypes::InformationToSend;
    use super::in_ssf_scf_classes::*;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " The AChBillingChargingCharacteristics parameter specifies the charging related information"]
    #[doc = " to be provided by the SSF and the conditions on which this information has to be reported"]
    #[doc = " back to the SCF with the ApplyChargingReport operation."]
    #[doc = " Different set of criteria may be provided in case more than one report is expected."]
    #[doc = " Its content is network operator specific."]
    #[doc = " Examples of charging related information to be provided by the SSF may be: bulk counter"]
    #[doc = " values, costs, tariff change and time of charge, time stamps, durations, etc."]
    #[doc = " Examples of conditions on which the charging related information are to be reported may be:"]
    #[doc = " threshold value reached, timer expiration, tariff change, end of connection configuration, etc"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ActionIndicator {
        activate = 1,
        deactivate = 2,
        retrieve = 3,
    }
    #[doc = " indicates the action to be performed by the ManageTriggerData operation (activate, deactivate"]
    #[doc = " or retrieve the status of a TDP."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ActionOnProfile {
        activate = 0,
        deactivate = 1,
    }
    #[doc = " Indicates whether a setServiceProfile operation is used to activate or deactivate profile elements."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ActionPerformed {
        activated = 1,
        deactivated = 2,
        alreadyActive = 3,
        alreadyInactive = 4,
        isActive = 5,
        isInactive = 6,
        tDPunknown = 7,
    }
    #[doc = " Indicates the AESACallingParty Information Element. Refer to Q.2763 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AlertingPattern(pub FixedOctetString<3usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AlternativeIdentity {
        #[rasn(size("1..=512"), tag(context, 0))]
        url(Ia5String),
    }
    #[doc = " Indicates the AlternativeATMTrafficDescriptor Information Element. Refer to Q.2931 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=2047"))]
    pub struct ApplicationTimer(pub u16);
    #[doc = " The following three definitions are local short-hand notation for convenience."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct B1(pub COMMONBOUNDS);
    #[doc = " defined in Q.1248.1 (Part 1 of Recommendation Q.1248)"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct B2(pub SCFSSFBOUNDS);
    #[doc = " defined in this Recommendation (Q.1248.2)"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct B3(pub SCFSRFBOUNDS);
    #[doc = " Indicates the GVNS Backward information. Refer to Q.735 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct BackwardServiceInteractionInd {
        #[rasn(
            size("1"),
            tag(context, 1),
            identifier = "conferenceTreatmentIndicator"
        )]
        pub conference_treatment_indicator: Option<OctetString>,
        #[rasn(
            size("1"),
            tag(context, 2),
            identifier = "callCompletionTreatmentIndicator"
        )]
        pub call_completion_treatment_indicator: Option<OctetString>,
        #[rasn(size("1"), tag(context, 3), identifier = "holdTreatmentIndicator")]
        pub hold_treatment_indicator: Option<OctetString>,
        #[rasn(size("1"), tag(context, 4), identifier = "ectTreatmentIndicator")]
        pub ect_treatment_indicator: Option<OctetString>,
    }
    impl BackwardServiceInteractionInd {
        pub fn new(
            conference_treatment_indicator: Option<OctetString>,
            call_completion_treatment_indicator: Option<OctetString>,
            hold_treatment_indicator: Option<OctetString>,
            ect_treatment_indicator: Option<OctetString>,
        ) -> Self {
            Self {
                conference_treatment_indicator,
                call_completion_treatment_indicator,
                hold_treatment_indicator,
                ect_treatment_indicator,
            }
        }
    }
    #[doc = " Special construct used to gather all B-ISDN specific parameters"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum BothwayThroughConnectionInd {
        bothwayPathRequired = 0,
        bothwayPathNotRequired = 1,
    }
    #[doc = " Indicates the cause for interface related information. Refer to the Q.763 Cause  parameter for encoding"]
    #[doc = " For the use of cause and location values refer to Q.850."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct CCSS(pub bool);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CGEncountered {
        noCGencountered = 0,
        manualCGencountered = 1,
        sCPOverload = 2,
    }
    #[doc = " See Q.763 for encoding"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(
        delegate,
        identifier = "CUG-Index",
        size("1..=4"),
        from(
            "\u{30}", "\u{31}", "\u{32}", "\u{33}", "\u{34}", "\u{35}", "\u{36}", "\u{37}",
            "\u{38}", "\u{39}"
        )
    )]
    pub struct CUGIndex(pub Ia5String);
    #[doc = " Indicates the SSF CSA identifier"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "CUG-Interlock")]
    pub struct CUGInterlock(pub FixedOctetString<4usize>);
    #[doc = " Indicates the type of calling party (e.g. operator, payphone, ordinary subscriber)."]
    #[doc = "  Refer to Q.763 for encoding"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CallProcessingOperation {
        aLERTing = 1,
        sETUP = 5,
        cONNect = 7,
        dISConnect = 69,
        rELease = 77,
        rELeaseCOMPlete = 90,
        fACility = 98,
    }
    #[doc = " Indicates the Called Directory Number. Refer to Q.763  'Called Directory Number' for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CalledPartyBusinessGroupID(pub OctetString);
    #[doc = " The coding of this parameter is based on the appropriate mapping with the ISUP parameter Calling Geodetic Location."]
    #[doc = " Refer to Q.763 for encoding."]
    #[doc = " This parameter  indicates the geograhic coordinate of a calling party. The excessive amount of data possible"]
    #[doc = " within this parameter may require segmentation of the INAP operation to be-sent to the SCF."]
    #[doc = " The amount of data possible to be conveyed within this  parameter  from"]
    #[doc = "  the SSF -to the SCF could  be limitted, for example it may be considered to only support a relevant subset of all the"]
    #[doc = "  shape descriptions. This is to be considered in the next Capability Set."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallingPartyBusinessGroupID(pub OctetString);
    #[doc = " Indicates the Calling Party Subaddress. . Refer to Q.763  for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallingPartysCategory(pub FixedOctetString<1usize>);
    #[doc = " encoding of cNInfo  is similar to the NNI specific information in the APP parameter in Q.765.1"]
    #[doc = " first octet contains Q.765.1 CNID indicator, only bit 5 and 6 are significant. This is followed by zero to 12 octets"]
    #[doc = " that contains the Q.765.1 CNID parameter, i.e. the Corporate Telecommunications Network  Identifier , if  present."]
    #[doc = " This implies that the recommended maxCNInfoLength  becomes 13 octets."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Component {
        #[rasn(size("1..=118"), tag(context, 0))]
        componentInfo(OctetString),
        #[rasn(tag(context, 1))]
        relayedComponent(Any),
    }
    #[doc = " If componentInfo is chosen, then it is necessary to use this parameter in sequence with ComponentType and"]
    #[doc = " ComponentCorrelationID"]
    #[doc = " If relayedComponent is chosen, then ComponentType and ComponentCorrelationID may not be used in the"]
    #[doc = " sequence"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ComponentCorrelationID(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ComponentType {
        any = 0,
        invoke = 1,
        rResult = 2,
        rError = 3,
        rReject = 4,
    }
    #[doc = " Allows to combine basic gap criteria with the SCF identifier."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ConnectedNumberTreatmentInd {
        noINImpact = 0,
        presentationRestricted = 1,
        presentCalledINNumber = 2,
        presentCalledINNumberRestricted = 3,
    }
    #[doc = " Indicates the ConnectionElementIdentifier Information Element. Refer to Q.2763 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ControlType {
        sCPOverloaded = 0,
        manuallyInitiated = 1,
        destinationOverload = 2,
    }
    #[doc = " used by SCF for correlation with a previous operation. Refer to clause 11 for a description of the procedures"]
    #[doc = " associated with this parameter."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CounterAndValue {
        #[rasn(tag(context, 0), identifier = "counterID")]
        pub counter_id: CounterID,
        #[rasn(tag(context, 1), identifier = "counterValue")]
        pub counter_value: Integer4,
    }
    impl CounterAndValue {
        pub fn new(counter_id: CounterID, counter_value: Integer4) -> Self {
            Self {
                counter_id,
                counter_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=9"))]
    pub struct CounterID(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CreateOrRemoveIndicator {
        create = 0,
        remove = 1,
    }
    #[doc = " Indicates the CumulativeTransitDelay Information Element. Refer to Q.2763 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=2"))]
    pub struct CutAndPaste(pub u8);
    #[doc = " Indicates the number of leading digits to be deleted (cut) and to paste remaining dialed digits."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DateAndTime(pub FixedOctetString<6usize>);
    #[doc = " The SCF may specify the number of digits to be collected by the SSF for the CollectedInfo event"]
    #[doc = " When all digits are collected, the SSF reports the event to the SCF"]
    #[doc = " The SCF may set a timer in the SSF for the No Answer event. If the user does not answer the call"]
    #[doc = "within the allotted time, the SSF reports the event to the SCF"]
    #[doc = " The SCF may specify the number of digits to be collected by the SSF for the"]
    #[doc = " CollecteInfo event and hereby specify a minimum number of digits to be collected in case"]
    #[doc = " the exact number of digits is unknown to the SCF, but a  report is desired in case of complete number"]
    #[doc = " is determined before the requested number of digits has been collected."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("-2..=86400"))]
    pub struct Duration(pub i32);
    #[doc = " Indicates the MaximunEndToEndTransitDelay Information Element. Refer to Q.2763 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Entry {
        #[rasn(tag(context, 0))]
        agreements(ObjectIdentifier),
        #[rasn(tag(context, 1))]
        networkSpecific(Integer4),
    }
    #[doc = " defined by network operator."]
    #[doc = " Its content is network signalling/operator specific."]
    #[doc = " Indicates the charging related information specific to the event."]
    #[doc = " An example data EmbeddedType definition for this parameter is given below:"]
    #[doc = "\t\tchargePulses\t\t[0] Integer4,"]
    #[doc = "\t\tchargeMessages\t\t[1] OCTET STRING (SIZE (min..max))"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum EventTypeBCSM {
        origAttemptAuthorized = 1,
        collectedInfo = 2,
        analysedInformation = 3,
        routeSelectFailure = 4,
        oCalledPartyBusy = 5,
        oNoAnswer = 6,
        oAnswer = 7,
        oMidCall = 8,
        oDisconnect = 9,
        oAbandon = 10,
        termAttemptAuthorized = 12,
        tBusy = 13,
        tNoAnswer = 14,
        tAnswer = 15,
        tMidCall = 16,
        tDisconnect = 17,
        tAbandon = 18,
        oTermSeized = 19,
        oSuspend = 20,
        tSuspend = 21,
        origAttempt = 22,
        termAttempt = 23,
        oReAnswer = 24,
        tReAnswer = 25,
        facilitySelectedAndAvailable = 26,
        callAccepted = 27,
        authorizeRouteFailure = 28,
        originationAttemptDenied = 29,
        terminationAttemptDenied = 30,
        oModifyRequest = 100,
        oModifyResult = 101,
        tModifyRequest = 102,
        tModifyResult = 103,
    }
    #[doc = " This parameter indicates the charging event type. ."]
    #[doc = " Its content is network signalling / operator specific."]
    #[doc = " An example data type definition for this parameter is given below:"]
    #[doc = " EventTypeCharging EmbeddedType ::= ENUMERATED {"]
    #[doc = " \t\t\t\tchargePulses (0),"]
    #[doc = " \t\t\t\tchargeMessages (1)"]
    #[doc = " \t\t\t\t}"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum FacilityGroup {
        #[rasn(tag(context, 0))]
        trunkGroupID(Integer),
        #[rasn(tag(context, 1))]
        privateFacilityID(Integer),
        #[rasn(tag(context, 2))]
        huntGroup(OctetString),
        #[rasn(tag(context, 3))]
        routeIndex(OctetString),
    }
    #[doc = " Indicates the particular group of facilities to route the call. huntGroup and routeIndex are encoded as"]
    #[doc = " network operator specific."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FacilityGroupMember(pub Integer);
    #[doc = " The two-digit feature code preceded by \"*\" or \"11\"."]
    #[doc = " Uses the LocationNumber format which is based on the Q.763 Location Number format."]
    #[doc = " The Nature of Address indicator field shall be set to \"Spare\" (value 00000000)."]
    #[doc = " The Numbering Plan Indicator field shall be set to \"Spare\" (value 000)"]
    #[doc = " Used for stimulus signalling (Q.932)."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum FeatureRequestIndicator {
        hold = 0,
        retrieve = 1,
        featureActivation = 2,
        spare1 = 3,
        sparen = 127,
    }
    #[doc = " If releaseCause is not present, the default value is the same as the ISUP cause value decimal 31."]
    #[doc = " If informationToSend is present, the call will be released after the end of the announcement"]
    #[doc = " with the indicated or default releaseCause."]
    #[doc = " If maximumNumberOfCounters is not present, ServiceFilteringResponse will be sent with"]
    #[doc = " CountersValue::= SEQUENCE SIZE (0) OF CountersAndValue."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum FilteringCharacteristics {
        #[rasn(value("-1..=32000"), tag(context, 0))]
        interval(i16),
        #[rasn(tag(context, 1))]
        numberOfCalls(Integer4),
    }
    #[doc = " In case calledAddressValue is specified, the numbers to be filtered are from calledAddressValue"]
    #[doc = " up to and including calledAddressValue + maximumNumberOfCounters-1."]
    #[doc = " The last two digits of calledAddressvalue can not exceed 100-maximumNumberOfCounters."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum FilteringTimeOut {
        #[rasn(tag(context, 0))]
        duration(Duration),
        #[rasn(tag(context, 1))]
        stopTime(DateAndTime),
    }
    #[doc = " Indicates the maximum duration of the filtering. When the timer expires, a ServiceFilteringResponse"]
    #[doc = " is sent to the SCF."]
    #[doc = " duration of 0 indicates that service filtering is to be removed."]
    #[doc = " duration of -1 indicates an infinite duration."]
    #[doc = " duration of -2 indicates a network specific duration."]
    #[doc = " other values indicate duration in seconds."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ForwardCallIndicators(pub FixedOctetString<2usize>);
    #[doc = " Indicates the condition that must be met to complete the connect."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct ForwardServiceInteractionInd {
        #[rasn(
            size("1"),
            tag(context, 1),
            identifier = "conferenceTreatmentIndicator"
        )]
        pub conference_treatment_indicator: Option<OctetString>,
        #[rasn(
            size("1"),
            tag(context, 2),
            identifier = "callDiversionTreatmentIndicator"
        )]
        pub call_diversion_treatment_indicator: Option<OctetString>,
        #[rasn(
            size("1"),
            tag(context, 3),
            identifier = "callOfferingTreatmentIndicator"
        )]
        pub call_offering_treatment_indicator: Option<OctetString>,
        #[rasn(
            size("1"),
            tag(context, 5),
            identifier = "callWaitingTreatmentIndicator"
        )]
        pub call_waiting_treatment_indicator: Option<OctetString>,
        #[rasn(
            extension_addition,
            size("1"),
            tag(context, 6),
            identifier = "holdTreatmentIndicator"
        )]
        pub hold_treatment_indicator: Option<OctetString>,
        #[rasn(
            extension_addition,
            size("1"),
            tag(context, 7),
            identifier = "ectTreatmentIndicator"
        )]
        pub ect_treatment_indicator: Option<OctetString>,
    }
    impl ForwardServiceInteractionInd {
        pub fn new(
            conference_treatment_indicator: Option<OctetString>,
            call_diversion_treatment_indicator: Option<OctetString>,
            call_offering_treatment_indicator: Option<OctetString>,
            call_waiting_treatment_indicator: Option<OctetString>,
            hold_treatment_indicator: Option<OctetString>,
            ect_treatment_indicator: Option<OctetString>,
        ) -> Self {
            Self {
                conference_treatment_indicator,
                call_diversion_treatment_indicator,
                call_offering_treatment_indicator,
                call_waiting_treatment_indicator,
                hold_treatment_indicator,
                ect_treatment_indicator,
            }
        }
    }
    #[doc = " Indicates the GVNS Forward information. Refer to Q.735, ยง6 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ForwardingCondition {
        busy = 0,
        noanswer = 1,
        any = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct GapIndicators {
        #[rasn(tag(context, 0))]
        pub duration: Duration,
        #[rasn(tag(context, 1), identifier = "gapInterval")]
        pub gap_interval: Interval,
    }
    impl GapIndicators {
        pub fn new(duration: Duration, gap_interval: Interval) -> Self {
            Self {
                duration,
                gap_interval,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct GapOnService {
        #[rasn(tag(context, 0), identifier = "serviceKey")]
        pub service_key: ServiceKey,
        #[rasn(tag(context, 1), identifier = "dpCriteria")]
        pub dp_criteria: Option<EventTypeBCSM>,
    }
    impl GapOnService {
        pub fn new(service_key: ServiceKey, dp_criteria: Option<EventTypeBCSM>) -> Self {
            Self {
                service_key,
                dp_criteria,
            }
        }
    }
    #[doc = " Indicates the teleservice. For encoding, DSS1 (Q.931) is used."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct HoldCause(pub OctetString);
    #[doc = " Identifies a list of service classes triggered during the lifetime of a call"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct INServiceCompatibilityResponse(pub Entry);
    #[doc = " Used to override the last entry in INServiceCompatibilityIndication"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("-1..=60000"))]
    pub struct Interval(pub i32);
    #[doc = " Indicates the destination user network interface related information. Refer to the Q.763 Access"]
    #[doc = " Transport parameter for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum LegID {
        #[rasn(tag(context, 0))]
        sendingSideID(LegType),
        #[rasn(tag(context, 1))]
        receivingSideID(LegType),
    }
    #[doc = " Indicates a reference to a specific party in a call. OPTIONAL denotes network operator specific use"]
    #[doc = " with a choice of unilateral ID assignment or bilateral ID assignment."]
    #[doc = " OPTIONAL for LegID also denotes the following:"]
    #[doc = "when only one party exists in the call, this parameter is not needed (as no ambiguity exists);"]
    #[doc = "when more than one party exists in the call, one of the following alternatives applies:"]
    #[doc = "\t 1. LegID is present and indicates which party is concerned."]
    #[doc = "\t 2. LegID is not present and a default value is assumed (e.g. calling party in the case of the"]
    #[doc = "\t    ApplyCharging operation)."]
    #[doc = " Choice between these two alternatives is kept a network operator option."]
    #[doc = " sendingSideID is used where legID is sent from the SCF  to the SSF and"]
    #[doc = " receivingSideID is used  where SCF receives legID from the SSF."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct LegType(pub FixedOctetString<1usize>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum MiscCallInfoMessageType {
        request = 0,
        notification = 1,
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum MiscCallInfoDpAssignment {
        individualBased = 0,
        groupBased = 1,
        switchBased = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MiscCallInfo {
        #[rasn(tag(context, 0), identifier = "messageType")]
        pub message_type: MiscCallInfoMessageType,
        #[rasn(tag(context, 1), identifier = "dpAssignment")]
        pub dp_assignment: Option<MiscCallInfoDpAssignment>,
    }
    impl MiscCallInfo {
        pub fn new(
            message_type: MiscCallInfoMessageType,
            dp_assignment: Option<MiscCallInfoDpAssignment>,
        ) -> Self {
            Self {
                message_type,
                dp_assignment,
            }
        }
    }
    #[doc = " Indicates the MinimumAcceptableATMTrafficDescriptor Information Element. Refer to Q.2931 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ModifyResultType {
        modifyAcknowledge = 0,
        modifyReject = 1,
    }
    #[doc = " Indicates the criteria for route monitoring"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum MonitorMode {
        interrupted = 0,
        notifyAndContinue = 1,
        transparent = 2,
    }
    #[doc = " Indicates whether a bearer modification attempt has been successful or not"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum MonitoringCriteria {
        #[rasn(tag(context, 0))]
        threshold(Integer4),
        #[rasn(tag(context, 1))]
        interval(Interval),
    }
    #[doc = " Indicates the event is relayed and/or processed by the SSF."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum MonitoringTimeOut {
        #[rasn(tag(context, 0))]
        duration(Duration),
        #[rasn(tag(context, 1))]
        stopTime(DateAndTime),
    }
    #[doc = " Indicates the numbering plan for collecting the user information. Refer to the Q.763 Numbering Plan"]
    #[doc = " Indicator field for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=255"))]
    pub struct NumberOfDigits(pub u8);
    #[doc = " Indicates when a route moniroting procedure shall be stopped."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct NumberingPlan(pub FixedOctetString<1usize>);
    #[doc = " Indicates redirection information. Refer to the Q.763 Redirection Information for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RedirectReason(pub FixedOctetString<1usize>);
    #[doc = " Indicates redirecting number. Refer to the Q.763 Redirecting number for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RedirectionInformation(pub FixedOctetString<2usize>);
    #[doc = " Indicates redirection reason information. Refer to the \"Invoking Pivot Reason\" parameter of  Q.763 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RegistratorIdentifier(pub OctetString);
    #[doc = " Its content is network operator specific"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ReportCondition {
        statusReport = 0,
        timerExpired = 1,
        canceled = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum RequestedInformationType {
        callAttemptElapsedTime = 0,
        callStopTime = 1,
        callConnectedElapsedTime = 2,
        calledAddress = 3,
        releaseCause = 30,
    }
    #[doc = " Indicates a logical identifier for the physical termination resource."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ResourceStatus {
        busy = 0,
        idle = 1,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ResponseCondition {
        intermediateResponse = 0,
        lastResponse = 1,
    }
    #[doc = " Its content is network operator specific"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct ServiceAddressInformation {
        #[rasn(tag(context, 0), identifier = "serviceKey")]
        pub service_key: Option<ServiceKey>,
        #[rasn(tag(context, 1), identifier = "miscCallInfo")]
        pub misc_call_info: MiscCallInfo,
        #[rasn(tag(context, 2), identifier = "triggerType")]
        pub trigger_type: Option<TriggerType>,
    }
    impl ServiceAddressInformation {
        pub fn new(
            service_key: Option<ServiceKey>,
            misc_call_info: MiscCallInfo,
            trigger_type: Option<TriggerType>,
        ) -> Self {
            Self {
                service_key,
                misc_call_info,
                trigger_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct ServiceInteractionIndicatorsTwoRedirectServiceTreatmentInd {
        #[rasn(tag(context, 0), identifier = "redirectReason")]
        pub redirect_reason: Option<RedirectReason>,
    }
    impl ServiceInteractionIndicatorsTwoRedirectServiceTreatmentInd {
        pub fn new(redirect_reason: Option<RedirectReason>) -> Self {
            Self { redirect_reason }
        }
    }
    #[doc = " Indicators which are exchanged between SSF and SCF to resolve interactions between IN based services"]
    #[doc = " and network based services, respectively between different IN based services."]
    #[doc = " Its content is network signalling/operator specific"]
    #[doc = " Note this parameter is kept in this Recommendation for backward compatibility to IN CS-1R,"]
    #[doc = " for this Recommendation see parameter ServiceInteractionIndicatorsTwo"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct ServiceInteractionIndicatorsTwo {
        #[rasn(tag(context, 0), identifier = "forwardServiceInteractionInd")]
        pub forward_service_interaction_ind: Option<ForwardServiceInteractionInd>,
        #[rasn(tag(context, 1), identifier = "backwardServiceInteractionInd")]
        pub backward_service_interaction_ind: Option<BackwardServiceInteractionInd>,
        #[rasn(tag(context, 2), identifier = "bothwayThroughConnectionInd")]
        pub bothway_through_connection_ind: Option<BothwayThroughConnectionInd>,
        #[rasn(tag(context, 3), identifier = "suspendTimer")]
        pub suspend_timer: Option<SuspendTimer>,
        #[rasn(tag(context, 4), identifier = "connectedNumberTreatmentInd")]
        pub connected_number_treatment_ind: Option<ConnectedNumberTreatmentInd>,
        #[rasn(tag(context, 5), identifier = "suppressCallDiversionNotification")]
        pub suppress_call_diversion_notification: Option<bool>,
        #[rasn(tag(context, 6), identifier = "suppressCallTransferNotification")]
        pub suppress_call_transfer_notification: Option<bool>,
        #[rasn(tag(context, 7), identifier = "allowCdINNoPresentationInd")]
        pub allow_cd_inno_presentation_ind: Option<bool>,
        #[rasn(
            tag(context, 8),
            default = "service_interaction_indicators_two_user_dialogue_duration_ind_default",
            identifier = "userDialogueDurationInd"
        )]
        pub user_dialogue_duration_ind: bool,
        #[rasn(
            tag(context, 9),
            default = "service_interaction_indicators_two_override_line_restrictions_default",
            identifier = "overrideLineRestrictions"
        )]
        pub override_line_restrictions: bool,
        #[rasn(
            tag(context, 10),
            default = "service_interaction_indicators_two_suppress_vpnapp_default",
            identifier = "suppressVPNAPP"
        )]
        pub suppress_vpnapp: bool,
        #[rasn(tag(context, 11), identifier = "calledINNumberOverriding")]
        pub called_innumber_overriding: Option<bool>,
        #[rasn(tag(context, 12), identifier = "redirectServiceTreatmentInd")]
        pub redirect_service_treatment_ind:
            Option<ServiceInteractionIndicatorsTwoRedirectServiceTreatmentInd>,
        #[rasn(tag(context, 13), identifier = "nonCUGCall")]
        pub non_cugcall: Option<()>,
    }
    impl ServiceInteractionIndicatorsTwo {
        pub fn new(
            forward_service_interaction_ind: Option<ForwardServiceInteractionInd>,
            backward_service_interaction_ind: Option<BackwardServiceInteractionInd>,
            bothway_through_connection_ind: Option<BothwayThroughConnectionInd>,
            suspend_timer: Option<SuspendTimer>,
            connected_number_treatment_ind: Option<ConnectedNumberTreatmentInd>,
            suppress_call_diversion_notification: Option<bool>,
            suppress_call_transfer_notification: Option<bool>,
            allow_cd_inno_presentation_ind: Option<bool>,
            user_dialogue_duration_ind: bool,
            override_line_restrictions: bool,
            suppress_vpnapp: bool,
            called_innumber_overriding: Option<bool>,
            redirect_service_treatment_ind: Option<
                ServiceInteractionIndicatorsTwoRedirectServiceTreatmentInd,
            >,
            non_cugcall: Option<()>,
        ) -> Self {
            Self {
                forward_service_interaction_ind,
                backward_service_interaction_ind,
                bothway_through_connection_ind,
                suspend_timer,
                connected_number_treatment_ind,
                suppress_call_diversion_notification,
                suppress_call_transfer_notification,
                allow_cd_inno_presentation_ind,
                user_dialogue_duration_ind,
                override_line_restrictions,
                suppress_vpnapp,
                called_innumber_overriding,
                redirect_service_treatment_ind,
                non_cugcall,
            }
        }
    }
    fn service_interaction_indicators_two_user_dialogue_duration_ind_default() -> bool {
        true
    }
    fn service_interaction_indicators_two_override_line_restrictions_default() -> bool {
        false
    }
    fn service_interaction_indicators_two_suppress_vpnapp_default() -> bool {
        false
    }
    #[doc = " ServiceInteractionIndicatorsTwo contains Indicators which are exchanged between SSF and SCF to resolve interactions"]
    #[doc = "between IN based services  and network based services, respectively between different IN based services."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ServiceKey(pub Integer4);
    #[doc = " Information that allows the SCF to choose the appropriate service logic."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ServiceProfileIdentifier(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=120"))]
    pub struct SuspendTimer(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TerminalType {
        unknown = 0,
        dialPulse = 1,
        dtmf = 2,
        isdn = 3,
        isdnNoDtmf = 4,
        spare = 16,
    }
    #[doc = " Identifies the terminal type so that the SCF can specify, to the SRF, the appropriate type of capability"]
    #[doc = " (voice recognition, DTMF, display capability, etc.). Since present signalling systems do not convey"]
    #[doc = " terminal type, this parameter applies only at originating or terminating local exchanges."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TimerID {
        tssf = 0,
    }
    #[doc = " Indicates the timer to be reset."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TimerValue(pub Integer4);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct Trigger {
        #[rasn(tag(context, 0), identifier = "tDPIdentifier")]
        pub t_dpidentifier: Integer,
        #[rasn(tag(context, 1), identifier = "dpName")]
        pub dp_name: Option<EventTypeBCSM>,
    }
    impl Trigger {
        pub fn new(t_dpidentifier: Integer, dp_name: Option<EventTypeBCSM>) -> Self {
            Self {
                t_dpidentifier,
                dp_name,
            }
        }
    }
    #[doc = " It is outside the scope of this capability set  whether all TDP types really apply"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TriggerDPType {
        #[rasn(identifier = "tdp-r")]
        tdp_r = 0,
        #[rasn(identifier = "tdp-n")]
        tdp_n = 1,
    }
    #[doc = " Indicates travelling class mark information."]
    #[doc = " Uses the LocationNumber format which is based on the Q.763 Location Number format."]
    #[doc = " The Nature of Address indicator field shall be set to \"Spare\" (value 00000000)."]
    #[doc = " The Numbering Plan Indicator field shall be set to \"Spare\" (value 000)."]
    #[doc = " Maximum 2 digits."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct TriggerData {
        #[rasn(tag(context, 0), identifier = "triggerId")]
        pub trigger_id: Any,
        #[rasn(tag(context, 1), identifier = "triggerPar")]
        pub trigger_par: Any,
    }
    impl TriggerData {
        pub fn new(trigger_id: Any, trigger_par: Any) -> Self {
            Self {
                trigger_id,
                trigger_par,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct TriggerResult {
        #[rasn(tag(context, 0), identifier = "tDPIdentifer")]
        pub t_dpidentifer: Integer,
        #[rasn(tag(context, 1), identifier = "actionPerformed")]
        pub action_performed: ActionPerformed,
        #[rasn(tag(context, 2), identifier = "dPName")]
        pub d_pname: Option<EventTypeBCSM>,
    }
    impl TriggerResult {
        pub fn new(
            t_dpidentifer: Integer,
            action_performed: ActionPerformed,
            d_pname: Option<EventTypeBCSM>,
        ) -> Self {
            Self {
                t_dpidentifer,
                action_performed,
                d_pname,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TriggerStatus {
        created = 0,
        alreadyExist = 1,
        deleted = 2,
        unknownTrigger = 3,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TriggerType {
        featureActivation = 0,
        verticalServiceCode = 1,
        customizedAccess = 2,
        customizedIntercom = 3,
        emergencyService = 12,
        aFR = 13,
        sharedIOTrunk = 14,
        offHookDelay = 17,
        channelSetupPRI = 18,
        tNoAnswer = 25,
        tBusy = 26,
        oCalledPartyBusy = 27,
        oNoAnswer = 29,
        originationAttemptAuthorized = 30,
        oAnswer = 31,
        oDisconnect = 32,
        termAttemptAuthorized = 33,
        tAnswer = 34,
        tDisconnect = 35,
        oModifyRequest = 100,
        tModifyRequest = 101,
    }
    #[doc = " Its content is network signalling/operator specific"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum USIMonitorMode {
        monitoringActive = 0,
        monitoringInactive = 1,
    }
    #[doc = " In case of local its content is network signalling/operator specific"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct VPNIndicator(pub bool);
    #[doc = " defined by network operator."]
    #[doc = " Indicates the cause for holding a call."]
    #[doc = " Its content is network operator specific"]
    pub static INITIAL_CALL_SEGMENT: LazyLock<Integer> = LazyLock::new(|| Integer::from(1i128));
    pub static LEG1: LazyLock<LegType> =
        LazyLock::new(|| LegType(<OctetString as From<&'static [u8]>>::from(&[1])));
    pub static LEG2: LazyLock<LegType> =
        LazyLock::new(|| LegType(<OctetString as From<&'static [u8]>>::from(&[2])));
}
