---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_h_h450.11_2001_Call-Intrusion-Operations.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to resolve reference in object set.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod call_intrusion_operations {
    extern crate alloc;
    use super::call_hold_operations::{MixedExtension, UNDEFINED};
    use super::call_offer_operations::{CFB_OVERRIDE, REMOTE_USER_ALERTING};
    use super::call_waiting_operations::CALL_WAITING;
    use super::h323_messages::CallIdentifier;
    use super::h4501_general_error_list::{
        NOT_AVAILABLE, SUPPLEMENTARY_SERVICE_INTERACTION_NOT_ALLOWED,
    };
    use super::remote_operations_information_objects::*;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=3"))]
    pub struct CICapabilityLevel(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIFrcRelArg {
        #[rasn(identifier = "ciCapabilityLevel")]
        pub ci_capability_level: CICapabilityLevel,
        #[rasn(size("0..=255"), identifier = "argumentExtension")]
        pub argument_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIFrcRelArg {
        pub fn new(
            ci_capability_level: CICapabilityLevel,
            argument_extension: Option<SequenceOf<MixedExtension>>,
        ) -> Self {
            Self {
                ci_capability_level,
                argument_extension,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIFrcRelOptRes {
        #[rasn(size("0..=255"), identifier = "resultExtension")]
        pub result_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIFrcRelOptRes {
        pub fn new(result_extension: Option<SequenceOf<MixedExtension>>) -> Self {
            Self { result_extension }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIGetCIPLOptArg {
        #[rasn(size("0..=255"), identifier = "argumentExtension")]
        pub argument_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIGetCIPLOptArg {
        pub fn new(argument_extension: Option<SequenceOf<MixedExtension>>) -> Self {
            Self { argument_extension }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIGetCIPLRes {
        #[rasn(identifier = "ciProtectionLevel")]
        pub ci_protection_level: CIProtectionLevel,
        #[rasn(identifier = "silentMonitoringPermitted")]
        pub silent_monitoring_permitted: Option<()>,
        #[rasn(size("0..=255"), identifier = "resultExtension")]
        pub result_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIGetCIPLRes {
        pub fn new(
            ci_protection_level: CIProtectionLevel,
            silent_monitoring_permitted: Option<()>,
            result_extension: Option<SequenceOf<MixedExtension>>,
        ) -> Self {
            Self {
                ci_protection_level,
                silent_monitoring_permitted,
                result_extension,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIIsOptArg {
        #[rasn(size("0..=255"), identifier = "argumentExtension")]
        pub argument_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIIsOptArg {
        pub fn new(argument_extension: Option<SequenceOf<MixedExtension>>) -> Self {
            Self { argument_extension }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIIsOptRes {
        #[rasn(size("0..=255"), identifier = "resultExtension")]
        pub result_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIIsOptRes {
        pub fn new(result_extension: Option<SequenceOf<MixedExtension>>) -> Self {
            Self { result_extension }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CINotificationArg {
        #[rasn(identifier = "ciStatusInformation")]
        pub ci_status_information: CIStatusInformation,
        #[rasn(size("0..=255"), identifier = "argumentExtension")]
        pub argument_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CINotificationArg {
        pub fn new(
            ci_status_information: CIStatusInformation,
            argument_extension: Option<SequenceOf<MixedExtension>>,
        ) -> Self {
            Self {
                ci_status_information,
                argument_extension,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=3"))]
    pub struct CIProtectionLevel(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIRequestArg {
        #[rasn(identifier = "ciCapabilityLevel")]
        pub ci_capability_level: CICapabilityLevel,
        #[rasn(size("0..=255"), identifier = "argumentExtension")]
        pub argument_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIRequestArg {
        pub fn new(
            ci_capability_level: CICapabilityLevel,
            argument_extension: Option<SequenceOf<MixedExtension>>,
        ) -> Self {
            Self {
                ci_capability_level,
                argument_extension,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIRequestRes {
        #[rasn(identifier = "ciStatusInformation")]
        pub ci_status_information: CIStatusInformation,
        #[rasn(size("0..=255"), identifier = "resultExtension")]
        pub result_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIRequestRes {
        pub fn new(
            ci_status_information: CIStatusInformation,
            result_extension: Option<SequenceOf<MixedExtension>>,
        ) -> Self {
            Self {
                ci_status_information,
                result_extension,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CISilentArg {
        #[rasn(identifier = "ciCapabilityLevel")]
        pub ci_capability_level: CICapabilityLevel,
        #[rasn(identifier = "specificCall")]
        pub specific_call: Option<CallIdentifier>,
        #[rasn(size("0..=255"), identifier = "argumentExtension")]
        pub argument_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CISilentArg {
        pub fn new(
            ci_capability_level: CICapabilityLevel,
            specific_call: Option<CallIdentifier>,
            argument_extension: Option<SequenceOf<MixedExtension>>,
        ) -> Self {
            Self {
                ci_capability_level,
                specific_call,
                argument_extension,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CISilentOptRes {
        #[rasn(size("0..=255"), identifier = "resultExtension")]
        pub result_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CISilentOptRes {
        pub fn new(result_extension: Option<SequenceOf<MixedExtension>>) -> Self {
            Self { result_extension }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CIStatusInformation {
        callIntrusionImpending(()),
        callIntruded(()),
        callIsolated(()),
        callForceReleased(()),
        callIntrusionComplete(()),
        callIntrusionEnd(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIWobOptArg {
        #[rasn(size("0..=255"), identifier = "argumentExtension")]
        pub argument_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIWobOptArg {
        pub fn new(argument_extension: Option<SequenceOf<MixedExtension>>) -> Self {
            Self { argument_extension }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CIWobOptRes {
        #[rasn(size("0..=255"), identifier = "resultExtension")]
        pub result_extension: Option<SequenceOf<MixedExtension>>,
    }
    impl CIWobOptRes {
        pub fn new(result_extension: Option<SequenceOf<MixedExtension>>) -> Self {
            Self { result_extension }
        }
    }
}
