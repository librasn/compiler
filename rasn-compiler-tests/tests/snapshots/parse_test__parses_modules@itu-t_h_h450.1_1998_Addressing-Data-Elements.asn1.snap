---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_h_h450.1_1998_Addressing-Data-Elements.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod addressing_data_elements {
    extern crate alloc;
    use super::h323_messages::{
        AliasAddress, PartyNumber, PresentationIndicator, ScreeningIndicator,
    };
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Address {
        #[rasn(identifier = "partyNumber")]
        pub party_number: PartyNumber,
        #[rasn(identifier = "partySubaddress")]
        pub party_subaddress: Option<PartySubaddress>,
    }
    impl Address {
        pub fn new(party_number: PartyNumber, party_subaddress: Option<PartySubaddress>) -> Self {
            Self {
                party_number,
                party_subaddress,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AddressScreened {
        #[rasn(identifier = "partyNumber")]
        pub party_number: PartyNumber,
        #[rasn(identifier = "screeningIndicator")]
        pub screening_indicator: ScreeningIndicator,
        #[rasn(identifier = "partySubaddress")]
        pub party_subaddress: Option<PartySubaddress>,
    }
    impl AddressScreened {
        pub fn new(
            party_number: PartyNumber,
            screening_indicator: ScreeningIndicator,
            party_subaddress: Option<PartySubaddress>,
        ) -> Self {
            Self {
                party_number,
                screening_indicator,
                party_subaddress,
            }
        }
    }
    #[doc = " PartyNumber defined in Recommendation H.225.0"]
    #[doc = " PublicPartyNumber defined in Recommendation H.225.0"]
    #[doc = " PrivatePartyNumber defined in Recommendation H.225.0"]
    #[doc = " NumberDigits defined in Recommendation H.225.0"]
    #[doc = " PublicTypeOfNumber defined in Recommendation H.225.0"]
    #[doc = " PrivateTypeOfNumber defined in Recommendation H.225.0"]
    #[doc = " PresentationIndicator defined in Recommendation H.225.0 (v3 and beyond)"]
    #[doc = " ScreeningIndicator defined in Recommendation H.225.0 (v3 and beyond)"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EndpointAddress {
        #[rasn(identifier = "destinationAddress")]
        pub destination_address: SequenceOf<AliasAddress>,
        #[rasn(identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<AliasAddress>,
        #[rasn(
            extension_addition,
            identifier = "destinationAddressPresentationIndicator"
        )]
        pub destination_address_presentation_indicator: Option<PresentationIndicator>,
        #[rasn(
            extension_addition,
            identifier = "destinationAddressScreeningIndicator"
        )]
        pub destination_address_screening_indicator: Option<ScreeningIndicator>,
        #[rasn(
            extension_addition,
            identifier = "remoteExtensionAddressPresentationIndicator"
        )]
        pub remote_extension_address_presentation_indicator: Option<PresentationIndicator>,
        #[rasn(
            extension_addition,
            identifier = "remoteExtensionAddressScreeningIndicator"
        )]
        pub remote_extension_address_screening_indicator: Option<ScreeningIndicator>,
    }
    impl EndpointAddress {
        pub fn new(
            destination_address: SequenceOf<AliasAddress>,
            remote_extension_address: Option<AliasAddress>,
            destination_address_presentation_indicator: Option<PresentationIndicator>,
            destination_address_screening_indicator: Option<ScreeningIndicator>,
            remote_extension_address_presentation_indicator: Option<PresentationIndicator>,
            remote_extension_address_screening_indicator: Option<ScreeningIndicator>,
        ) -> Self {
            Self {
                destination_address,
                remote_extension_address,
                destination_address_presentation_indicator,
                destination_address_screening_indicator,
                remote_extension_address_presentation_indicator,
                remote_extension_address_screening_indicator,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=20"))]
    pub struct NSAPSubaddress(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NumberScreened {
        #[rasn(identifier = "partyNumber")]
        pub party_number: PartyNumber,
        #[rasn(identifier = "screeningIndicator")]
        pub screening_indicator: ScreeningIndicator,
    }
    impl NumberScreened {
        pub fn new(party_number: PartyNumber, screening_indicator: ScreeningIndicator) -> Self {
            Self {
                party_number,
                screening_indicator,
            }
        }
    }
    #[doc = " Note 1: If this element is not available, presentation allowed shall be assumed."]
    #[doc = " Note 2: If an H.450 APDU that carries this element EndpointAddress also"]
    #[doc = " contains an element PresentationAllowedIndicator, then the setting of the"]
    #[doc = " element PresentationAllowedIndicator shall take precedence in case of"]
    #[doc = " conflicting presentation information."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PartySubaddress {
        userSpecifiedSubaddress(UserSpecifiedSubaddress),
        nsapSubaddress(NSAPSubaddress),
    }
    #[doc = " coded according to user requirements. Some networks"]
    #[doc = " may limit the subaddress value to some other length"]
    #[doc = " e.g. 4 octets"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct PresentationAllowedIndicator(pub bool);
    #[doc = " see H.225.0"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PresentedAddressScreened {
        presentationAllowedAddress(AddressScreened),
        presentationRestricted(()),
        numberNotAvailableDueToInterworking(()),
        presentationRestrictedAddress(AddressScreened),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PresentedAddressUnscreened {
        presentationAllowedAddress(Address),
        presentationRestricted(()),
        numberNotAvailableDueToInterworking(()),
        presentationRestrictedAddress(Address),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PresentedNumberScreened {
        presentationAllowedAddress(NumberScreened),
        presentationRestricted(()),
        numberNotAvailableDueToInterworking(()),
        presentationRestrictedAddress(NumberScreened),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PresentedNumberUnscreened {
        presentationAllowedAddress(PartyNumber),
        presentationRestricted(()),
        numberNotAvailableDueToInterworking(()),
        presentationRestrictedAddress(PartyNumber),
    }
    #[doc = " specified according to X.213. Some networks may"]
    #[doc = " limit the subaddress value to some other length"]
    #[doc = " e.g. 4 octets"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=20"))]
    pub struct SubaddressInformation(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UserSpecifiedSubaddress {
        #[rasn(identifier = "subaddressInformation")]
        pub subaddress_information: SubaddressInformation,
        #[rasn(identifier = "oddCountIndicator")]
        pub odd_count_indicator: Option<bool>,
    }
    impl UserSpecifiedSubaddress {
        pub fn new(
            subaddress_information: SubaddressInformation,
            odd_count_indicator: Option<bool>,
        ) -> Self {
            Self {
                subaddress_information,
                odd_count_indicator,
            }
        }
    }
}
