---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x692_2002_LegacyProtocol-ASN1-Module.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod legacy_protocol_asn1_module {
    extern crate alloc;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " determined by end of PDU"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=7"))]
    pub struct A(pub u8);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum BB1 {
        e0 = 0,
        e1 = 1,
        e2 = 2,
        e3 = 3,
    }
    #[doc = " Values 5..7 are reserved for future use.  Version 1 systems should treat 5 to 7 as 4."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct B {
        pub b1: BB1,
        pub b2: bool,
        #[rasn(value("0..=3"))]
        pub b3: u8,
    }
    impl B {
        pub fn new(b1: BB1, b2: bool, b3: u8) -> Self {
            Self { b1, b2, b3 }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("0..=7"))]
    pub struct C(pub SequenceOf<CElem>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "C-elem")]
    pub struct CElem {
        #[rasn(size("4"))]
        pub c1: BitString,
        #[rasn(value("0..=1024"))]
        pub c2: u16,
    }
    impl CElem {
        pub fn new(c1: BitString, c2: u16) -> Self {
            Self { c1, c2 }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("0..=20"))]
    pub struct D(pub SequenceOf<DElem>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum DElemD2 {
        f0 = 0,
        f1 = 1,
        f2 = 2,
        f3 = 3,
        f4 = 4,
        f5 = 5,
        f6 = 6,
        f7 = 7,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "D-elem")]
    pub struct DElem {
        pub d1: bool,
        pub d2: DElemD2,
        #[rasn(value("0..=7"))]
        pub d3: u8,
    }
    impl DElem {
        pub fn new(d1: bool, d2: DElemD2, d3: u8) -> Self {
            Self { d1, d2, d3 }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum LegacyProtocolMessagesMessageId {
        message1 = 0,
        message2 = 1,
        message3 = 2,
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum LegacyProtocolMessagesMessages {
        message1(Message1),
        message2(Message2),
        message3(Message3),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct LegacyProtocolMessages {
        #[rasn(identifier = "message-id")]
        pub message_id: LegacyProtocolMessagesMessageId,
        pub messages: LegacyProtocolMessagesMessages,
    }
    impl LegacyProtocolMessages {
        pub fn new(
            message_id: LegacyProtocolMessagesMessageId,
            messages: LegacyProtocolMessagesMessages,
        ) -> Self {
            Self {
                message_id,
                messages,
            }
        }
    }
    #[doc = " The CHOICE is constrained by the value of message-id."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct Message1 {
        pub a: A,
        #[rasn(identifier = "b-flag")]
        pub b_flag: bool,
        #[rasn(value("0..=7"), identifier = "c-len")]
        pub c_len: u8,
        pub b: Option<B>,
        pub c: C,
        pub d: Option<D>,
    }
    impl Message1 {
        pub fn new(a: A, b_flag: bool, c_len: u8, b: Option<B>, c: C, d: Option<D>) -> Self {
            Self {
                a,
                b_flag,
                c_len,
                b,
                c,
                d,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct Message2 {}
    impl Message2 {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for Message2 {
        fn default() -> Self {
            Self {}
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct Message3 {}
    impl Message3 {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for Message3 {
        fn default() -> Self {
            Self {}
        }
    }
    pub static MAX_C_LEN: LazyLock<Integer> = LazyLock::new(|| Integer::from(7i128));
    pub static MAX_D_LEN: LazyLock<Integer> = LazyLock::new(|| Integer::from(20i128));
}
