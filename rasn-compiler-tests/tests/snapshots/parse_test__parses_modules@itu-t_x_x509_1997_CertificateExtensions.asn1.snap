---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x509_1997_CertificateExtensions.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to resolve supertype DirectoryString of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod certificate_extensions {
    extern crate alloc;
    use super::authentication_framework::*;
    use super::information_framework::*;
    use super::mtsabstract_service::ORAddress;
    use super::selected_attribute_types::DirectoryString;
    use super::upper_bounds::UB_NAME;
    use super::useful_definitions::{
        AUTHENTICATION_FRAMEWORK, ID_AT, ID_CE, ID_MR, INFORMATION_FRAMEWORK,
        SELECTED_ATTRIBUTE_TYPES, UPPER_BOUNDS,
    };
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum AltNameTypeBuiltinNameForm {
        rfc822Name = 1,
        dNSName = 2,
        x400Address = 3,
        directoryName = 4,
        ediPartyName = 5,
        uniformResourceIdentifier = 6,
        iPAddress = 7,
        registeredId = 8,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum AltNameType {
        builtinNameForm(AltNameTypeBuiltinNameForm),
        otherNameForm(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct AttributesSyntax(pub SequenceOf<Attribute>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct AuthorityKeyIdentifier {
        #[rasn(tag(context, 0), identifier = "keyIdentifier")]
        pub key_identifier: Option<KeyIdentifier>,
        #[rasn(tag(context, 1), identifier = "authorityCertIssuer")]
        pub authority_cert_issuer: Option<GeneralNames>,
        #[rasn(tag(context, 2), identifier = "authorityCertSerialNumber")]
        pub authority_cert_serial_number: Option<CertificateSerialNumber>,
    }
    impl AuthorityKeyIdentifier {
        pub fn new(
            key_identifier: Option<KeyIdentifier>,
            authority_cert_issuer: Option<GeneralNames>,
            authority_cert_serial_number: Option<CertificateSerialNumber>,
        ) -> Self {
            Self {
                key_identifier,
                authority_cert_issuer,
                authority_cert_serial_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct BaseCRLNumber(pub CRLNumber);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0.."))]
    pub struct BaseDistance(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct BasicConstraintsSyntax {
        #[rasn(default = "basic_constraints_syntax_c_a_default", identifier = "cA")]
        pub c_a: bool,
        #[rasn(value("0.."), identifier = "pathLenConstraint")]
        pub path_len_constraint: Option<Integer>,
    }
    impl BasicConstraintsSyntax {
        pub fn new(c_a: bool, path_len_constraint: Option<Integer>) -> Self {
            Self {
                c_a,
                path_len_constraint,
            }
        }
    }
    fn basic_constraints_syntax_c_a_default() -> bool {
        false
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct BasicNameForms(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct CRLDistPointsSyntax(pub SequenceOf<DistributionPoint>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0.."))]
    pub struct CRLNumber(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CRLReason {
        unspecified = 0,
        keyCompromise = 1,
        cACompromise = 2,
        affiliationChanged = 3,
        superseded = 4,
        cessationOfOperation = 5,
        certificateHold = 6,
        removeFromCRL = 8,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CertPolicyId(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct CertPolicySet(pub SequenceOf<CertPolicyId>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CertificateAssertion {
        #[rasn(tag(context, 0), identifier = "serialNumber")]
        pub serial_number: Option<CertificateSerialNumber>,
        #[rasn(tag(context, 1))]
        pub issuer: Option<Name>,
        #[rasn(tag(context, 2), identifier = "subjectKeyIdentifier")]
        pub subject_key_identifier: Option<SubjectKeyIdentifier>,
        #[rasn(tag(context, 3), identifier = "authorityKeyIdentifier")]
        pub authority_key_identifier: Option<AuthorityKeyIdentifier>,
        #[rasn(tag(context, 4), identifier = "certificateValid")]
        pub certificate_valid: Option<Time>,
        #[rasn(tag(context, 5), identifier = "privateKeyValid")]
        pub private_key_valid: Option<GeneralizedTime>,
        #[rasn(tag(context, 6), identifier = "subjectPublicKeyAlgID")]
        pub subject_public_key_alg_id: Option<ObjectIdentifier>,
        #[rasn(tag(context, 7), identifier = "keyUsage")]
        pub key_usage: Option<KeyUsage>,
        #[rasn(tag(context, 8), identifier = "subjectAltName")]
        pub subject_alt_name: Option<AltNameType>,
        #[rasn(tag(context, 9))]
        pub policy: Option<CertPolicySet>,
        #[rasn(tag(context, 10), identifier = "pathToName")]
        pub path_to_name: Option<Name>,
    }
    impl CertificateAssertion {
        pub fn new(
            serial_number: Option<CertificateSerialNumber>,
            issuer: Option<Name>,
            subject_key_identifier: Option<SubjectKeyIdentifier>,
            authority_key_identifier: Option<AuthorityKeyIdentifier>,
            certificate_valid: Option<Time>,
            private_key_valid: Option<GeneralizedTime>,
            subject_public_key_alg_id: Option<ObjectIdentifier>,
            key_usage: Option<KeyUsage>,
            subject_alt_name: Option<AltNameType>,
            policy: Option<CertPolicySet>,
            path_to_name: Option<Name>,
        ) -> Self {
            Self {
                serial_number,
                issuer,
                subject_key_identifier,
                authority_key_identifier,
                certificate_valid,
                private_key_valid,
                subject_public_key_alg_id,
                key_usage,
                subject_alt_name,
                policy,
                path_to_name,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CertificateExactAssertion {
        #[rasn(identifier = "serialNumber")]
        pub serial_number: CertificateSerialNumber,
        pub issuer: Name,
    }
    impl CertificateExactAssertion {
        pub fn new(serial_number: CertificateSerialNumber, issuer: Name) -> Self {
            Self {
                serial_number,
                issuer,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CertificateListAssertion {
        pub issuer: Option<Name>,
        #[rasn(tag(context, 0), identifier = "minCRLNumber")]
        pub min_crlnumber: Option<CRLNumber>,
        #[rasn(tag(context, 1), identifier = "maxCRLNumber")]
        pub max_crlnumber: Option<CRLNumber>,
        #[rasn(identifier = "reasonFlags")]
        pub reason_flags: Option<ReasonFlags>,
        #[rasn(identifier = "dateAndTime")]
        pub date_and_time: Option<Time>,
        #[rasn(tag(context, 2), identifier = "distributionPoint")]
        pub distribution_point: Option<DistributionPointName>,
    }
    impl CertificateListAssertion {
        pub fn new(
            issuer: Option<Name>,
            min_crlnumber: Option<CRLNumber>,
            max_crlnumber: Option<CRLNumber>,
            reason_flags: Option<ReasonFlags>,
            date_and_time: Option<Time>,
            distribution_point: Option<DistributionPointName>,
        ) -> Self {
            Self {
                issuer,
                min_crlnumber,
                max_crlnumber,
                reason_flags,
                date_and_time,
                distribution_point,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CertificateListExactAssertion {
        pub issuer: Name,
        #[rasn(identifier = "thisUpdate")]
        pub this_update: Time,
        #[rasn(identifier = "distributionPoint")]
        pub distribution_point: Option<DistributionPointName>,
    }
    impl CertificateListExactAssertion {
        pub fn new(
            issuer: Name,
            this_update: Time,
            distribution_point: Option<DistributionPointName>,
        ) -> Self {
            Self {
                issuer,
                this_update,
                distribution_point,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CertificatePairAssertion {
        #[rasn(tag(context, 0), identifier = "forwardAssertion")]
        pub forward_assertion: Option<CertificateAssertion>,
        #[rasn(tag(context, 1), identifier = "reverseAssertion")]
        pub reverse_assertion: Option<CertificateAssertion>,
    }
    impl CertificatePairAssertion {
        pub fn new(
            forward_assertion: Option<CertificateAssertion>,
            reverse_assertion: Option<CertificateAssertion>,
        ) -> Self {
            Self {
                forward_assertion,
                reverse_assertion,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CertificatePairExactAssertion {
        #[rasn(tag(context, 0), identifier = "forwardAssertion")]
        pub forward_assertion: Option<CertificateExactAssertion>,
        #[rasn(tag(context, 1), identifier = "reverseAssertion")]
        pub reverse_assertion: Option<CertificateExactAssertion>,
    }
    impl CertificatePairExactAssertion {
        pub fn new(
            forward_assertion: Option<CertificateExactAssertion>,
            reverse_assertion: Option<CertificateExactAssertion>,
        ) -> Self {
            Self {
                forward_assertion,
                reverse_assertion,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct CertificatePoliciesSyntax(pub SequenceOf<PolicyInformation>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct DistributionPoint {
        #[rasn(tag(context, 0), identifier = "distributionPoint")]
        pub distribution_point: Option<DistributionPointName>,
        #[rasn(tag(context, 1))]
        pub reasons: Option<ReasonFlags>,
        #[rasn(tag(context, 2), identifier = "cRLIssuer")]
        pub c_rlissuer: Option<GeneralNames>,
    }
    impl DistributionPoint {
        pub fn new(
            distribution_point: Option<DistributionPointName>,
            reasons: Option<ReasonFlags>,
            c_rlissuer: Option<GeneralNames>,
        ) -> Self {
            Self {
                distribution_point,
                reasons,
                c_rlissuer,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum DistributionPointName {
        #[rasn(tag(context, 0))]
        fullName(GeneralNames),
        #[rasn(tag(context, 1))]
        nameRelativeToCRLIssuer(RelativeDistinguishedName),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct EDIPartyName {
        #[rasn(value("0.."), tag(context, 0), identifier = "nameAssigner")]
        pub name_assigner: Option<DirectoryString>,
        #[rasn(value("0.."), tag(context, 1), identifier = "partyName")]
        pub party_name: DirectoryString,
    }
    impl EDIPartyName {
        pub fn new(name_assigner: Option<DirectoryString>, party_name: DirectoryString) -> Self {
            Self {
                name_assigner,
                party_name,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum GeneralName {
        #[rasn(tag(context, 0))]
        otherName(INSTANCE),
        OF(OTHERNAME),
        #[rasn(tag(context, 1))]
        rfc822Name(Ia5String),
        #[rasn(tag(context, 2))]
        dNSName(Ia5String),
        #[rasn(tag(context, 3))]
        x400Address(ORAddress),
        #[rasn(tag(context, 4))]
        directoryName(Name),
        #[rasn(tag(context, 5))]
        ediPartyName(EDIPartyName),
        #[rasn(tag(context, 6))]
        uniformResourceIdentifier(Ia5String),
        #[rasn(tag(context, 7))]
        iPAddress(OctetString),
        #[rasn(tag(context, 8))]
        registeredID(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct GeneralNames(pub SequenceOf<GeneralName>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct GeneralSubtree {
        pub base: GeneralName,
        #[rasn(tag(context, 0), default = "general_subtree_minimum_default")]
        pub minimum: BaseDistance,
        #[rasn(tag(context, 1))]
        pub maximum: Option<BaseDistance>,
    }
    impl GeneralSubtree {
        pub fn new(
            base: GeneralName,
            minimum: BaseDistance,
            maximum: Option<BaseDistance>,
        ) -> Self {
            Self {
                base,
                minimum,
                maximum,
            }
        }
    }
    fn general_subtree_minimum_default() -> BaseDistance {
        BaseDistance(Integer::from(0))
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct GeneralSubtrees(pub SequenceOf<GeneralSubtree>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct HoldInstruction(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct IssuingDistPointSyntax {
        #[rasn(tag(context, 0), identifier = "distributionPoint")]
        pub distribution_point: Option<DistributionPointName>,
        #[rasn(
            tag(context, 1),
            default = "issuing_dist_point_syntax_only_contains_user_certs_default",
            identifier = "onlyContainsUserCerts"
        )]
        pub only_contains_user_certs: bool,
        #[rasn(
            tag(context, 2),
            default = "issuing_dist_point_syntax_only_contains_cacerts_default",
            identifier = "onlyContainsCACerts"
        )]
        pub only_contains_cacerts: bool,
        #[rasn(tag(context, 3), identifier = "onlySomeReasons")]
        pub only_some_reasons: Option<ReasonFlags>,
        #[rasn(
            tag(context, 4),
            default = "issuing_dist_point_syntax_indirect_crl_default",
            identifier = "indirectCRL"
        )]
        pub indirect_crl: bool,
    }
    impl IssuingDistPointSyntax {
        pub fn new(
            distribution_point: Option<DistributionPointName>,
            only_contains_user_certs: bool,
            only_contains_cacerts: bool,
            only_some_reasons: Option<ReasonFlags>,
            indirect_crl: bool,
        ) -> Self {
            Self {
                distribution_point,
                only_contains_user_certs,
                only_contains_cacerts,
                only_some_reasons,
                indirect_crl,
            }
        }
    }
    fn issuing_dist_point_syntax_only_contains_user_certs_default() -> bool {
        false
    }
    fn issuing_dist_point_syntax_only_contains_cacerts_default() -> bool {
        false
    }
    fn issuing_dist_point_syntax_indirect_crl_default() -> bool {
        false
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct KeyIdentifier(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct KeyPurposeId(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct KeyUsage(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct NameConstraintsSyntax {
        #[rasn(tag(context, 0), identifier = "permittedSubtrees")]
        pub permitted_subtrees: Option<GeneralSubtrees>,
        #[rasn(tag(context, 1), identifier = "excludedSubtrees")]
        pub excluded_subtrees: Option<GeneralSubtrees>,
        #[rasn(tag(context, 2), identifier = "requiredNameForms")]
        pub required_name_forms: Option<NameForms>,
    }
    impl NameConstraintsSyntax {
        pub fn new(
            permitted_subtrees: Option<GeneralSubtrees>,
            excluded_subtrees: Option<GeneralSubtrees>,
            required_name_forms: Option<NameForms>,
        ) -> Self {
            Self {
                permitted_subtrees,
                excluded_subtrees,
                required_name_forms,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct NameForms {
        #[rasn(tag(context, 0), identifier = "basicNameForms")]
        pub basic_name_forms: Option<BasicNameForms>,
        #[rasn(size("1.."), tag(context, 1), identifier = "otherNameForms")]
        pub other_name_forms: Option<SequenceOf<ObjectIdentifier>>,
    }
    impl NameForms {
        pub fn new(
            basic_name_forms: Option<BasicNameForms>,
            other_name_forms: Option<SequenceOf<ObjectIdentifier>>,
        ) -> Self {
            Self {
                basic_name_forms,
                other_name_forms,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct PolicyConstraintsSyntax {
        #[rasn(tag(context, 0), identifier = "requireExplicitPolicy")]
        pub require_explicit_policy: Option<SkipCerts>,
        #[rasn(tag(context, 1), identifier = "inhibitPolicyMapping")]
        pub inhibit_policy_mapping: Option<SkipCerts>,
    }
    impl PolicyConstraintsSyntax {
        pub fn new(
            require_explicit_policy: Option<SkipCerts>,
            inhibit_policy_mapping: Option<SkipCerts>,
        ) -> Self {
            Self {
                require_explicit_policy,
                inhibit_policy_mapping,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct PolicyInformation {
        #[rasn(identifier = "policyIdentifier")]
        pub policy_identifier: CertPolicyId,
        #[rasn(size("1.."), identifier = "policyQualifiers")]
        pub policy_qualifiers: Option<SequenceOf<PolicyQualifierInfo>>,
    }
    impl PolicyInformation {
        pub fn new(
            policy_identifier: CertPolicyId,
            policy_qualifiers: Option<SequenceOf<PolicyQualifierInfo>>,
        ) -> Self {
            Self {
                policy_identifier,
                policy_qualifiers,
            }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousPolicyMappingsSyntax {
        #[rasn(identifier = "issuerDomainPolicy")]
        pub issuer_domain_policy: CertPolicyId,
        #[rasn(identifier = "subjectDomainPolicy")]
        pub subject_domain_policy: CertPolicyId,
    }
    impl AnonymousPolicyMappingsSyntax {
        pub fn new(
            issuer_domain_policy: CertPolicyId,
            subject_domain_policy: CertPolicyId,
        ) -> Self {
            Self {
                issuer_domain_policy,
                subject_domain_policy,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1.."))]
    pub struct PolicyMappingsSyntax(pub SequenceOf<AnonymousPolicyMappingsSyntax>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct PolicyQualifierInfo {
        #[rasn(identifier = "policyQualifierId")]
        pub policy_qualifier_id: ObjectIdentifier,
        pub qualifier: Option<Any>,
    }
    impl PolicyQualifierInfo {
        pub fn new(policy_qualifier_id: ObjectIdentifier, qualifier: Option<Any>) -> Self {
            Self {
                policy_qualifier_id,
                qualifier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct PrivateKeyUsagePeriod {
        #[rasn(tag(context, 0), identifier = "notBefore")]
        pub not_before: Option<GeneralizedTime>,
        #[rasn(tag(context, 1), identifier = "notAfter")]
        pub not_after: Option<GeneralizedTime>,
    }
    impl PrivateKeyUsagePeriod {
        pub fn new(
            not_before: Option<GeneralizedTime>,
            not_after: Option<GeneralizedTime>,
        ) -> Self {
            Self {
                not_before,
                not_after,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ReasonFlags(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0.."))]
    pub struct SkipCerts(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SubjectKeyIdentifier(pub KeyIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SupportedAlgorithm {
        #[rasn(identifier = "algorithmIdentifier")]
        pub algorithm_identifier: AlgorithmIdentifier,
        #[rasn(tag(context, 0), identifier = "intendedUsage")]
        pub intended_usage: Option<KeyUsage>,
        #[rasn(tag(context, 1), identifier = "intendedCertificatePolicies")]
        pub intended_certificate_policies: Option<CertificatePoliciesSyntax>,
    }
    impl SupportedAlgorithm {
        pub fn new(
            algorithm_identifier: AlgorithmIdentifier,
            intended_usage: Option<KeyUsage>,
            intended_certificate_policies: Option<CertificatePoliciesSyntax>,
        ) -> Self {
            Self {
                algorithm_identifier,
                intended_usage,
                intended_certificate_policies,
            }
        }
    }
    pub static ID_AT_DELTA_REVOCATION_LIST: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[53u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = "  Object identifier assignments"]
    pub static ID_AT_SUPPORTED_ALGORITHMS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_AT, &[52u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = "  deprecated\t\t\t\t\t\tOBJECT IDENTIFIER\t::=\t{id-ce 34}"]
    pub static ID_CE_AUTHORITY_KEY_IDENTIFIER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[35u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_BASIC_CONSTRAINTS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[19u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_C_RLDISTRIBUTION_POINTS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[31u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_C_RLNUMBER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[20u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_CERTIFICATE_ISSUER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[29u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_CERTIFICATE_POLICIES: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[32u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_DELTA_CRLINDICATOR: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[27u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_EXT_KEY_USAGE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[37u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_INHIBIT_ANY_POLICY: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[54u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_INSTRUCTION_CODE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[23u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_INVALIDITY_DATE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[24u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_ISSUER_ALT_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[18u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_ISSUING_DISTRIBUTION_POINT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[28u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_KEY_USAGE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[15u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_NAME_CONSTRAINT: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[30u32, 1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_POLICY_CONSTRAINTS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[36u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_POLICY_MAPPINGS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[33u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_PRIVATE_KEY_USAGE_PERIOD: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[16u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_REASON_CODE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[21u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_SUBJECT_ALT_NAME: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[17u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_CE_SUBJECT_DIRECTORY_ATTRIBUTES: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***ID_CE, &[9u32]].concat()).unwrap().to_owned());
    pub static ID_CE_SUBJECT_KEY_IDENTIFIER: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_CE, &[14u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_ALGORITHM_IDENTIFIER_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[40u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_CERTIFICATE_EXACT_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[34u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_CERTIFICATE_LIST_EXACT_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[38u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_CERTIFICATE_LIST_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[39u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_CERTIFICATE_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[35u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ID_MR_CERTIFICATE_PAIR_EXACT_MATCH: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ID_MR, &[36u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ID_MR_CERTIFICATE_PAIR_MATCH: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ID_MR, &[37u32]].concat())
            .unwrap()
            .to_owned()
    });
}
