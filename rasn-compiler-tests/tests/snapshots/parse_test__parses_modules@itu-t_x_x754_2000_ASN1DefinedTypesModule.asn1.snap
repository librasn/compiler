---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x754_2000_ASN1DefinedTypesModule.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod asn1_defined_types_module {
    extern crate alloc;
    use super::attribute_asn1_module::{
        AdministrativeState, CapacityAlarmThreshold, Destination, LogFullAction, LogRecordId,
        ManagementExtension, OperationalState,
    };
    use super::cmip_1::{Attribute, ObjectClass, ObjectInstance};
    use super::metric_module::TimePeriod;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AgingPeriod(pub TimePeriod);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GetDestinationArgument(pub SequenceOf<LogRecordId>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GetDestinationResult(pub SequenceOf<SendToList>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0.."))]
    pub struct NonNegativeInteger(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct QueueSize(pub NonNegativeInteger);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum QueuingDiscipline {
        fifoTransmission = 0,
        lifoTransmission = 1,
    }
    #[doc = " contains a count of the number of records"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RecordIdList(pub SequenceOf<NonNegativeInteger>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct SendToList {
        #[rasn(identifier = "recordId")]
        pub record_id: LogRecordId,
        #[rasn(identifier = "destinationList")]
        pub destination_list: SetOf<Destination>,
    }
    impl SendToList {
        pub fn new(record_id: LogRecordId, destination_list: SetOf<Destination>) -> Self {
            Self {
                record_id,
                destination_list,
            }
        }
    }
    pub static EEC_ACTION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***INFORMATION_MODEL, &[9u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static EEC_ATTRIBUTE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***INFORMATION_MODEL, &[7u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static EEC_BEHAVIOUR: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***INFORMATION_MODEL, &[11u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static EEC_MANAGED_OBJECT_CLASS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***INFORMATION_MODEL, &[3u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static EEC_NAME_BINDING: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***INFORMATION_MODEL, &[6u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static EEC_NOTIFICATION: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***INFORMATION_MODEL, &[10u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static EEC_PACKAGE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***INFORMATION_MODEL, &[4u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = " OBJECT IDENTIFIERS"]
    pub static INFORMATION_MODEL: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[0u32, 0u32, 24u32, 754u32, 0u32]).to_owned());
}
