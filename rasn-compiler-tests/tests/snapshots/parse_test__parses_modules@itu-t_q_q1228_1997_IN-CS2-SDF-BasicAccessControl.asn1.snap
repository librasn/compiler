---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_q_q1228_1997_IN-CS2-SDF-BasicAccessControl.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to resolve supertype DirectoryString of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod in_cs2_sdf_basic_access_control {
    extern crate alloc;
    use super::basic_access_control::{
        AttributeTypeAndValue, AuthenticationLevel, MaxValueCount, Precedence, RestrictedValue,
    };
    use super::directory_abstract_service::Filter;
    use super::in_cs2_object_identifiers::{
        ID_ACA_ENTRY_ACI, ID_ACA_PRESCRIPTIVE_ACI, ID_ACA_SUBENTRY_ACI, SDF_INFORMATION_FRAMEWORK,
    };
    use super::in_cs2_sdf_information_framework::*;
    use super::information_framework::*;
    use super::selected_attribute_types::{
        DirectoryString, NameAndOptionalUID, DIRECTORY_STRING_FIRST_COMPONENT_MATCH,
    };
    use super::upper_bounds::UB_TAG;
    use super::useful_definitions::{
        BASIC_ACCESS_CONTROL, DIRECTORY_ABSTRACT_SERVICE, INFORMATION_FRAMEWORK,
        SELECTED_ATTRIBUTE_TYPES, UPPER_BOUNDS,
    };
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ACIItemItemOrUserFirstItemFirst {
        #[rasn(identifier = "protectedItems")]
        pub protected_items: ProtectedItems,
        #[rasn(identifier = "itemPermissions")]
        pub item_permissions: SetOf<ItemPermission>,
    }
    impl ACIItemItemOrUserFirstItemFirst {
        pub fn new(
            protected_items: ProtectedItems,
            item_permissions: SetOf<ItemPermission>,
        ) -> Self {
            Self {
                protected_items,
                item_permissions,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ACIItemItemOrUserFirstUserFirst {
        #[rasn(identifier = "userClasses")]
        pub user_classes: UserClasses,
        #[rasn(identifier = "userPermissions")]
        pub user_permissions: SetOf<UserPermission>,
    }
    impl ACIItemItemOrUserFirstUserFirst {
        pub fn new(user_classes: UserClasses, user_permissions: SetOf<UserPermission>) -> Self {
            Self {
                user_classes,
                user_permissions,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ACIItemItemOrUserFirst {
        #[rasn(tag(context, 0))]
        itemFirst(ACIItemItemOrUserFirstItemFirst),
        #[rasn(tag(context, 1))]
        userFirst(ACIItemItemOrUserFirstUserFirst),
    }
    #[doc = " types"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ACIItem {
        #[rasn(value("0.."), identifier = "identificationTag")]
        pub identification_tag: DirectoryString,
        pub precedence: Precedence,
        #[rasn(identifier = "authenticationLevel")]
        pub authentication_level: AuthenticationLevel,
        #[rasn(identifier = "itemOrUserFirst")]
        pub item_or_user_first: ACIItemItemOrUserFirst,
    }
    impl ACIItem {
        pub fn new(
            identification_tag: DirectoryString,
            precedence: Precedence,
            authentication_level: AuthenticationLevel,
            item_or_user_first: ACIItemItemOrUserFirst,
        ) -> Self {
            Self {
                identification_tag,
                precedence,
                authentication_level,
                item_or_user_first,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GrantsAndDenials(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ItemPermission {
        pub precedence: Option<Precedence>,
        #[rasn(identifier = "userClasses")]
        pub user_classes: UserClasses,
        #[rasn(identifier = "grantsAndDenials")]
        pub grants_and_denials: GrantsAndDenials,
    }
    impl ItemPermission {
        pub fn new(
            precedence: Option<Precedence>,
            user_classes: UserClasses,
            grants_and_denials: GrantsAndDenials,
        ) -> Self {
            Self {
                precedence,
                user_classes,
                grants_and_denials,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct MethodIDs(pub Any);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ProtectedItems {
        #[rasn(tag(context, 0))]
        pub entry: Option<()>,
        #[rasn(tag(context, 1), identifier = "allUserAttributeTypes")]
        pub all_user_attribute_types: Option<()>,
        #[rasn(tag(context, 2), identifier = "attributeType")]
        pub attribute_type: Option<SetOf<AttributeType>>,
        #[rasn(tag(context, 3), identifier = "allAttributeValues")]
        pub all_attribute_values: Option<SetOf<AttributeType>>,
        #[rasn(tag(context, 4), identifier = "allUserAttributeTypesAndValues")]
        pub all_user_attribute_types_and_values: Option<()>,
        #[rasn(tag(context, 5), identifier = "attributeValue")]
        pub attribute_value: Option<SetOf<AttributeTypeAndValue>>,
        #[rasn(tag(context, 6), identifier = "selfValue")]
        pub self_value: Option<SetOf<AttributeType>>,
        #[rasn(tag(context, 7), identifier = "rangeOfValues")]
        pub range_of_values: Option<Filter>,
        #[rasn(tag(context, 8), identifier = "maxValueCount")]
        pub max_value_count: Option<SetOf<MaxValueCount>>,
        #[rasn(tag(context, 9), identifier = "maxImmSub")]
        pub max_imm_sub: Option<Integer>,
        #[rasn(tag(context, 10), identifier = "restrictedBy")]
        pub restricted_by: Option<SetOf<RestrictedValue>>,
        #[rasn(tag(context, 11))]
        pub contexts: Option<SetOf<ContextAssertion>>,
        #[rasn(tag(context, 30), identifier = "entryMethods")]
        pub entry_methods: Option<SetOf<MethodIDs>>,
    }
    impl ProtectedItems {
        pub fn new(
            entry: Option<()>,
            all_user_attribute_types: Option<()>,
            attribute_type: Option<SetOf<AttributeType>>,
            all_attribute_values: Option<SetOf<AttributeType>>,
            all_user_attribute_types_and_values: Option<()>,
            attribute_value: Option<SetOf<AttributeTypeAndValue>>,
            self_value: Option<SetOf<AttributeType>>,
            range_of_values: Option<Filter>,
            max_value_count: Option<SetOf<MaxValueCount>>,
            max_imm_sub: Option<Integer>,
            restricted_by: Option<SetOf<RestrictedValue>>,
            contexts: Option<SetOf<ContextAssertion>>,
            entry_methods: Option<SetOf<MethodIDs>>,
        ) -> Self {
            Self {
                entry,
                all_user_attribute_types,
                attribute_type,
                all_attribute_values,
                all_user_attribute_types_and_values,
                attribute_value,
                self_value,
                range_of_values,
                max_value_count,
                max_imm_sub,
                restricted_by,
                contexts,
                entry_methods,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct UserClasses {
        #[rasn(tag(context, 0), identifier = "allUsers")]
        pub all_users: Option<()>,
        #[rasn(tag(context, 1), identifier = "thisEntry")]
        pub this_entry: Option<()>,
        #[rasn(tag(context, 2))]
        pub name: Option<SetOf<NameAndOptionalUID>>,
        #[rasn(tag(context, 3), identifier = "userGroup")]
        pub user_group: Option<SetOf<NameAndOptionalUID>>,
        #[rasn(tag(context, 4))]
        pub subtree: Option<SetOf<SubtreeSpecification>>,
    }
    impl UserClasses {
        pub fn new(
            all_users: Option<()>,
            this_entry: Option<()>,
            name: Option<SetOf<NameAndOptionalUID>>,
            user_group: Option<SetOf<NameAndOptionalUID>>,
            subtree: Option<SetOf<SubtreeSpecification>>,
        ) -> Self {
            Self {
                all_users,
                this_entry,
                name,
                user_group,
                subtree,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct UserPermission {
        pub precedence: Option<Precedence>,
        #[rasn(identifier = "protectedItems")]
        pub protected_items: ProtectedItems,
        #[rasn(identifier = "grantsAndDenials")]
        pub grants_and_denials: GrantsAndDenials,
    }
    impl UserPermission {
        pub fn new(
            precedence: Option<Precedence>,
            protected_items: ProtectedItems,
            grants_and_denials: GrantsAndDenials,
        ) -> Self {
            Self {
                precedence,
                protected_items,
                grants_and_denials,
            }
        }
    }
}
