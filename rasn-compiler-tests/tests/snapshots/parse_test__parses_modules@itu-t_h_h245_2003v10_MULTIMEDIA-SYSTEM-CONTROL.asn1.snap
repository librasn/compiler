---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_h_h245_2003v10_MULTIMEDIA-SYSTEM-CONTROL.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod multimedia_system_control {
    extern crate alloc;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ATMParameters {
        #[rasn(value("0..=65535"), identifier = "maxNTUSize")]
        pub max_ntusize: u16,
        #[rasn(identifier = "atmUBR")]
        pub atm_ubr: bool,
        #[rasn(identifier = "atmrtVBR")]
        pub atmrt_vbr: bool,
        #[rasn(identifier = "atmnrtVBR")]
        pub atmnrt_vbr: bool,
        #[rasn(identifier = "atmABR")]
        pub atm_abr: bool,
        #[rasn(identifier = "atmCBR")]
        pub atm_cbr: bool,
    }
    impl ATMParameters {
        pub fn new(
            max_ntusize: u16,
            atm_ubr: bool,
            atmrt_vbr: bool,
            atmnrt_vbr: bool,
            atm_abr: bool,
            atm_cbr: bool,
        ) -> Self {
            Self {
                max_ntusize,
                atm_ubr,
                atmrt_vbr,
                atmnrt_vbr,
                atm_abr,
                atm_cbr,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=256"))]
    pub struct AlternativeCapabilitySet(pub SequenceOf<CapabilityTableEntryNumber>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct AudioCapabilityG7231 {
        #[rasn(value("1..=256"), identifier = "maxAl-sduAudioFrames")]
        pub max_al_sdu_audio_frames: u16,
        #[rasn(identifier = "silenceSuppression")]
        pub silence_suppression: bool,
    }
    impl AudioCapabilityG7231 {
        pub fn new(max_al_sdu_audio_frames: u16, silence_suppression: bool) -> Self {
            Self {
                max_al_sdu_audio_frames,
                silence_suppression,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability exchange definitions: Audio capabilities"]
    #[doc = " ==================================================================================="]
    #[doc = " For an H.222 multiplex, the integers indicate the size of the STD buffer in units of 256 octets"]
    #[doc = " For an H.223 multiplex, the integers indicate the maximum number of audio frames per AL-SDU"]
    #[doc = " For an H.225.0 multiplex, the integers indicate the maximum number of audio frames per packet"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AudioCapability {
        nonStandard(NonStandardParameter),
        #[rasn(value("1..=256"))]
        g711Alaw64k(u16),
        #[rasn(value("1..=256"))]
        g711Alaw56k(u16),
        #[rasn(value("1..=256"))]
        g711Ulaw64k(u16),
        #[rasn(value("1..=256"))]
        g711Ulaw56k(u16),
        #[rasn(value("1..=256"), identifier = "g722-64k")]
        g722_64k(u16),
        #[rasn(value("1..=256"), identifier = "g722-56k")]
        g722_56k(u16),
        #[rasn(value("1..=256"), identifier = "g722-48k")]
        g722_48k(u16),
        g7231(AudioCapabilityG7231),
        #[rasn(value("1..=256"))]
        g728(u16),
        #[rasn(value("1..=256"))]
        g729(u16),
        #[rasn(value("1..=256"))]
        g729AnnexA(u16),
        is11172AudioCapability(IS11172AudioCapability),
        is13818AudioCapability(IS13818AudioCapability),
        #[rasn(extension_addition, value("1..=256"))]
        g729wAnnexB(u16),
        #[rasn(extension_addition, value("1..=256"))]
        g729AnnexAwAnnexB(u16),
        #[rasn(extension_addition)]
        g7231AnnexCCapability(G7231AnnexCCapability),
        #[rasn(extension_addition)]
        gsmFullRate(GSMAudioCapability),
        #[rasn(extension_addition)]
        gsmHalfRate(GSMAudioCapability),
        #[rasn(extension_addition)]
        gsmEnhancedFullRate(GSMAudioCapability),
        #[rasn(extension_addition)]
        genericAudioCapability(GenericCapability),
        #[rasn(extension_addition)]
        g729Extensions(G729Extensions),
        #[rasn(extension_addition)]
        vbd(VBDCapability),
        #[rasn(extension_addition)]
        audioTelephonyEvent(NoPTAudioTelephonyEventCapability),
        #[rasn(extension_addition)]
        audioTone(NoPTAudioToneCapability),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum AudioModeG7231 {
        noSilenceSuppressionLowRate(()),
        noSilenceSuppressionHighRate(()),
        silenceSuppressionLowRate(()),
        silenceSuppressionHighRate(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Request mode definitions: Audio modes"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AudioMode {
        nonStandard(NonStandardParameter),
        g711Alaw64k(()),
        g711Alaw56k(()),
        g711Ulaw64k(()),
        g711Ulaw56k(()),
        #[rasn(identifier = "g722-64k")]
        g722_64k(()),
        #[rasn(identifier = "g722-56k")]
        g722_56k(()),
        #[rasn(identifier = "g722-48k")]
        g722_48k(()),
        g728(()),
        g729(()),
        g729AnnexA(()),
        g7231(AudioModeG7231),
        is11172AudioMode(IS11172AudioMode),
        is13818AudioMode(IS13818AudioMode),
        #[rasn(extension_addition, value("1..=256"))]
        g729wAnnexB(u16),
        #[rasn(extension_addition, value("1..=256"))]
        g729AnnexAwAnnexB(u16),
        #[rasn(extension_addition)]
        g7231AnnexCMode(G7231AnnexCMode),
        #[rasn(extension_addition)]
        gsmFullRate(GSMAudioCapability),
        #[rasn(extension_addition)]
        gsmHalfRate(GSMAudioCapability),
        #[rasn(extension_addition)]
        gsmEnhancedFullRate(GSMAudioCapability),
        #[rasn(extension_addition)]
        genericAudioMode(GenericCapability),
        #[rasn(extension_addition)]
        g729Extensions(G729Extensions),
        #[rasn(extension_addition)]
        vbd(VBDMode),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability Exchange Definitions: AudioTelephonyEventCapability and AudioToneCapability"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AudioTelephonyEventCapability {
        #[rasn(value("96..=127"), identifier = "dynamicRTPPayloadType")]
        pub dynamic_rtppayload_type: u8,
        #[rasn(identifier = "audioTelephoneEvent")]
        pub audio_telephone_event: GeneralString,
    }
    impl AudioTelephonyEventCapability {
        pub fn new(dynamic_rtppayload_type: u8, audio_telephone_event: GeneralString) -> Self {
            Self {
                dynamic_rtppayload_type,
                audio_telephone_event,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AudioToneCapability {
        #[rasn(value("96..=127"), identifier = "dynamicRTPPayloadType")]
        pub dynamic_rtppayload_type: u8,
    }
    impl AudioToneCapability {
        pub fn new(dynamic_rtppayload_type: u8) -> Self {
            Self {
                dynamic_rtppayload_type,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AuthenticationCapability {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "antiSpamAlgorithm")]
        pub anti_spam_algorithm: Option<ObjectIdentifier>,
    }
    impl AuthenticationCapability {
        pub fn new(
            non_standard: Option<NonStandardParameter>,
            anti_spam_algorithm: Option<ObjectIdentifier>,
        ) -> Self {
            Self {
                non_standard,
                anti_spam_algorithm,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BEnhancementParameters {
        #[rasn(identifier = "enhancementOptions")]
        pub enhancement_options: EnhancementOptions,
        #[rasn(value("1..=64"), identifier = "numberOfBPictures")]
        pub number_of_bpictures: u8,
    }
    impl BEnhancementParameters {
        pub fn new(enhancement_options: EnhancementOptions, number_of_bpictures: u8) -> Self {
            Self {
                enhancement_options,
                number_of_bpictures,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CRCLength {
        crc8bit(()),
        crc16bit(()),
        crc32bit(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CapabilityH233EncryptionReceiveCapability {
        #[rasn(value("0..=255"), identifier = "h233IVResponseTime")]
        pub h233_ivresponse_time: u8,
    }
    impl CapabilityH233EncryptionReceiveCapability {
        pub fn new(h233_ivresponse_time: u8) -> Self {
            Self {
                h233_ivresponse_time,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability exchange definitions: top level capability description"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum Capability {
        nonStandard(NonStandardParameter),
        receiveVideoCapability(VideoCapability),
        transmitVideoCapability(VideoCapability),
        receiveAndTransmitVideoCapability(VideoCapability),
        receiveAudioCapability(AudioCapability),
        transmitAudioCapability(AudioCapability),
        receiveAndTransmitAudioCapability(AudioCapability),
        receiveDataApplicationCapability(DataApplicationCapability),
        transmitDataApplicationCapability(DataApplicationCapability),
        receiveAndTransmitDataApplicationCapability(DataApplicationCapability),
        h233EncryptionTransmitCapability(bool),
        h233EncryptionReceiveCapability(CapabilityH233EncryptionReceiveCapability),
        #[rasn(extension_addition)]
        conferenceCapability(ConferenceCapability),
        #[rasn(extension_addition)]
        h235SecurityCapability(H235SecurityCapability),
        #[rasn(extension_addition, value("0..=255"))]
        maxPendingReplacementFor(u8),
        #[rasn(extension_addition)]
        receiveUserInputCapability(UserInputCapability),
        #[rasn(extension_addition)]
        transmitUserInputCapability(UserInputCapability),
        #[rasn(extension_addition)]
        receiveAndTransmitUserInputCapability(UserInputCapability),
        #[rasn(extension_addition)]
        genericControlCapability(GenericCapability),
        #[rasn(extension_addition)]
        receiveMultiplexedStreamCapability(MultiplexedStreamCapability),
        #[rasn(extension_addition)]
        transmitMultiplexedStreamCapability(MultiplexedStreamCapability),
        #[rasn(extension_addition)]
        receiveAndTransmitMultiplexedStreamCapability(MultiplexedStreamCapability),
        #[rasn(extension_addition)]
        receiveRTPAudioTelephonyEventCapability(AudioTelephonyEventCapability),
        #[rasn(extension_addition)]
        receiveRTPAudioToneCapability(AudioToneCapability),
        #[rasn(extension_addition)]
        fecCapability(FECCapability),
        #[rasn(extension_addition)]
        multiplePayloadStreamCapability(MultiplePayloadStreamCapability),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CapabilityDescriptor {
        #[rasn(identifier = "capabilityDescriptorNumber")]
        pub capability_descriptor_number: CapabilityDescriptorNumber,
        #[rasn(size("1..=256"), identifier = "simultaneousCapabilities")]
        pub simultaneous_capabilities: Option<SetOf<AlternativeCapabilitySet>>,
    }
    impl CapabilityDescriptor {
        pub fn new(
            capability_descriptor_number: CapabilityDescriptorNumber,
            simultaneous_capabilities: Option<SetOf<AlternativeCapabilitySet>>,
        ) -> Self {
            Self {
                capability_descriptor_number,
                simultaneous_capabilities,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=255"))]
    pub struct CapabilityDescriptorNumber(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CapabilityIdentifier {
        standard(ObjectIdentifier),
        h221NonStandard(NonStandardParameter),
        #[rasn(size("16"))]
        uuid(OctetString),
        #[rasn(size("1..=64"))]
        domainBased(Ia5String),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CapabilityTableEntry {
        #[rasn(identifier = "capabilityTableEntryNumber")]
        pub capability_table_entry_number: CapabilityTableEntryNumber,
        pub capability: Option<Capability>,
    }
    impl CapabilityTableEntry {
        pub fn new(
            capability_table_entry_number: CapabilityTableEntryNumber,
            capability: Option<Capability>,
        ) -> Self {
            Self {
                capability_table_entry_number,
                capability,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=65535"))]
    pub struct CapabilityTableEntryNumber(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=16"))]
    pub struct CertSelectionCriteria(pub SequenceOf<Criteria>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum CloseLogicalChannelSource {
        user(()),
        lcse(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CloseLogicalChannelReason {
        unknown(()),
        reopen(()),
        reservationFailure(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CloseLogicalChannel {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
        pub source: CloseLogicalChannelSource,
        #[rasn(extension_addition)]
        pub reason: CloseLogicalChannelReason,
    }
    impl CloseLogicalChannel {
        pub fn new(
            forward_logical_channel_number: LogicalChannelNumber,
            source: CloseLogicalChannelSource,
            reason: CloseLogicalChannelReason,
        ) -> Self {
            Self {
                forward_logical_channel_number,
                source,
                reason,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CloseLogicalChannelAck {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
    }
    impl CloseLogicalChannelAck {
        pub fn new(forward_logical_channel_number: LogicalChannelNumber) -> Self {
            Self {
                forward_logical_channel_number,
            }
        }
    }
    #[doc = " A CommandMessage requires action, but no explicit response"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CommandMessage {
        nonStandard(NonStandardMessage),
        maintenanceLoopOffCommand(MaintenanceLoopOffCommand),
        sendTerminalCapabilitySet(SendTerminalCapabilitySet),
        encryptionCommand(EncryptionCommand),
        flowControlCommand(FlowControlCommand),
        endSessionCommand(EndSessionCommand),
        miscellaneousCommand(MiscellaneousCommand),
        #[rasn(extension_addition)]
        communicationModeCommand(CommunicationModeCommand),
        #[rasn(extension_addition)]
        conferenceCommand(ConferenceCommand),
        #[rasn(extension_addition)]
        h223MultiplexReconfiguration(H223MultiplexReconfiguration),
        #[rasn(extension_addition)]
        newATMVCCommand(NewATMVCCommand),
        #[rasn(extension_addition)]
        mobileMultilinkReconfigurationCommand(MobileMultilinkReconfigurationCommand),
        #[rasn(extension_addition)]
        genericCommand(GenericMessage),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Communication Mode definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CommunicationModeCommand {
        #[rasn(size("1..=256"), identifier = "communicationModeTable")]
        pub communication_mode_table: SetOf<CommunicationModeTableEntry>,
    }
    impl CommunicationModeCommand {
        pub fn new(communication_mode_table: SetOf<CommunicationModeTableEntry>) -> Self {
            Self {
                communication_mode_table,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CommunicationModeRequest {}
    impl CommunicationModeRequest {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for CommunicationModeRequest {
        fn default() -> Self {
            Self {}
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CommunicationModeResponse {
        #[rasn(size("1..=256"))]
        communicationModeTable(SetOf<CommunicationModeTableEntry>),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CommunicationModeTableEntryDataType {
        videoData(VideoCapability),
        audioData(AudioCapability),
        data(DataApplicationCapability),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CommunicationModeTableEntry {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
        #[rasn(value("1..=255"), identifier = "sessionID")]
        pub session_id: u8,
        #[rasn(value("1..=255"), identifier = "associatedSessionID")]
        pub associated_session_id: Option<u8>,
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: Option<TerminalLabel>,
        #[rasn(size("1..=128"), identifier = "sessionDescription")]
        pub session_description: BmpString,
        #[rasn(identifier = "dataType")]
        pub data_type: CommunicationModeTableEntryDataType,
        #[rasn(identifier = "mediaChannel")]
        pub media_channel: Option<TransportAddress>,
        #[rasn(identifier = "mediaGuaranteedDelivery")]
        pub media_guaranteed_delivery: Option<bool>,
        #[rasn(identifier = "mediaControlChannel")]
        pub media_control_channel: Option<TransportAddress>,
        #[rasn(identifier = "mediaControlGuaranteedDelivery")]
        pub media_control_guaranteed_delivery: Option<bool>,
        #[rasn(extension_addition, identifier = "redundancyEncoding")]
        pub redundancy_encoding: Option<RedundancyEncoding>,
        #[rasn(extension_addition, value("1..=255"), identifier = "sessionDependency")]
        pub session_dependency: Option<u8>,
        #[rasn(extension_addition)]
        pub destination: Option<TerminalLabel>,
    }
    impl CommunicationModeTableEntry {
        pub fn new(
            non_standard: Option<SequenceOf<NonStandardParameter>>,
            session_id: u8,
            associated_session_id: Option<u8>,
            terminal_label: Option<TerminalLabel>,
            session_description: BmpString,
            data_type: CommunicationModeTableEntryDataType,
            media_channel: Option<TransportAddress>,
            media_guaranteed_delivery: Option<bool>,
            media_control_channel: Option<TransportAddress>,
            media_control_guaranteed_delivery: Option<bool>,
            redundancy_encoding: Option<RedundancyEncoding>,
            session_dependency: Option<u8>,
            destination: Option<TerminalLabel>,
        ) -> Self {
            Self {
                non_standard,
                session_id,
                associated_session_id,
                terminal_label,
                session_description,
                data_type,
                media_channel,
                media_guaranteed_delivery,
                media_control_channel,
                media_control_guaranteed_delivery,
                redundancy_encoding,
                session_dependency,
                destination,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CompressionType {
        v42bis(V42bis),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability Exchange Definitions: Conference"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceCapability {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<SequenceOf<NonStandardParameter>>,
        #[rasn(identifier = "chairControlCapability")]
        pub chair_control_capability: bool,
        #[rasn(extension_addition, identifier = "videoIndicateMixingCapability")]
        pub video_indicate_mixing_capability: bool,
        #[rasn(extension_addition, identifier = "multipointVisualizationCapability")]
        pub multipoint_visualization_capability: Option<bool>,
    }
    impl ConferenceCapability {
        pub fn new(
            non_standard_data: Option<SequenceOf<NonStandardParameter>>,
            chair_control_capability: bool,
            video_indicate_mixing_capability: bool,
            multipoint_visualization_capability: Option<bool>,
        ) -> Self {
            Self {
                non_standard_data,
                chair_control_capability,
                video_indicate_mixing_capability,
                multipoint_visualization_capability,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : Conference Commands"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ConferenceCommand {
        broadcastMyLogicalChannel(LogicalChannelNumber),
        cancelBroadcastMyLogicalChannel(LogicalChannelNumber),
        makeTerminalBroadcaster(TerminalLabel),
        cancelMakeTerminalBroadcaster(()),
        sendThisSource(TerminalLabel),
        cancelSendThisSource(()),
        dropConference(()),
        #[rasn(extension_addition)]
        substituteConferenceIDCommand(SubstituteConferenceIDCommand),
    }
    #[doc = " as per H.230"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=32"))]
    pub struct ConferenceID(pub OctetString);
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : Conference"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ConferenceIndication {
        #[rasn(value("0..=9"))]
        sbeNumber(u8),
        terminalNumberAssign(TerminalLabel),
        terminalJoinedConference(TerminalLabel),
        terminalLeftConference(TerminalLabel),
        seenByAtLeastOneOther(()),
        cancelSeenByAtLeastOneOther(()),
        seenByAll(()),
        cancelSeenByAll(()),
        terminalYouAreSeeing(TerminalLabel),
        requestForFloor(()),
        #[rasn(extension_addition)]
        withdrawChairToken(()),
        #[rasn(extension_addition)]
        floorRequested(TerminalLabel),
        #[rasn(extension_addition)]
        terminalYouAreSeeingInSubPictureNumber(TerminalYouAreSeeingInSubPictureNumber),
        #[rasn(extension_addition)]
        videoIndicateCompose(VideoIndicateCompose),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceRequestRequestTerminalCertificate {
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: Option<TerminalLabel>,
        #[rasn(identifier = "certSelectionCriteria")]
        pub cert_selection_criteria: Option<CertSelectionCriteria>,
        #[rasn(value("1..=4294967295"), identifier = "sRandom")]
        pub s_random: Option<u32>,
    }
    impl ConferenceRequestRequestTerminalCertificate {
        pub fn new(
            terminal_label: Option<TerminalLabel>,
            cert_selection_criteria: Option<CertSelectionCriteria>,
            s_random: Option<u32>,
        ) -> Self {
            Self {
                terminal_label,
                cert_selection_criteria,
                s_random,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Conference Request definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ConferenceRequest {
        terminalListRequest(()),
        makeMeChair(()),
        cancelMakeMeChair(()),
        dropTerminal(TerminalLabel),
        requestTerminalID(TerminalLabel),
        enterH243Password(()),
        enterH243TerminalID(()),
        enterH243ConferenceID(()),
        #[rasn(extension_addition)]
        enterExtensionAddress(()),
        #[rasn(extension_addition)]
        requestChairTokenOwner(()),
        #[rasn(extension_addition)]
        requestTerminalCertificate(ConferenceRequestRequestTerminalCertificate),
        #[rasn(extension_addition)]
        broadcastMyLogicalChannel(LogicalChannelNumber),
        #[rasn(extension_addition)]
        makeTerminalBroadcaster(TerminalLabel),
        #[rasn(extension_addition)]
        sendThisSource(TerminalLabel),
        #[rasn(extension_addition)]
        requestAllTerminalIDs(()),
        #[rasn(extension_addition)]
        remoteMCRequest(RemoteMCRequest),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceResponseMCTerminalIDResponse {
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: TerminalLabel,
        #[rasn(identifier = "terminalID")]
        pub terminal_id: TerminalID,
    }
    impl ConferenceResponseMCTerminalIDResponse {
        pub fn new(terminal_label: TerminalLabel, terminal_id: TerminalID) -> Self {
            Self {
                terminal_label,
                terminal_id,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceResponseTerminalIDResponse {
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: TerminalLabel,
        #[rasn(identifier = "terminalID")]
        pub terminal_id: TerminalID,
    }
    impl ConferenceResponseTerminalIDResponse {
        pub fn new(terminal_label: TerminalLabel, terminal_id: TerminalID) -> Self {
            Self {
                terminal_label,
                terminal_id,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceResponseConferenceIDResponse {
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: TerminalLabel,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceID,
    }
    impl ConferenceResponseConferenceIDResponse {
        pub fn new(terminal_label: TerminalLabel, conference_id: ConferenceID) -> Self {
            Self {
                terminal_label,
                conference_id,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceResponsePasswordResponse {
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: TerminalLabel,
        pub password: Password,
    }
    impl ConferenceResponsePasswordResponse {
        pub fn new(terminal_label: TerminalLabel, password: Password) -> Self {
            Self {
                terminal_label,
                password,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ConferenceResponseMakeMeChairResponse {
        grantedChairToken(()),
        deniedChairToken(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceResponseExtensionAddressResponse {
        #[rasn(identifier = "extensionAddress")]
        pub extension_address: TerminalID,
    }
    impl ConferenceResponseExtensionAddressResponse {
        pub fn new(extension_address: TerminalID) -> Self {
            Self { extension_address }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceResponseChairTokenOwnerResponse {
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: TerminalLabel,
        #[rasn(identifier = "terminalID")]
        pub terminal_id: TerminalID,
    }
    impl ConferenceResponseChairTokenOwnerResponse {
        pub fn new(terminal_label: TerminalLabel, terminal_id: TerminalID) -> Self {
            Self {
                terminal_label,
                terminal_id,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceResponseTerminalCertificateResponse {
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: Option<TerminalLabel>,
        #[rasn(size("1..=65535"), identifier = "certificateResponse")]
        pub certificate_response: Option<OctetString>,
    }
    impl ConferenceResponseTerminalCertificateResponse {
        pub fn new(
            terminal_label: Option<TerminalLabel>,
            certificate_response: Option<OctetString>,
        ) -> Self {
            Self {
                terminal_label,
                certificate_response,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ConferenceResponseBroadcastMyLogicalChannelResponse {
        grantedBroadcastMyLogicalChannel(()),
        deniedBroadcastMyLogicalChannel(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ConferenceResponseMakeTerminalBroadcasterResponse {
        grantedMakeTerminalBroadcaster(()),
        deniedMakeTerminalBroadcaster(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ConferenceResponseSendThisSourceResponse {
        grantedSendThisSource(()),
        deniedSendThisSource(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Conference Response definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ConferenceResponse {
        mCTerminalIDResponse(ConferenceResponseMCTerminalIDResponse),
        terminalIDResponse(ConferenceResponseTerminalIDResponse),
        conferenceIDResponse(ConferenceResponseConferenceIDResponse),
        passwordResponse(ConferenceResponsePasswordResponse),
        #[rasn(size("1..=256"))]
        terminalListResponse(SetOf<TerminalLabel>),
        videoCommandReject(()),
        terminalDropReject(()),
        makeMeChairResponse(ConferenceResponseMakeMeChairResponse),
        #[rasn(extension_addition)]
        extensionAddressResponse(ConferenceResponseExtensionAddressResponse),
        #[rasn(extension_addition)]
        chairTokenOwnerResponse(ConferenceResponseChairTokenOwnerResponse),
        #[rasn(extension_addition)]
        terminalCertificateResponse(ConferenceResponseTerminalCertificateResponse),
        #[rasn(extension_addition)]
        broadcastMyLogicalChannelResponse(ConferenceResponseBroadcastMyLogicalChannelResponse),
        #[rasn(extension_addition)]
        makeTerminalBroadcasterResponse(ConferenceResponseMakeTerminalBroadcasterResponse),
        #[rasn(extension_addition)]
        sendThisSourceResponse(ConferenceResponseSendThisSourceResponse),
        #[rasn(extension_addition)]
        requestAllTerminalIDsResponse(RequestAllTerminalIDsResponse),
        #[rasn(extension_addition)]
        remoteMCResponse(RemoteMCResponse),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConnectionIdentifier {
        #[rasn(value("0..=4294967295"), identifier = "channelTag")]
        pub channel_tag: u32,
        #[rasn(value("0..=4294967295"), identifier = "sequenceNumber")]
        pub sequence_number: u32,
    }
    impl ConnectionIdentifier {
        pub fn new(channel_tag: u32, sequence_number: u32) -> Self {
            Self {
                channel_tag,
                sequence_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Criteria {
        pub field: ObjectIdentifier,
        #[rasn(size("1..=65535"))]
        pub value: OctetString,
    }
    impl Criteria {
        pub fn new(field: ObjectIdentifier, value: OctetString) -> Self {
            Self { field, value }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CustomPictureClockFrequency {
        #[rasn(value("1000..=1001"), identifier = "clockConversionCode")]
        pub clock_conversion_code: u16,
        #[rasn(value("1..=127"), identifier = "clockDivisor")]
        pub clock_divisor: u8,
        #[rasn(value("1..=2048"), identifier = "sqcifMPI")]
        pub sqcif_mpi: Option<u16>,
        #[rasn(value("1..=2048"), identifier = "qcifMPI")]
        pub qcif_mpi: Option<u16>,
        #[rasn(value("1..=2048"), identifier = "cifMPI")]
        pub cif_mpi: Option<u16>,
        #[rasn(value("1..=2048"), identifier = "cif4MPI")]
        pub cif4_mpi: Option<u16>,
        #[rasn(value("1..=2048"), identifier = "cif16MPI")]
        pub cif16_mpi: Option<u16>,
    }
    impl CustomPictureClockFrequency {
        pub fn new(
            clock_conversion_code: u16,
            clock_divisor: u8,
            sqcif_mpi: Option<u16>,
            qcif_mpi: Option<u16>,
            cif_mpi: Option<u16>,
            cif4_mpi: Option<u16>,
            cif16_mpi: Option<u16>,
        ) -> Self {
            Self {
                clock_conversion_code,
                clock_divisor,
                sqcif_mpi,
                qcif_mpi,
                cif_mpi,
                cif4_mpi,
                cif16_mpi,
            }
        }
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "SEQUENCE")]
    #[non_exhaustive]
    pub struct AnonymousCustomPictureFormatMPICustomPCF {
        #[rasn(value("1000..=1001"), identifier = "clockConversionCode")]
        pub clock_conversion_code: u16,
        #[rasn(value("1..=127"), identifier = "clockDivisor")]
        pub clock_divisor: u8,
        #[rasn(value("1..=2048"), identifier = "customMPI")]
        pub custom_mpi: u16,
    }
    impl AnonymousCustomPictureFormatMPICustomPCF {
        pub fn new(clock_conversion_code: u16, clock_divisor: u8, custom_mpi: u16) -> Self {
            Self {
                clock_conversion_code,
                clock_divisor,
                custom_mpi,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=16"))]
    pub struct CustomPictureFormatMPICustomPCF(pub SetOf<AnonymousCustomPictureFormatMPICustomPCF>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CustomPictureFormatMPI {
        #[rasn(value("1..=31"), identifier = "standardMPI")]
        pub standard_mpi: Option<u8>,
        #[rasn(identifier = "customPCF")]
        pub custom_pcf: Option<CustomPictureFormatMPICustomPCF>,
    }
    impl CustomPictureFormatMPI {
        pub fn new(
            standard_mpi: Option<u8>,
            custom_pcf: Option<CustomPictureFormatMPICustomPCF>,
        ) -> Self {
            Self {
                standard_mpi,
                custom_pcf,
            }
        }
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER", value("1..=14"))]
    pub struct AnonymousCustomPictureFormatPixelAspectInformationPixelAspectCode(pub u8);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=14"))]
    pub struct CustomPictureFormatPixelAspectInformationPixelAspectCode(
        pub SetOf<AnonymousCustomPictureFormatPixelAspectInformationPixelAspectCode>,
    );
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "SEQUENCE")]
    #[non_exhaustive]
    pub struct AnonymousCustomPictureFormatPixelAspectInformationExtendedPAR {
        #[rasn(value("1..=255"))]
        pub width: u8,
        #[rasn(value("1..=255"))]
        pub height: u8,
    }
    impl AnonymousCustomPictureFormatPixelAspectInformationExtendedPAR {
        pub fn new(width: u8, height: u8) -> Self {
            Self { width, height }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=256"))]
    pub struct CustomPictureFormatPixelAspectInformationExtendedPAR(
        pub SetOf<AnonymousCustomPictureFormatPixelAspectInformationExtendedPAR>,
    );
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CustomPictureFormatPixelAspectInformation {
        anyPixelAspectRatio(bool),
        pixelAspectCode(CustomPictureFormatPixelAspectInformationPixelAspectCode),
        extendedPAR(CustomPictureFormatPixelAspectInformationExtendedPAR),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CustomPictureFormat {
        #[rasn(value("1..=2048"), identifier = "maxCustomPictureWidth")]
        pub max_custom_picture_width: u16,
        #[rasn(value("1..=2048"), identifier = "maxCustomPictureHeight")]
        pub max_custom_picture_height: u16,
        #[rasn(value("1..=2048"), identifier = "minCustomPictureWidth")]
        pub min_custom_picture_width: u16,
        #[rasn(value("1..=2048"), identifier = "minCustomPictureHeight")]
        pub min_custom_picture_height: u16,
        #[rasn(identifier = "mPI")]
        pub m_pi: CustomPictureFormatMPI,
        #[rasn(identifier = "pixelAspectInformation")]
        pub pixel_aspect_information: CustomPictureFormatPixelAspectInformation,
    }
    impl CustomPictureFormat {
        pub fn new(
            max_custom_picture_width: u16,
            max_custom_picture_height: u16,
            min_custom_picture_width: u16,
            min_custom_picture_height: u16,
            m_pi: CustomPictureFormatMPI,
            pixel_aspect_information: CustomPictureFormatPixelAspectInformation,
        ) -> Self {
            Self {
                max_custom_picture_width,
                max_custom_picture_height,
                min_custom_picture_width,
                min_custom_picture_height,
                m_pi,
                pixel_aspect_information,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct DataApplicationCapabilityApplicationT84 {
        #[rasn(identifier = "t84Protocol")]
        pub t84_protocol: DataProtocolCapability,
        #[rasn(identifier = "t84Profile")]
        pub t84_profile: T84Profile,
    }
    impl DataApplicationCapabilityApplicationT84 {
        pub fn new(t84_protocol: DataProtocolCapability, t84_profile: T84Profile) -> Self {
            Self {
                t84_protocol,
                t84_profile,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct DataApplicationCapabilityApplicationNlpid {
        #[rasn(identifier = "nlpidProtocol")]
        pub nlpid_protocol: DataProtocolCapability,
        #[rasn(identifier = "nlpidData")]
        pub nlpid_data: OctetString,
    }
    impl DataApplicationCapabilityApplicationNlpid {
        pub fn new(nlpid_protocol: DataProtocolCapability, nlpid_data: OctetString) -> Self {
            Self {
                nlpid_protocol,
                nlpid_data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct DataApplicationCapabilityApplicationT38fax {
        #[rasn(identifier = "t38FaxProtocol")]
        pub t38_fax_protocol: DataProtocolCapability,
        #[rasn(identifier = "t38FaxProfile")]
        pub t38_fax_profile: T38FaxProfile,
    }
    impl DataApplicationCapabilityApplicationT38fax {
        pub fn new(
            t38_fax_protocol: DataProtocolCapability,
            t38_fax_profile: T38FaxProfile,
        ) -> Self {
            Self {
                t38_fax_protocol,
                t38_fax_profile,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DataApplicationCapabilityApplication {
        nonStandard(NonStandardParameter),
        t120(DataProtocolCapability),
        #[rasn(identifier = "dsm-cc")]
        dsm_cc(DataProtocolCapability),
        userData(DataProtocolCapability),
        t84(DataApplicationCapabilityApplicationT84),
        t434(DataProtocolCapability),
        h224(DataProtocolCapability),
        nlpid(DataApplicationCapabilityApplicationNlpid),
        dsvdControl(()),
        h222DataPartitioning(DataProtocolCapability),
        #[rasn(extension_addition)]
        t30fax(DataProtocolCapability),
        #[rasn(extension_addition)]
        t140(DataProtocolCapability),
        #[rasn(extension_addition)]
        t38fax(DataApplicationCapabilityApplicationT38fax),
        #[rasn(extension_addition)]
        genericDataCapability(GenericCapability),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability exchange definitions: Data capabilities"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DataApplicationCapability {
        pub application: DataApplicationCapabilityApplication,
        #[rasn(value("0..=4294967295"), identifier = "maxBitRate")]
        pub max_bit_rate: u32,
    }
    impl DataApplicationCapability {
        pub fn new(application: DataApplicationCapabilityApplication, max_bit_rate: u32) -> Self {
            Self {
                application,
                max_bit_rate,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct DataModeApplicationNlpid {
        #[rasn(identifier = "nlpidProtocol")]
        pub nlpid_protocol: DataProtocolCapability,
        #[rasn(identifier = "nlpidData")]
        pub nlpid_data: OctetString,
    }
    impl DataModeApplicationNlpid {
        pub fn new(nlpid_protocol: DataProtocolCapability, nlpid_data: OctetString) -> Self {
            Self {
                nlpid_protocol,
                nlpid_data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct DataModeApplicationT38fax {
        #[rasn(identifier = "t38FaxProtocol")]
        pub t38_fax_protocol: DataProtocolCapability,
        #[rasn(identifier = "t38FaxProfile")]
        pub t38_fax_profile: T38FaxProfile,
    }
    impl DataModeApplicationT38fax {
        pub fn new(
            t38_fax_protocol: DataProtocolCapability,
            t38_fax_profile: T38FaxProfile,
        ) -> Self {
            Self {
                t38_fax_protocol,
                t38_fax_profile,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DataModeApplication {
        nonStandard(NonStandardParameter),
        t120(DataProtocolCapability),
        #[rasn(identifier = "dsm-cc")]
        dsm_cc(DataProtocolCapability),
        userData(DataProtocolCapability),
        t84(DataProtocolCapability),
        t434(DataProtocolCapability),
        h224(DataProtocolCapability),
        nlpid(DataModeApplicationNlpid),
        dsvdControl(()),
        h222DataPartitioning(DataProtocolCapability),
        #[rasn(extension_addition)]
        t30fax(DataProtocolCapability),
        #[rasn(extension_addition)]
        t140(DataProtocolCapability),
        #[rasn(extension_addition)]
        t38fax(DataModeApplicationT38fax),
        #[rasn(extension_addition)]
        genericDataMode(GenericCapability),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Request mode definitions: Data modes"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DataMode {
        pub application: DataModeApplication,
        #[rasn(value("0..=4294967295"), identifier = "bitRate")]
        pub bit_rate: u32,
    }
    impl DataMode {
        pub fn new(application: DataModeApplication, bit_rate: u32) -> Self {
            Self {
                application,
                bit_rate,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DataProtocolCapabilityV76wCompression {
        transmitCompression(CompressionType),
        receiveCompression(CompressionType),
        transmitAndReceiveCompression(CompressionType),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DataProtocolCapability {
        nonStandard(NonStandardParameter),
        v14buffered(()),
        v42lapm(()),
        hdlcFrameTunnelling(()),
        h310SeparateVCStack(()),
        h310SingleVCStack(()),
        transparent(()),
        #[rasn(extension_addition)]
        segmentationAndReassembly(()),
        #[rasn(extension_addition)]
        hdlcFrameTunnelingwSAR(()),
        #[rasn(extension_addition)]
        v120(()),
        #[rasn(extension_addition)]
        separateLANStack(()),
        #[rasn(extension_addition)]
        v76wCompression(DataProtocolCapabilityV76wCompression),
        #[rasn(extension_addition)]
        tcp(()),
        #[rasn(extension_addition)]
        udp(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DataType {
        nonStandard(NonStandardParameter),
        nullData(()),
        videoData(VideoCapability),
        audioData(AudioCapability),
        data(DataApplicationCapability),
        encryptionData(EncryptionMode),
        #[rasn(extension_addition)]
        h235Control(NonStandardParameter),
        #[rasn(extension_addition)]
        h235Media(H235Media),
        #[rasn(extension_addition)]
        multiplexedStream(MultiplexedStreamParameter),
        #[rasn(extension_addition)]
        redundancyEncoding(RedundancyEncoding),
        #[rasn(extension_addition)]
        multiplePayloadStream(MultiplePayloadStream),
        #[rasn(extension_addition)]
        fec(FECData),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DialingInformation {
        nonStandard(NonStandardMessage),
        #[rasn(size("1..=65535"))]
        differential(SetOf<DialingInformationNumber>),
        #[rasn(value("1..=65535"))]
        infoNotAvailable(u16),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DialingInformationNetworkType {
        nonStandard(NonStandardMessage),
        #[rasn(identifier = "n-isdn")]
        n_isdn(()),
        gstn(()),
        #[rasn(extension_addition)]
        mobile(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DialingInformationNumber {
        #[rasn(size("0..=40"), identifier = "networkAddress")]
        pub network_address: NumericString,
        #[rasn(size("1..=40"), identifier = "subAddress")]
        pub sub_address: Option<Ia5String>,
        #[rasn(size("1..=255"), identifier = "networkType")]
        pub network_type: SetOf<DialingInformationNetworkType>,
    }
    impl DialingInformationNumber {
        pub fn new(
            network_address: NumericString,
            sub_address: Option<Ia5String>,
            network_type: SetOf<DialingInformationNetworkType>,
        ) -> Self {
            Self {
                network_address,
                sub_address,
                network_type,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Encryption Capability Definitions:"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EncryptionAuthenticationAndIntegrity {
        #[rasn(identifier = "encryptionCapability")]
        pub encryption_capability: Option<EncryptionCapability>,
        #[rasn(identifier = "authenticationCapability")]
        pub authentication_capability: Option<AuthenticationCapability>,
        #[rasn(identifier = "integrityCapability")]
        pub integrity_capability: Option<IntegrityCapability>,
    }
    impl EncryptionAuthenticationAndIntegrity {
        pub fn new(
            encryption_capability: Option<EncryptionCapability>,
            authentication_capability: Option<AuthenticationCapability>,
            integrity_capability: Option<IntegrityCapability>,
        ) -> Self {
            Self {
                encryption_capability,
                authentication_capability,
                integrity_capability,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=256"))]
    pub struct EncryptionCapability(pub SequenceOf<MediaEncryptionAlgorithm>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct EncryptionCommandEncryptionAlgorithmID {
        #[rasn(identifier = "h233AlgorithmIdentifier")]
        pub h233_algorithm_identifier: SequenceNumber,
        #[rasn(identifier = "associatedAlgorithm")]
        pub associated_algorithm: NonStandardParameter,
    }
    impl EncryptionCommandEncryptionAlgorithmID {
        pub fn new(
            h233_algorithm_identifier: SequenceNumber,
            associated_algorithm: NonStandardParameter,
        ) -> Self {
            Self {
                h233_algorithm_identifier,
                associated_algorithm,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : Encryption"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum EncryptionCommand {
        encryptionSE(OctetString),
        encryptionIVRequest(()),
        encryptionAlgorithmID(EncryptionCommandEncryptionAlgorithmID),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Request mode definitions: Encryption modes"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum EncryptionMode {
        nonStandard(NonStandardParameter),
        h233Encryption(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EncryptionSync {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<NonStandardParameter>,
        #[rasn(value("0..=255"), identifier = "synchFlag")]
        pub synch_flag: u8,
        #[rasn(size("1..=65535"), identifier = "h235Key")]
        pub h235_key: OctetString,
        #[rasn(size("1..=256"))]
        pub escrowentry: Option<SequenceOf<EscrowData>>,
    }
    impl EncryptionSync {
        pub fn new(
            non_standard: Option<NonStandardParameter>,
            synch_flag: u8,
            h235_key: OctetString,
            escrowentry: Option<SequenceOf<EscrowData>>,
        ) -> Self {
            Self {
                non_standard,
                synch_flag,
                h235_key,
                escrowentry,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : Miscellaneous H.230-like commands"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum EncryptionUpdateDirection {
        masterToSlave(()),
        slaveToMaster(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EncryptionUpdateRequest {
        #[rasn(identifier = "keyProtectionMethod")]
        pub key_protection_method: Option<KeyProtectionMethod>,
        #[rasn(extension_addition, value("0..=255"), identifier = "synchFlag")]
        pub synch_flag: Option<u8>,
    }
    impl EncryptionUpdateRequest {
        pub fn new(
            key_protection_method: Option<KeyProtectionMethod>,
            synch_flag: Option<u8>,
        ) -> Self {
            Self {
                key_protection_method,
                synch_flag,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum EndSessionCommandGstnOptions {
        telephonyMode(()),
        v8bis(()),
        v34DSVD(()),
        v34DuplexFAX(()),
        v34H324(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum EndSessionCommandIsdnOptions {
        telephonyMode(()),
        v140(()),
        terminalOnHold(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : Change or End Session"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum EndSessionCommand {
        nonStandard(NonStandardParameter),
        disconnect(()),
        gstnOptions(EndSessionCommandGstnOptions),
        #[rasn(extension_addition)]
        isdnOptions(EndSessionCommandIsdnOptions),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EnhancementLayerInfo {
        #[rasn(identifier = "baseBitRateConstrained")]
        pub base_bit_rate_constrained: bool,
        #[rasn(size("1..=14"), identifier = "snrEnhancement")]
        pub snr_enhancement: Option<SetOf<EnhancementOptions>>,
        #[rasn(size("1..=14"), identifier = "spatialEnhancement")]
        pub spatial_enhancement: Option<SetOf<EnhancementOptions>>,
        #[rasn(size("1..=14"), identifier = "bPictureEnhancement")]
        pub b_picture_enhancement: Option<SetOf<BEnhancementParameters>>,
    }
    impl EnhancementLayerInfo {
        pub fn new(
            base_bit_rate_constrained: bool,
            snr_enhancement: Option<SetOf<EnhancementOptions>>,
            spatial_enhancement: Option<SetOf<EnhancementOptions>>,
            b_picture_enhancement: Option<SetOf<BEnhancementParameters>>,
        ) -> Self {
            Self {
                base_bit_rate_constrained,
                snr_enhancement,
                spatial_enhancement,
                b_picture_enhancement,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EnhancementOptions {
        #[rasn(value("1..=32"), identifier = "sqcifMPI")]
        pub sqcif_mpi: Option<u8>,
        #[rasn(value("1..=32"), identifier = "qcifMPI")]
        pub qcif_mpi: Option<u8>,
        #[rasn(value("1..=32"), identifier = "cifMPI")]
        pub cif_mpi: Option<u8>,
        #[rasn(value("1..=32"), identifier = "cif4MPI")]
        pub cif4_mpi: Option<u8>,
        #[rasn(value("1..=32"), identifier = "cif16MPI")]
        pub cif16_mpi: Option<u8>,
        #[rasn(value("1..=192400"), identifier = "maxBitRate")]
        pub max_bit_rate: u32,
        #[rasn(identifier = "unrestrictedVector")]
        pub unrestricted_vector: bool,
        #[rasn(identifier = "arithmeticCoding")]
        pub arithmetic_coding: bool,
        #[rasn(identifier = "temporalSpatialTradeOffCapability")]
        pub temporal_spatial_trade_off_capability: bool,
        #[rasn(value("1..=3600"), identifier = "slowSqcifMPI")]
        pub slow_sqcif_mpi: Option<u16>,
        #[rasn(value("1..=3600"), identifier = "slowQcifMPI")]
        pub slow_qcif_mpi: Option<u16>,
        #[rasn(value("1..=3600"), identifier = "slowCifMPI")]
        pub slow_cif_mpi: Option<u16>,
        #[rasn(value("1..=3600"), identifier = "slowCif4MPI")]
        pub slow_cif4_mpi: Option<u16>,
        #[rasn(value("1..=3600"), identifier = "slowCif16MPI")]
        pub slow_cif16_mpi: Option<u16>,
        #[rasn(identifier = "errorCompensation")]
        pub error_compensation: bool,
        #[rasn(identifier = "h263Options")]
        pub h263_options: Option<H263Options>,
    }
    impl EnhancementOptions {
        pub fn new(
            sqcif_mpi: Option<u8>,
            qcif_mpi: Option<u8>,
            cif_mpi: Option<u8>,
            cif4_mpi: Option<u8>,
            cif16_mpi: Option<u8>,
            max_bit_rate: u32,
            unrestricted_vector: bool,
            arithmetic_coding: bool,
            temporal_spatial_trade_off_capability: bool,
            slow_sqcif_mpi: Option<u16>,
            slow_qcif_mpi: Option<u16>,
            slow_cif_mpi: Option<u16>,
            slow_cif4_mpi: Option<u16>,
            slow_cif16_mpi: Option<u16>,
            error_compensation: bool,
            h263_options: Option<H263Options>,
        ) -> Self {
            Self {
                sqcif_mpi,
                qcif_mpi,
                cif_mpi,
                cif4_mpi,
                cif16_mpi,
                max_bit_rate,
                unrestricted_vector,
                arithmetic_coding,
                temporal_spatial_trade_off_capability,
                slow_sqcif_mpi,
                slow_qcif_mpi,
                slow_cif_mpi,
                slow_cif4_mpi,
                slow_cif16_mpi,
                error_compensation,
                h263_options,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EscrowData {
        #[rasn(identifier = "escrowID")]
        pub escrow_id: ObjectIdentifier,
        #[rasn(size("1..=65535"), identifier = "escrowValue")]
        pub escrow_value: BitString,
    }
    impl EscrowData {
        pub fn new(escrow_id: ObjectIdentifier, escrow_value: BitString) -> Self {
            Self {
                escrow_id,
                escrow_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ExtendedVideoCapability {
        #[rasn(identifier = "videoCapability")]
        pub video_capability: SequenceOf<VideoCapability>,
        #[rasn(identifier = "videoCapabilityExtension")]
        pub video_capability_extension: Option<SequenceOf<GenericCapability>>,
    }
    impl ExtendedVideoCapability {
        pub fn new(
            video_capability: SequenceOf<VideoCapability>,
            video_capability_extension: Option<SequenceOf<GenericCapability>>,
        ) -> Self {
            Self {
                video_capability,
                video_capability_extension,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FECCapabilityRfc2733SeparateStream {
        #[rasn(identifier = "separatePort")]
        pub separate_port: bool,
        #[rasn(identifier = "samePort")]
        pub same_port: bool,
    }
    impl FECCapabilityRfc2733SeparateStream {
        pub fn new(separate_port: bool, same_port: bool) -> Self {
            Self {
                separate_port,
                same_port,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FECCapabilityRfc2733 {
        #[rasn(identifier = "redundancyEncoding")]
        pub redundancy_encoding: bool,
        #[rasn(identifier = "separateStream")]
        pub separate_stream: FECCapabilityRfc2733SeparateStream,
    }
    impl FECCapabilityRfc2733 {
        pub fn new(
            redundancy_encoding: bool,
            separate_stream: FECCapabilityRfc2733SeparateStream,
        ) -> Self {
            Self {
                redundancy_encoding,
                separate_stream,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability Exchange Definitions: FECCapability"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FECCapability {
        rfc2733(FECCapabilityRfc2733),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FECDataRfc2733ModeSeparateStreamDifferentPort {
        #[rasn(value("1..=255"), identifier = "protectedSessionID")]
        pub protected_session_id: u8,
        #[rasn(value("0..=127"), identifier = "protectedPayloadType")]
        pub protected_payload_type: Option<u8>,
    }
    impl FECDataRfc2733ModeSeparateStreamDifferentPort {
        pub fn new(protected_session_id: u8, protected_payload_type: Option<u8>) -> Self {
            Self {
                protected_session_id,
                protected_payload_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FECDataRfc2733ModeSeparateStreamSamePort {
        #[rasn(value("0..=127"), identifier = "protectedPayloadType")]
        pub protected_payload_type: u8,
    }
    impl FECDataRfc2733ModeSeparateStreamSamePort {
        pub fn new(protected_payload_type: u8) -> Self {
            Self {
                protected_payload_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FECDataRfc2733ModeSeparateStream {
        differentPort(FECDataRfc2733ModeSeparateStreamDifferentPort),
        samePort(FECDataRfc2733ModeSeparateStreamSamePort),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FECDataRfc2733Mode {
        redundancyEncoding(()),
        separateStream(FECDataRfc2733ModeSeparateStream),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FECDataRfc2733 {
        pub mode: FECDataRfc2733Mode,
    }
    impl FECDataRfc2733 {
        pub fn new(mode: FECDataRfc2733Mode) -> Self {
            Self { mode }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum FECData {
        rfc2733(FECDataRfc2733),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FECModeRfc2733ModeModeSeparateStreamDifferentPort {
        #[rasn(value("1..=255"), identifier = "protectedSessionID")]
        pub protected_session_id: u8,
        #[rasn(value("0..=127"), identifier = "protectedPayloadType")]
        pub protected_payload_type: Option<u8>,
    }
    impl FECModeRfc2733ModeModeSeparateStreamDifferentPort {
        pub fn new(protected_session_id: u8, protected_payload_type: Option<u8>) -> Self {
            Self {
                protected_session_id,
                protected_payload_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FECModeRfc2733ModeModeSeparateStreamSamePort {
        #[rasn(identifier = "protectedType")]
        pub protected_type: ModeElementType,
    }
    impl FECModeRfc2733ModeModeSeparateStreamSamePort {
        pub fn new(protected_type: ModeElementType) -> Self {
            Self { protected_type }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FECModeRfc2733ModeModeSeparateStream {
        differentPort(FECModeRfc2733ModeModeSeparateStreamDifferentPort),
        samePort(FECModeRfc2733ModeModeSeparateStreamSamePort),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FECModeRfc2733ModeMode {
        redundancyEncoding(()),
        separateStream(FECModeRfc2733ModeModeSeparateStream),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FECModeRfc2733Mode {
        pub mode: FECModeRfc2733ModeMode,
    }
    impl FECModeRfc2733Mode {
        pub fn new(mode: FECModeRfc2733ModeMode) -> Self {
            Self { mode }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FECMode {
        rfc2733Mode(FECModeRfc2733Mode),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum FlowControlCommandScope {
        logicalChannelNumber(LogicalChannelNumber),
        #[rasn(value("0..=65535"))]
        resourceID(u16),
        wholeMultiplex(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum FlowControlCommandRestriction {
        #[rasn(value("0..=16777215"))]
        maximumBitRate(u32),
        noRestriction(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : Flow Control"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FlowControlCommand {
        pub scope: FlowControlCommandScope,
        pub restriction: FlowControlCommandRestriction,
    }
    impl FlowControlCommand {
        pub fn new(
            scope: FlowControlCommandScope,
            restriction: FlowControlCommandRestriction,
        ) -> Self {
            Self { scope, restriction }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum FlowControlIndicationScope {
        logicalChannelNumber(LogicalChannelNumber),
        #[rasn(value("0..=65535"))]
        resourceID(u16),
        wholeMultiplex(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum FlowControlIndicationRestriction {
        #[rasn(value("0..=16777215"))]
        maximumBitRate(u32),
        noRestriction(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : Flow Control"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FlowControlIndication {
        pub scope: FlowControlIndicationScope,
        pub restriction: FlowControlIndicationRestriction,
    }
    impl FlowControlIndication {
        pub fn new(
            scope: FlowControlIndicationScope,
            restriction: FlowControlIndicationRestriction,
        ) -> Self {
            Self { scope, restriction }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FunctionNotSupportedCause {
        syntaxError(()),
        semanticError(()),
        unknownFunction(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : Function not Supported"]
    #[doc = " ==================================================================================="]
    #[doc = " This is used to return a complete request, response or command that is not recognized"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct FunctionNotSupported {
        pub cause: FunctionNotSupportedCause,
        #[rasn(identifier = "returnedFunction")]
        pub returned_function: Option<OctetString>,
    }
    impl FunctionNotSupported {
        pub fn new(
            cause: FunctionNotSupportedCause,
            returned_function: Option<OctetString>,
        ) -> Self {
            Self {
                cause,
                returned_function,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message definitions"]
    #[doc = " ==================================================================================="]
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : Function not understood"]
    #[doc = " ==================================================================================="]
    #[doc = " This is used to return a request, response or command that is not understood"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum FunctionNotUnderstood {
        request(RequestMessage),
        response(ResponseMessage),
        command(CommandMessage),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct G7231AnnexCCapabilityG723AnnexCAudioMode {
        #[rasn(value("27..=78"), identifier = "highRateMode0")]
        pub high_rate_mode0: u8,
        #[rasn(value("27..=78"), identifier = "highRateMode1")]
        pub high_rate_mode1: u8,
        #[rasn(value("23..=66"), identifier = "lowRateMode0")]
        pub low_rate_mode0: u8,
        #[rasn(value("23..=66"), identifier = "lowRateMode1")]
        pub low_rate_mode1: u8,
        #[rasn(value("6..=17"), identifier = "sidMode0")]
        pub sid_mode0: u8,
        #[rasn(value("6..=17"), identifier = "sidMode1")]
        pub sid_mode1: u8,
    }
    impl G7231AnnexCCapabilityG723AnnexCAudioMode {
        pub fn new(
            high_rate_mode0: u8,
            high_rate_mode1: u8,
            low_rate_mode0: u8,
            low_rate_mode1: u8,
            sid_mode0: u8,
            sid_mode1: u8,
        ) -> Self {
            Self {
                high_rate_mode0,
                high_rate_mode1,
                low_rate_mode0,
                low_rate_mode1,
                sid_mode0,
                sid_mode1,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct G7231AnnexCCapability {
        #[rasn(value("1..=256"), identifier = "maxAl-sduAudioFrames")]
        pub max_al_sdu_audio_frames: u16,
        #[rasn(identifier = "silenceSuppression")]
        pub silence_suppression: bool,
        #[rasn(identifier = "g723AnnexCAudioMode")]
        pub g723_annex_caudio_mode: Option<G7231AnnexCCapabilityG723AnnexCAudioMode>,
    }
    impl G7231AnnexCCapability {
        pub fn new(
            max_al_sdu_audio_frames: u16,
            silence_suppression: bool,
            g723_annex_caudio_mode: Option<G7231AnnexCCapabilityG723AnnexCAudioMode>,
        ) -> Self {
            Self {
                max_al_sdu_audio_frames,
                silence_suppression,
                g723_annex_caudio_mode,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct G7231AnnexCModeG723AnnexCAudioMode {
        #[rasn(value("27..=78"), identifier = "highRateMode0")]
        pub high_rate_mode0: u8,
        #[rasn(value("27..=78"), identifier = "highRateMode1")]
        pub high_rate_mode1: u8,
        #[rasn(value("23..=66"), identifier = "lowRateMode0")]
        pub low_rate_mode0: u8,
        #[rasn(value("23..=66"), identifier = "lowRateMode1")]
        pub low_rate_mode1: u8,
        #[rasn(value("6..=17"), identifier = "sidMode0")]
        pub sid_mode0: u8,
        #[rasn(value("6..=17"), identifier = "sidMode1")]
        pub sid_mode1: u8,
    }
    impl G7231AnnexCModeG723AnnexCAudioMode {
        pub fn new(
            high_rate_mode0: u8,
            high_rate_mode1: u8,
            low_rate_mode0: u8,
            low_rate_mode1: u8,
            sid_mode0: u8,
            sid_mode1: u8,
        ) -> Self {
            Self {
                high_rate_mode0,
                high_rate_mode1,
                low_rate_mode0,
                low_rate_mode1,
                sid_mode0,
                sid_mode1,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct G7231AnnexCMode {
        #[rasn(value("1..=256"), identifier = "maxAl-sduAudioFrames")]
        pub max_al_sdu_audio_frames: u16,
        #[rasn(identifier = "silenceSuppression")]
        pub silence_suppression: bool,
        #[rasn(identifier = "g723AnnexCAudioMode")]
        pub g723_annex_caudio_mode: G7231AnnexCModeG723AnnexCAudioMode,
    }
    impl G7231AnnexCMode {
        pub fn new(
            max_al_sdu_audio_frames: u16,
            silence_suppression: bool,
            g723_annex_caudio_mode: G7231AnnexCModeG723AnnexCAudioMode,
        ) -> Self {
            Self {
                max_al_sdu_audio_frames,
                silence_suppression,
                g723_annex_caudio_mode,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct G729Extensions {
        #[rasn(value("1..=256"), identifier = "audioUnit")]
        pub audio_unit: Option<u16>,
        #[rasn(identifier = "annexA")]
        pub annex_a: bool,
        #[rasn(identifier = "annexB")]
        pub annex_b: bool,
        #[rasn(identifier = "annexD")]
        pub annex_d: bool,
        #[rasn(identifier = "annexE")]
        pub annex_e: bool,
        #[rasn(identifier = "annexF")]
        pub annex_f: bool,
        #[rasn(identifier = "annexG")]
        pub annex_g: bool,
        #[rasn(identifier = "annexH")]
        pub annex_h: bool,
    }
    impl G729Extensions {
        pub fn new(
            audio_unit: Option<u16>,
            annex_a: bool,
            annex_b: bool,
            annex_d: bool,
            annex_e: bool,
            annex_f: bool,
            annex_g: bool,
            annex_h: bool,
        ) -> Self {
            Self {
                audio_unit,
                annex_a,
                annex_b,
                annex_d,
                annex_e,
                annex_f,
                annex_g,
                annex_h,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GSMAudioCapability {
        #[rasn(value("1..=256"), identifier = "audioUnitSize")]
        pub audio_unit_size: u16,
        #[rasn(identifier = "comfortNoise")]
        pub comfort_noise: bool,
        pub scrambled: bool,
    }
    impl GSMAudioCapability {
        pub fn new(audio_unit_size: u16, comfort_noise: bool, scrambled: bool) -> Self {
            Self {
                audio_unit_size,
                comfort_noise,
                scrambled,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability Exchange Definitions: Generic Capability"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GenericCapability {
        #[rasn(identifier = "capabilityIdentifier")]
        pub capability_identifier: CapabilityIdentifier,
        #[rasn(value("0..=4294967295"), identifier = "maxBitRate")]
        pub max_bit_rate: Option<u32>,
        pub collapsing: Option<SequenceOf<GenericParameter>>,
        #[rasn(identifier = "nonCollapsing")]
        pub non_collapsing: Option<SequenceOf<GenericParameter>>,
        #[rasn(identifier = "nonCollapsingRaw")]
        pub non_collapsing_raw: Option<OctetString>,
        pub transport: Option<DataProtocolCapability>,
    }
    impl GenericCapability {
        pub fn new(
            capability_identifier: CapabilityIdentifier,
            max_bit_rate: Option<u32>,
            collapsing: Option<SequenceOf<GenericParameter>>,
            non_collapsing: Option<SequenceOf<GenericParameter>>,
            non_collapsing_raw: Option<OctetString>,
            transport: Option<DataProtocolCapability>,
        ) -> Self {
            Self {
                capability_identifier,
                max_bit_rate,
                collapsing,
                non_collapsing,
                non_collapsing_raw,
                transport,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Generic Message definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GenericMessage {
        #[rasn(identifier = "messageIdentifier")]
        pub message_identifier: CapabilityIdentifier,
        #[rasn(value("0..=127"), identifier = "subMessageIdentifer")]
        pub sub_message_identifer: Option<u8>,
        #[rasn(identifier = "messageContent")]
        pub message_content: Option<SequenceOf<GenericParameter>>,
    }
    impl GenericMessage {
        pub fn new(
            message_identifier: CapabilityIdentifier,
            sub_message_identifer: Option<u8>,
            message_content: Option<SequenceOf<GenericParameter>>,
        ) -> Self {
            Self {
                message_identifier,
                sub_message_identifer,
                message_content,
            }
        }
    }
    #[doc = " Note. The ranges of parameter values have been selected to ensure that the GenericParameter"]
    #[doc = " preamble, standard part of ParameterIdentifier and the encoding of that choice, and the preamble"]
    #[doc = " of ParameterValue to fit into 2 octets."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GenericParameter {
        #[rasn(identifier = "parameterIdentifier")]
        pub parameter_identifier: ParameterIdentifier,
        #[rasn(identifier = "parameterValue")]
        pub parameter_value: ParameterValue,
        pub supersedes: Option<SequenceOf<ParameterIdentifier>>,
    }
    impl GenericParameter {
        pub fn new(
            parameter_identifier: ParameterIdentifier,
            parameter_value: ParameterValue,
            supersedes: Option<SequenceOf<ParameterIdentifier>>,
        ) -> Self {
            Self {
                parameter_identifier,
                parameter_value,
                supersedes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H222Capability {
        #[rasn(value("1..=256"), identifier = "numberOfVCs")]
        pub number_of_vcs: u16,
        #[rasn(identifier = "vcCapability")]
        pub vc_capability: SetOf<VCCapability>,
    }
    impl H222Capability {
        pub fn new(number_of_vcs: u16, vc_capability: SetOf<VCCapability>) -> Self {
            Self {
                number_of_vcs,
                vc_capability,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H222LogicalChannelParameters {
        #[rasn(value("0..=65535"), identifier = "resourceID")]
        pub resource_id: u16,
        #[rasn(value("0..=8191"), identifier = "subChannelID")]
        pub sub_channel_id: u16,
        #[rasn(value("0..=8191"), identifier = "pcr-pid")]
        pub pcr_pid: Option<u16>,
        #[rasn(identifier = "programDescriptors")]
        pub program_descriptors: Option<OctetString>,
        #[rasn(identifier = "streamDescriptors")]
        pub stream_descriptors: Option<OctetString>,
    }
    impl H222LogicalChannelParameters {
        pub fn new(
            resource_id: u16,
            sub_channel_id: u16,
            pcr_pid: Option<u16>,
            program_descriptors: Option<OctetString>,
            stream_descriptors: Option<OctetString>,
        ) -> Self {
            Self {
                resource_id,
                sub_channel_id,
                pcr_pid,
                program_descriptors,
                stream_descriptors,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AL1MParametersTransferMode {
        framed(()),
        unframed(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AL1MParametersHeaderFEC {
        #[rasn(identifier = "sebch16-7")]
        sebch16_7(()),
        #[rasn(identifier = "golay24-12")]
        golay24_12(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AL1MParametersCrcLength {
        crc4bit(()),
        crc12bit(()),
        crc20bit(()),
        crc28bit(()),
        #[rasn(extension_addition)]
        crc8bit(()),
        #[rasn(extension_addition)]
        crc16bit(()),
        #[rasn(extension_addition)]
        crc32bit(()),
        #[rasn(extension_addition)]
        crcNotUsed(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AL1MParametersArqType {
        noArq(()),
        typeIArq(H223AnnexCArqParameters),
        typeIIArq(H223AnnexCArqParameters),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223AL1MParameters {
        #[rasn(identifier = "transferMode")]
        pub transfer_mode: H223AL1MParametersTransferMode,
        #[rasn(identifier = "headerFEC")]
        pub header_fec: H223AL1MParametersHeaderFEC,
        #[rasn(identifier = "crcLength")]
        pub crc_length: H223AL1MParametersCrcLength,
        #[rasn(value("8..=32"), identifier = "rcpcCodeRate")]
        pub rcpc_code_rate: u8,
        #[rasn(identifier = "arqType")]
        pub arq_type: H223AL1MParametersArqType,
        #[rasn(identifier = "alpduInterleaving")]
        pub alpdu_interleaving: bool,
        #[rasn(identifier = "alsduSplitting")]
        pub alsdu_splitting: bool,
        #[rasn(extension_addition, value("0..=127"), identifier = "rsCodeCorrection")]
        pub rs_code_correction: Option<u8>,
    }
    impl H223AL1MParameters {
        pub fn new(
            transfer_mode: H223AL1MParametersTransferMode,
            header_fec: H223AL1MParametersHeaderFEC,
            crc_length: H223AL1MParametersCrcLength,
            rcpc_code_rate: u8,
            arq_type: H223AL1MParametersArqType,
            alpdu_interleaving: bool,
            alsdu_splitting: bool,
            rs_code_correction: Option<u8>,
        ) -> Self {
            Self {
                transfer_mode,
                header_fec,
                crc_length,
                rcpc_code_rate,
                arq_type,
                alpdu_interleaving,
                alsdu_splitting,
                rs_code_correction,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AL2MParametersHeaderFEC {
        #[rasn(identifier = "sebch16-5")]
        sebch16_5(()),
        #[rasn(identifier = "golay24-12")]
        golay24_12(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223AL2MParameters {
        #[rasn(identifier = "headerFEC")]
        pub header_fec: H223AL2MParametersHeaderFEC,
        #[rasn(identifier = "alpduInterleaving")]
        pub alpdu_interleaving: bool,
    }
    impl H223AL2MParameters {
        pub fn new(header_fec: H223AL2MParametersHeaderFEC, alpdu_interleaving: bool) -> Self {
            Self {
                header_fec,
                alpdu_interleaving,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AL3MParametersHeaderFormat {
        #[rasn(identifier = "sebch16-7")]
        sebch16_7(()),
        #[rasn(identifier = "golay24-12")]
        golay24_12(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AL3MParametersCrcLength {
        crc4bit(()),
        crc12bit(()),
        crc20bit(()),
        crc28bit(()),
        #[rasn(extension_addition)]
        crc8bit(()),
        #[rasn(extension_addition)]
        crc16bit(()),
        #[rasn(extension_addition)]
        crc32bit(()),
        #[rasn(extension_addition)]
        crcNotUsed(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AL3MParametersArqType {
        noArq(()),
        typeIArq(H223AnnexCArqParameters),
        typeIIArq(H223AnnexCArqParameters),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223AL3MParameters {
        #[rasn(identifier = "headerFormat")]
        pub header_format: H223AL3MParametersHeaderFormat,
        #[rasn(identifier = "crcLength")]
        pub crc_length: H223AL3MParametersCrcLength,
        #[rasn(value("8..=32"), identifier = "rcpcCodeRate")]
        pub rcpc_code_rate: u8,
        #[rasn(identifier = "arqType")]
        pub arq_type: H223AL3MParametersArqType,
        #[rasn(identifier = "alpduInterleaving")]
        pub alpdu_interleaving: bool,
        #[rasn(extension_addition, value("0..=127"), identifier = "rsCodeCorrection")]
        pub rs_code_correction: Option<u8>,
    }
    impl H223AL3MParameters {
        pub fn new(
            header_format: H223AL3MParametersHeaderFormat,
            crc_length: H223AL3MParametersCrcLength,
            rcpc_code_rate: u8,
            arq_type: H223AL3MParametersArqType,
            alpdu_interleaving: bool,
            rs_code_correction: Option<u8>,
        ) -> Self {
            Self {
                header_format,
                crc_length,
                rcpc_code_rate,
                arq_type,
                alpdu_interleaving,
                rs_code_correction,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223AnnexCArqParametersNumberOfRetransmissions {
        #[rasn(value("0..=16"))]
        finite(u8),
        infinite(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223AnnexCArqParameters {
        #[rasn(identifier = "numberOfRetransmissions")]
        pub number_of_retransmissions: H223AnnexCArqParametersNumberOfRetransmissions,
        #[rasn(value("0..=16777215"), identifier = "sendBufferSize")]
        pub send_buffer_size: u32,
    }
    impl H223AnnexCArqParameters {
        pub fn new(
            number_of_retransmissions: H223AnnexCArqParametersNumberOfRetransmissions,
            send_buffer_size: u32,
        ) -> Self {
            Self {
                number_of_retransmissions,
                send_buffer_size,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223AnnexCCapability {
        #[rasn(identifier = "videoWithAL1M")]
        pub video_with_al1_m: bool,
        #[rasn(identifier = "videoWithAL2M")]
        pub video_with_al2_m: bool,
        #[rasn(identifier = "videoWithAL3M")]
        pub video_with_al3_m: bool,
        #[rasn(identifier = "audioWithAL1M")]
        pub audio_with_al1_m: bool,
        #[rasn(identifier = "audioWithAL2M")]
        pub audio_with_al2_m: bool,
        #[rasn(identifier = "audioWithAL3M")]
        pub audio_with_al3_m: bool,
        #[rasn(identifier = "dataWithAL1M")]
        pub data_with_al1_m: bool,
        #[rasn(identifier = "dataWithAL2M")]
        pub data_with_al2_m: bool,
        #[rasn(identifier = "dataWithAL3M")]
        pub data_with_al3_m: bool,
        #[rasn(identifier = "alpduInterleaving")]
        pub alpdu_interleaving: bool,
        #[rasn(value("0..=65535"), identifier = "maximumAL1MPDUSize")]
        pub maximum_al1_mpdusize: u16,
        #[rasn(value("0..=65535"), identifier = "maximumAL2MSDUSize")]
        pub maximum_al2_msdusize: u16,
        #[rasn(value("0..=65535"), identifier = "maximumAL3MSDUSize")]
        pub maximum_al3_msdusize: u16,
        #[rasn(extension_addition, identifier = "rsCodeCapability")]
        pub rs_code_capability: Option<bool>,
    }
    impl H223AnnexCCapability {
        pub fn new(
            video_with_al1_m: bool,
            video_with_al2_m: bool,
            video_with_al3_m: bool,
            audio_with_al1_m: bool,
            audio_with_al2_m: bool,
            audio_with_al3_m: bool,
            data_with_al1_m: bool,
            data_with_al2_m: bool,
            data_with_al3_m: bool,
            alpdu_interleaving: bool,
            maximum_al1_mpdusize: u16,
            maximum_al2_msdusize: u16,
            maximum_al3_msdusize: u16,
            rs_code_capability: Option<bool>,
        ) -> Self {
            Self {
                video_with_al1_m,
                video_with_al2_m,
                video_with_al3_m,
                audio_with_al1_m,
                audio_with_al2_m,
                audio_with_al3_m,
                data_with_al1_m,
                data_with_al2_m,
                data_with_al3_m,
                alpdu_interleaving,
                maximum_al1_mpdusize,
                maximum_al2_msdusize,
                maximum_al3_msdusize,
                rs_code_capability,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223CapabilityH223MultiplexTableCapabilityEnhanced {
        #[rasn(value("1..=15"), identifier = "maximumNestingDepth")]
        pub maximum_nesting_depth: u8,
        #[rasn(value("2..=255"), identifier = "maximumElementListSize")]
        pub maximum_element_list_size: u8,
        #[rasn(value("2..=255"), identifier = "maximumSubElementListSize")]
        pub maximum_sub_element_list_size: u8,
    }
    impl H223CapabilityH223MultiplexTableCapabilityEnhanced {
        pub fn new(
            maximum_nesting_depth: u8,
            maximum_element_list_size: u8,
            maximum_sub_element_list_size: u8,
        ) -> Self {
            Self {
                maximum_nesting_depth,
                maximum_element_list_size,
                maximum_sub_element_list_size,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum H223CapabilityH223MultiplexTableCapability {
        basic(()),
        enhanced(H223CapabilityH223MultiplexTableCapabilityEnhanced),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223CapabilityMobileOperationTransmitCapability {
        #[rasn(identifier = "modeChangeCapability")]
        pub mode_change_capability: bool,
        #[rasn(identifier = "h223AnnexA")]
        pub h223_annex_a: bool,
        #[rasn(identifier = "h223AnnexADoubleFlag")]
        pub h223_annex_adouble_flag: bool,
        #[rasn(identifier = "h223AnnexB")]
        pub h223_annex_b: bool,
        #[rasn(identifier = "h223AnnexBwithHeader")]
        pub h223_annex_bwith_header: bool,
    }
    impl H223CapabilityMobileOperationTransmitCapability {
        pub fn new(
            mode_change_capability: bool,
            h223_annex_a: bool,
            h223_annex_adouble_flag: bool,
            h223_annex_b: bool,
            h223_annex_bwith_header: bool,
        ) -> Self {
            Self {
                mode_change_capability,
                h223_annex_a,
                h223_annex_adouble_flag,
                h223_annex_b,
                h223_annex_bwith_header,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223CapabilityMobileMultilinkFrameCapability {
        #[rasn(value("1..=255"), identifier = "maximumSampleSize")]
        pub maximum_sample_size: u8,
        #[rasn(value("1..=65025"), identifier = "maximumPayloadLength")]
        pub maximum_payload_length: u16,
    }
    impl H223CapabilityMobileMultilinkFrameCapability {
        pub fn new(maximum_sample_size: u8, maximum_payload_length: u16) -> Self {
            Self {
                maximum_sample_size,
                maximum_payload_length,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223Capability {
        #[rasn(identifier = "transportWithI-frames")]
        pub transport_with_i_frames: bool,
        #[rasn(identifier = "videoWithAL1")]
        pub video_with_al1: bool,
        #[rasn(identifier = "videoWithAL2")]
        pub video_with_al2: bool,
        #[rasn(identifier = "videoWithAL3")]
        pub video_with_al3: bool,
        #[rasn(identifier = "audioWithAL1")]
        pub audio_with_al1: bool,
        #[rasn(identifier = "audioWithAL2")]
        pub audio_with_al2: bool,
        #[rasn(identifier = "audioWithAL3")]
        pub audio_with_al3: bool,
        #[rasn(identifier = "dataWithAL1")]
        pub data_with_al1: bool,
        #[rasn(identifier = "dataWithAL2")]
        pub data_with_al2: bool,
        #[rasn(identifier = "dataWithAL3")]
        pub data_with_al3: bool,
        #[rasn(value("0..=65535"), identifier = "maximumAl2SDUSize")]
        pub maximum_al2_sdusize: u16,
        #[rasn(value("0..=65535"), identifier = "maximumAl3SDUSize")]
        pub maximum_al3_sdusize: u16,
        #[rasn(value("0..=1023"), identifier = "maximumDelayJitter")]
        pub maximum_delay_jitter: u16,
        #[rasn(identifier = "h223MultiplexTableCapability")]
        pub h223_multiplex_table_capability: H223CapabilityH223MultiplexTableCapability,
        #[rasn(extension_addition, identifier = "maxMUXPDUSizeCapability")]
        pub max_muxpdusize_capability: bool,
        #[rasn(extension_addition, identifier = "nsrpSupport")]
        pub nsrp_support: bool,
        #[rasn(extension_addition, identifier = "mobileOperationTransmitCapability")]
        pub mobile_operation_transmit_capability:
            Option<H223CapabilityMobileOperationTransmitCapability>,
        #[rasn(extension_addition, identifier = "h223AnnexCCapability")]
        pub h223_annex_ccapability: Option<H223AnnexCCapability>,
        #[rasn(extension_addition, value("1..=19200"), identifier = "bitRate")]
        pub bit_rate: Option<u16>,
        #[rasn(extension_addition, identifier = "mobileMultilinkFrameCapability")]
        pub mobile_multilink_frame_capability: Option<H223CapabilityMobileMultilinkFrameCapability>,
    }
    impl H223Capability {
        pub fn new(
            transport_with_i_frames: bool,
            video_with_al1: bool,
            video_with_al2: bool,
            video_with_al3: bool,
            audio_with_al1: bool,
            audio_with_al2: bool,
            audio_with_al3: bool,
            data_with_al1: bool,
            data_with_al2: bool,
            data_with_al3: bool,
            maximum_al2_sdusize: u16,
            maximum_al3_sdusize: u16,
            maximum_delay_jitter: u16,
            h223_multiplex_table_capability: H223CapabilityH223MultiplexTableCapability,
            max_muxpdusize_capability: bool,
            nsrp_support: bool,
            mobile_operation_transmit_capability: Option<
                H223CapabilityMobileOperationTransmitCapability,
            >,
            h223_annex_ccapability: Option<H223AnnexCCapability>,
            bit_rate: Option<u16>,
            mobile_multilink_frame_capability: Option<H223CapabilityMobileMultilinkFrameCapability>,
        ) -> Self {
            Self {
                transport_with_i_frames,
                video_with_al1,
                video_with_al2,
                video_with_al3,
                audio_with_al1,
                audio_with_al2,
                audio_with_al3,
                data_with_al1,
                data_with_al2,
                data_with_al3,
                maximum_al2_sdusize,
                maximum_al3_sdusize,
                maximum_delay_jitter,
                h223_multiplex_table_capability,
                max_muxpdusize_capability,
                nsrp_support,
                mobile_operation_transmit_capability,
                h223_annex_ccapability,
                bit_rate,
                mobile_multilink_frame_capability,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct H223LogicalChannelParametersAdaptationLayerTypeAl3 {
        #[rasn(value("0..=2"), identifier = "controlFieldOctets")]
        pub control_field_octets: u8,
        #[rasn(value("0..=16777215"), identifier = "sendBufferSize")]
        pub send_buffer_size: u32,
    }
    impl H223LogicalChannelParametersAdaptationLayerTypeAl3 {
        pub fn new(control_field_octets: u8, send_buffer_size: u32) -> Self {
            Self {
                control_field_octets,
                send_buffer_size,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223LogicalChannelParametersAdaptationLayerType {
        nonStandard(NonStandardParameter),
        al1Framed(()),
        al1NotFramed(()),
        al2WithoutSequenceNumbers(()),
        al2WithSequenceNumbers(()),
        al3(H223LogicalChannelParametersAdaptationLayerTypeAl3),
        #[rasn(extension_addition)]
        al1M(H223AL1MParameters),
        #[rasn(extension_addition)]
        al2M(H223AL2MParameters),
        #[rasn(extension_addition)]
        al3M(H223AL3MParameters),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223LogicalChannelParameters {
        #[rasn(identifier = "adaptationLayerType")]
        pub adaptation_layer_type: H223LogicalChannelParametersAdaptationLayerType,
        #[rasn(identifier = "segmentableFlag")]
        pub segmentable_flag: bool,
    }
    impl H223LogicalChannelParameters {
        pub fn new(
            adaptation_layer_type: H223LogicalChannelParametersAdaptationLayerType,
            segmentable_flag: bool,
        ) -> Self {
            Self {
                adaptation_layer_type,
                segmentable_flag,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct H223ModeParametersAdaptationLayerTypeAl3 {
        #[rasn(value("0..=2"), identifier = "controlFieldOctets")]
        pub control_field_octets: u8,
        #[rasn(value("0..=16777215"), identifier = "sendBufferSize")]
        pub send_buffer_size: u32,
    }
    impl H223ModeParametersAdaptationLayerTypeAl3 {
        pub fn new(control_field_octets: u8, send_buffer_size: u32) -> Self {
            Self {
                control_field_octets,
                send_buffer_size,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223ModeParametersAdaptationLayerType {
        nonStandard(NonStandardParameter),
        al1Framed(()),
        al1NotFramed(()),
        al2WithoutSequenceNumbers(()),
        al2WithSequenceNumbers(()),
        al3(H223ModeParametersAdaptationLayerTypeAl3),
        #[rasn(extension_addition)]
        al1M(H223AL1MParameters),
        #[rasn(extension_addition)]
        al2M(H223AL2MParameters),
        #[rasn(extension_addition)]
        al3M(H223AL3MParameters),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223ModeParameters {
        #[rasn(identifier = "adaptationLayerType")]
        pub adaptation_layer_type: H223ModeParametersAdaptationLayerType,
        #[rasn(identifier = "segmentableFlag")]
        pub segmentable_flag: bool,
    }
    impl H223ModeParameters {
        pub fn new(
            adaptation_layer_type: H223ModeParametersAdaptationLayerType,
            segmentable_flag: bool,
        ) -> Self {
            Self {
                adaptation_layer_type,
                segmentable_flag,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223MultiplexReconfigurationH223ModeChange {
        toLevel0(()),
        toLevel1(()),
        toLevel2(()),
        toLevel2withOptionalHeader(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223MultiplexReconfigurationH223AnnexADoubleFlag {
        start(()),
        stop(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : H.223 Multiplex Reconfiguration"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H223MultiplexReconfiguration {
        h223ModeChange(H223MultiplexReconfigurationH223ModeChange),
        h223AnnexADoubleFlag(H223MultiplexReconfigurationH223AnnexADoubleFlag),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : H.223 logical channel skew"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H223SkewIndication {
        #[rasn(identifier = "logicalChannelNumber1")]
        pub logical_channel_number1: LogicalChannelNumber,
        #[rasn(identifier = "logicalChannelNumber2")]
        pub logical_channel_number2: LogicalChannelNumber,
        #[rasn(value("0..=4095"))]
        pub skew: u16,
    }
    impl H223SkewIndication {
        pub fn new(
            logical_channel_number1: LogicalChannelNumber,
            logical_channel_number2: LogicalChannelNumber,
            skew: u16,
        ) -> Self {
            Self {
                logical_channel_number1,
                logical_channel_number2,
                skew,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H2250CapabilityMcCapability {
        #[rasn(identifier = "centralizedConferenceMC")]
        pub centralized_conference_mc: bool,
        #[rasn(identifier = "decentralizedConferenceMC")]
        pub decentralized_conference_mc: bool,
    }
    impl H2250CapabilityMcCapability {
        pub fn new(centralized_conference_mc: bool, decentralized_conference_mc: bool) -> Self {
            Self {
                centralized_conference_mc,
                decentralized_conference_mc,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H2250Capability {
        #[rasn(value("0..=1023"), identifier = "maximumAudioDelayJitter")]
        pub maximum_audio_delay_jitter: u16,
        #[rasn(identifier = "receiveMultipointCapability")]
        pub receive_multipoint_capability: MultipointCapability,
        #[rasn(identifier = "transmitMultipointCapability")]
        pub transmit_multipoint_capability: MultipointCapability,
        #[rasn(identifier = "receiveAndTransmitMultipointCapability")]
        pub receive_and_transmit_multipoint_capability: MultipointCapability,
        #[rasn(identifier = "mcCapability")]
        pub mc_capability: H2250CapabilityMcCapability,
        #[rasn(identifier = "rtcpVideoControlCapability")]
        pub rtcp_video_control_capability: bool,
        #[rasn(identifier = "mediaPacketizationCapability")]
        pub media_packetization_capability: MediaPacketizationCapability,
        #[rasn(extension_addition, identifier = "transportCapability")]
        pub transport_capability: Option<TransportCapability>,
        #[rasn(
            extension_addition,
            size("1..=256"),
            identifier = "redundancyEncodingCapability"
        )]
        pub redundancy_encoding_capability: Option<SequenceOf<RedundancyEncodingCapability>>,
        #[rasn(extension_addition, identifier = "logicalChannelSwitchingCapability")]
        pub logical_channel_switching_capability: bool,
        #[rasn(extension_addition, identifier = "t120DynamicPortCapability")]
        pub t120_dynamic_port_capability: bool,
    }
    impl H2250Capability {
        pub fn new(
            maximum_audio_delay_jitter: u16,
            receive_multipoint_capability: MultipointCapability,
            transmit_multipoint_capability: MultipointCapability,
            receive_and_transmit_multipoint_capability: MultipointCapability,
            mc_capability: H2250CapabilityMcCapability,
            rtcp_video_control_capability: bool,
            media_packetization_capability: MediaPacketizationCapability,
            transport_capability: Option<TransportCapability>,
            redundancy_encoding_capability: Option<SequenceOf<RedundancyEncodingCapability>>,
            logical_channel_switching_capability: bool,
            t120_dynamic_port_capability: bool,
        ) -> Self {
            Self {
                maximum_audio_delay_jitter,
                receive_multipoint_capability,
                transmit_multipoint_capability,
                receive_and_transmit_multipoint_capability,
                mc_capability,
                rtcp_video_control_capability,
                media_packetization_capability,
                transport_capability,
                redundancy_encoding_capability,
                logical_channel_switching_capability,
                t120_dynamic_port_capability,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H2250LogicalChannelAckParameters {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
        #[rasn(value("1..=255"), identifier = "sessionID")]
        pub session_id: Option<u8>,
        #[rasn(identifier = "mediaChannel")]
        pub media_channel: Option<TransportAddress>,
        #[rasn(identifier = "mediaControlChannel")]
        pub media_control_channel: Option<TransportAddress>,
        #[rasn(value("96..=127"), identifier = "dynamicRTPPayloadType")]
        pub dynamic_rtppayload_type: Option<u8>,
        #[rasn(extension_addition, identifier = "flowControlToZero")]
        pub flow_control_to_zero: bool,
        #[rasn(extension_addition, value("0..=65535"), identifier = "portNumber")]
        pub port_number: Option<u16>,
    }
    impl H2250LogicalChannelAckParameters {
        pub fn new(
            non_standard: Option<SequenceOf<NonStandardParameter>>,
            session_id: Option<u8>,
            media_channel: Option<TransportAddress>,
            media_control_channel: Option<TransportAddress>,
            dynamic_rtppayload_type: Option<u8>,
            flow_control_to_zero: bool,
            port_number: Option<u16>,
        ) -> Self {
            Self {
                non_standard,
                session_id,
                media_channel,
                media_control_channel,
                dynamic_rtppayload_type,
                flow_control_to_zero,
                port_number,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H2250LogicalChannelParametersMediaPacketization {
        h261aVideoPacketization(()),
        #[rasn(extension_addition)]
        rtpPayloadType(RTPPayloadType),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H2250LogicalChannelParameters {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<SequenceOf<NonStandardParameter>>,
        #[rasn(value("0..=255"), identifier = "sessionID")]
        pub session_id: u8,
        #[rasn(value("1..=255"), identifier = "associatedSessionID")]
        pub associated_session_id: Option<u8>,
        #[rasn(identifier = "mediaChannel")]
        pub media_channel: Option<TransportAddress>,
        #[rasn(identifier = "mediaGuaranteedDelivery")]
        pub media_guaranteed_delivery: Option<bool>,
        #[rasn(identifier = "mediaControlChannel")]
        pub media_control_channel: Option<TransportAddress>,
        #[rasn(identifier = "mediaControlGuaranteedDelivery")]
        pub media_control_guaranteed_delivery: Option<bool>,
        #[rasn(identifier = "silenceSuppression")]
        pub silence_suppression: Option<bool>,
        pub destination: Option<TerminalLabel>,
        #[rasn(value("96..=127"), identifier = "dynamicRTPPayloadType")]
        pub dynamic_rtppayload_type: Option<u8>,
        #[rasn(identifier = "mediaPacketization")]
        pub media_packetization: Option<H2250LogicalChannelParametersMediaPacketization>,
        #[rasn(extension_addition, identifier = "transportCapability")]
        pub transport_capability: Option<TransportCapability>,
        #[rasn(extension_addition, identifier = "redundancyEncoding")]
        pub redundancy_encoding: Option<RedundancyEncoding>,
        #[rasn(extension_addition)]
        pub source: Option<TerminalLabel>,
    }
    impl H2250LogicalChannelParameters {
        pub fn new(
            non_standard: Option<SequenceOf<NonStandardParameter>>,
            session_id: u8,
            associated_session_id: Option<u8>,
            media_channel: Option<TransportAddress>,
            media_guaranteed_delivery: Option<bool>,
            media_control_channel: Option<TransportAddress>,
            media_control_guaranteed_delivery: Option<bool>,
            silence_suppression: Option<bool>,
            destination: Option<TerminalLabel>,
            dynamic_rtppayload_type: Option<u8>,
            media_packetization: Option<H2250LogicalChannelParametersMediaPacketization>,
            transport_capability: Option<TransportCapability>,
            redundancy_encoding: Option<RedundancyEncoding>,
            source: Option<TerminalLabel>,
        ) -> Self {
            Self {
                non_standard,
                session_id,
                associated_session_id,
                media_channel,
                media_guaranteed_delivery,
                media_control_channel,
                media_control_guaranteed_delivery,
                silence_suppression,
                destination,
                dynamic_rtppayload_type,
                media_packetization,
                transport_capability,
                redundancy_encoding,
                source,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : H.225.0 maximum logical channel skew"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H2250MaximumSkewIndication {
        #[rasn(identifier = "logicalChannelNumber1")]
        pub logical_channel_number1: LogicalChannelNumber,
        #[rasn(identifier = "logicalChannelNumber2")]
        pub logical_channel_number2: LogicalChannelNumber,
        #[rasn(value("0..=4095"), identifier = "maximumSkew")]
        pub maximum_skew: u16,
    }
    impl H2250MaximumSkewIndication {
        pub fn new(
            logical_channel_number1: LogicalChannelNumber,
            logical_channel_number2: LogicalChannelNumber,
            maximum_skew: u16,
        ) -> Self {
            Self {
                logical_channel_number1,
                logical_channel_number2,
                maximum_skew,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H2250ModeParameters {
        #[rasn(identifier = "redundancyEncodingMode")]
        pub redundancy_encoding_mode: Option<RedundancyEncodingMode>,
    }
    impl H2250ModeParameters {
        pub fn new(redundancy_encoding_mode: Option<RedundancyEncodingMode>) -> Self {
            Self {
                redundancy_encoding_mode,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H235MediaMediaType {
        nonStandard(NonStandardParameter),
        videoData(VideoCapability),
        audioData(AudioCapability),
        data(DataApplicationCapability),
        #[rasn(extension_addition)]
        redundancyEncoding(RedundancyEncoding),
        #[rasn(extension_addition)]
        multiplePayloadStream(MultiplePayloadStream),
        #[rasn(extension_addition)]
        fec(FECData),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H235Media {
        #[rasn(identifier = "encryptionAuthenticationAndIntegrity")]
        pub encryption_authentication_and_integrity: EncryptionAuthenticationAndIntegrity,
        #[rasn(identifier = "mediaType")]
        pub media_type: H235MediaMediaType,
    }
    impl H235Media {
        pub fn new(
            encryption_authentication_and_integrity: EncryptionAuthenticationAndIntegrity,
            media_type: H235MediaMediaType,
        ) -> Self {
            Self {
                encryption_authentication_and_integrity,
                media_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H235ModeMediaMode {
        nonStandard(NonStandardParameter),
        videoMode(VideoMode),
        audioMode(AudioMode),
        dataMode(DataMode),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H235Mode {
        #[rasn(identifier = "encryptionAuthenticationAndIntegrity")]
        pub encryption_authentication_and_integrity: EncryptionAuthenticationAndIntegrity,
        #[rasn(identifier = "mediaMode")]
        pub media_mode: H235ModeMediaMode,
    }
    impl H235Mode {
        pub fn new(
            encryption_authentication_and_integrity: EncryptionAuthenticationAndIntegrity,
            media_mode: H235ModeMediaMode,
        ) -> Self {
            Self {
                encryption_authentication_and_integrity,
                media_mode,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H235SecurityCapability {
        #[rasn(identifier = "encryptionAuthenticationAndIntegrity")]
        pub encryption_authentication_and_integrity: EncryptionAuthenticationAndIntegrity,
        #[rasn(identifier = "mediaCapability")]
        pub media_capability: CapabilityTableEntryNumber,
    }
    impl H235SecurityCapability {
        pub fn new(
            encryption_authentication_and_integrity: EncryptionAuthenticationAndIntegrity,
            media_capability: CapabilityTableEntryNumber,
        ) -> Self {
            Self {
                encryption_authentication_and_integrity,
                media_capability,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H261VideoCapability {
        #[rasn(value("1..=4"), identifier = "qcifMPI")]
        pub qcif_mpi: Option<u8>,
        #[rasn(value("1..=4"), identifier = "cifMPI")]
        pub cif_mpi: Option<u8>,
        #[rasn(identifier = "temporalSpatialTradeOffCapability")]
        pub temporal_spatial_trade_off_capability: bool,
        #[rasn(value("1..=19200"), identifier = "maxBitRate")]
        pub max_bit_rate: u16,
        #[rasn(identifier = "stillImageTransmission")]
        pub still_image_transmission: bool,
        #[rasn(extension_addition, identifier = "videoBadMBsCap")]
        pub video_bad_mbs_cap: bool,
    }
    impl H261VideoCapability {
        pub fn new(
            qcif_mpi: Option<u8>,
            cif_mpi: Option<u8>,
            temporal_spatial_trade_off_capability: bool,
            max_bit_rate: u16,
            still_image_transmission: bool,
            video_bad_mbs_cap: bool,
        ) -> Self {
            Self {
                qcif_mpi,
                cif_mpi,
                temporal_spatial_trade_off_capability,
                max_bit_rate,
                still_image_transmission,
                video_bad_mbs_cap,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum H261VideoModeResolution {
        qcif(()),
        cif(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H261VideoMode {
        pub resolution: H261VideoModeResolution,
        #[rasn(value("1..=19200"), identifier = "bitRate")]
        pub bit_rate: u16,
        #[rasn(identifier = "stillImageTransmission")]
        pub still_image_transmission: bool,
    }
    impl H261VideoMode {
        pub fn new(
            resolution: H261VideoModeResolution,
            bit_rate: u16,
            still_image_transmission: bool,
        ) -> Self {
            Self {
                resolution,
                bit_rate,
                still_image_transmission,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H262VideoCapability {
        #[rasn(identifier = "profileAndLevel-SPatML")]
        pub profile_and_level_spat_ml: bool,
        #[rasn(identifier = "profileAndLevel-MPatLL")]
        pub profile_and_level_mpat_ll: bool,
        #[rasn(identifier = "profileAndLevel-MPatML")]
        pub profile_and_level_mpat_ml: bool,
        #[rasn(identifier = "profileAndLevel-MPatH-14")]
        pub profile_and_level_mpat_h_14: bool,
        #[rasn(identifier = "profileAndLevel-MPatHL")]
        pub profile_and_level_mpat_hl: bool,
        #[rasn(identifier = "profileAndLevel-SNRatLL")]
        pub profile_and_level_snrat_ll: bool,
        #[rasn(identifier = "profileAndLevel-SNRatML")]
        pub profile_and_level_snrat_ml: bool,
        #[rasn(identifier = "profileAndLevel-SpatialatH-14")]
        pub profile_and_level_spatialat_h_14: bool,
        #[rasn(identifier = "profileAndLevel-HPatML")]
        pub profile_and_level_hpat_ml: bool,
        #[rasn(identifier = "profileAndLevel-HPatH-14")]
        pub profile_and_level_hpat_h_14: bool,
        #[rasn(identifier = "profileAndLevel-HPatHL")]
        pub profile_and_level_hpat_hl: bool,
        #[rasn(value("0..=1073741823"), identifier = "videoBitRate")]
        pub video_bit_rate: Option<u32>,
        #[rasn(value("0..=262143"), identifier = "vbvBufferSize")]
        pub vbv_buffer_size: Option<u32>,
        #[rasn(value("0..=16383"), identifier = "samplesPerLine")]
        pub samples_per_line: Option<u16>,
        #[rasn(value("0..=16383"), identifier = "linesPerFrame")]
        pub lines_per_frame: Option<u16>,
        #[rasn(value("0..=15"), identifier = "framesPerSecond")]
        pub frames_per_second: Option<u8>,
        #[rasn(value("0..=4294967295"), identifier = "luminanceSampleRate")]
        pub luminance_sample_rate: Option<u32>,
        #[rasn(extension_addition, identifier = "videoBadMBsCap")]
        pub video_bad_mbs_cap: bool,
    }
    impl H262VideoCapability {
        pub fn new(
            profile_and_level_spat_ml: bool,
            profile_and_level_mpat_ll: bool,
            profile_and_level_mpat_ml: bool,
            profile_and_level_mpat_h_14: bool,
            profile_and_level_mpat_hl: bool,
            profile_and_level_snrat_ll: bool,
            profile_and_level_snrat_ml: bool,
            profile_and_level_spatialat_h_14: bool,
            profile_and_level_hpat_ml: bool,
            profile_and_level_hpat_h_14: bool,
            profile_and_level_hpat_hl: bool,
            video_bit_rate: Option<u32>,
            vbv_buffer_size: Option<u32>,
            samples_per_line: Option<u16>,
            lines_per_frame: Option<u16>,
            frames_per_second: Option<u8>,
            luminance_sample_rate: Option<u32>,
            video_bad_mbs_cap: bool,
        ) -> Self {
            Self {
                profile_and_level_spat_ml,
                profile_and_level_mpat_ll,
                profile_and_level_mpat_ml,
                profile_and_level_mpat_h_14,
                profile_and_level_mpat_hl,
                profile_and_level_snrat_ll,
                profile_and_level_snrat_ml,
                profile_and_level_spatialat_h_14,
                profile_and_level_hpat_ml,
                profile_and_level_hpat_h_14,
                profile_and_level_hpat_hl,
                video_bit_rate,
                vbv_buffer_size,
                samples_per_line,
                lines_per_frame,
                frames_per_second,
                luminance_sample_rate,
                video_bad_mbs_cap,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H262VideoModeProfileAndLevel {
        #[rasn(identifier = "profileAndLevel-SPatML")]
        profileAndLevel_SPatML(()),
        #[rasn(identifier = "profileAndLevel-MPatLL")]
        profileAndLevel_MPatLL(()),
        #[rasn(identifier = "profileAndLevel-MPatML")]
        profileAndLevel_MPatML(()),
        #[rasn(identifier = "profileAndLevel-MPatH-14")]
        profileAndLevel_MPatH_14(()),
        #[rasn(identifier = "profileAndLevel-MPatHL")]
        profileAndLevel_MPatHL(()),
        #[rasn(identifier = "profileAndLevel-SNRatLL")]
        profileAndLevel_SNRatLL(()),
        #[rasn(identifier = "profileAndLevel-SNRatML")]
        profileAndLevel_SNRatML(()),
        #[rasn(identifier = "profileAndLevel-SpatialatH-14")]
        profileAndLevel_SpatialatH_14(()),
        #[rasn(identifier = "profileAndLevel-HPatML")]
        profileAndLevel_HPatML(()),
        #[rasn(identifier = "profileAndLevel-HPatH-14")]
        profileAndLevel_HPatH_14(()),
        #[rasn(identifier = "profileAndLevel-HPatHL")]
        profileAndLevel_HPatHL(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H262VideoMode {
        #[rasn(identifier = "profileAndLevel")]
        pub profile_and_level: H262VideoModeProfileAndLevel,
        #[rasn(value("0..=1073741823"), identifier = "videoBitRate")]
        pub video_bit_rate: Option<u32>,
        #[rasn(value("0..=262143"), identifier = "vbvBufferSize")]
        pub vbv_buffer_size: Option<u32>,
        #[rasn(value("0..=16383"), identifier = "samplesPerLine")]
        pub samples_per_line: Option<u16>,
        #[rasn(value("0..=16383"), identifier = "linesPerFrame")]
        pub lines_per_frame: Option<u16>,
        #[rasn(value("0..=15"), identifier = "framesPerSecond")]
        pub frames_per_second: Option<u8>,
        #[rasn(value("0..=4294967295"), identifier = "luminanceSampleRate")]
        pub luminance_sample_rate: Option<u32>,
    }
    impl H262VideoMode {
        pub fn new(
            profile_and_level: H262VideoModeProfileAndLevel,
            video_bit_rate: Option<u32>,
            vbv_buffer_size: Option<u32>,
            samples_per_line: Option<u16>,
            lines_per_frame: Option<u16>,
            frames_per_second: Option<u8>,
            luminance_sample_rate: Option<u32>,
        ) -> Self {
            Self {
                profile_and_level,
                video_bit_rate,
                vbv_buffer_size,
                samples_per_line,
                lines_per_frame,
                frames_per_second,
                luminance_sample_rate,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H263ModeComboFlags {
        #[rasn(identifier = "unrestrictedVector")]
        pub unrestricted_vector: bool,
        #[rasn(identifier = "arithmeticCoding")]
        pub arithmetic_coding: bool,
        #[rasn(identifier = "advancedPrediction")]
        pub advanced_prediction: bool,
        #[rasn(identifier = "pbFrames")]
        pub pb_frames: bool,
        #[rasn(identifier = "advancedIntraCodingMode")]
        pub advanced_intra_coding_mode: bool,
        #[rasn(identifier = "deblockingFilterMode")]
        pub deblocking_filter_mode: bool,
        #[rasn(identifier = "unlimitedMotionVectors")]
        pub unlimited_motion_vectors: bool,
        #[rasn(identifier = "slicesInOrder-NonRect")]
        pub slices_in_order_non_rect: bool,
        #[rasn(identifier = "slicesInOrder-Rect")]
        pub slices_in_order_rect: bool,
        #[rasn(identifier = "slicesNoOrder-NonRect")]
        pub slices_no_order_non_rect: bool,
        #[rasn(identifier = "slicesNoOrder-Rect")]
        pub slices_no_order_rect: bool,
        #[rasn(identifier = "improvedPBFramesMode")]
        pub improved_pbframes_mode: bool,
        #[rasn(identifier = "referencePicSelect")]
        pub reference_pic_select: bool,
        #[rasn(identifier = "dynamicPictureResizingByFour")]
        pub dynamic_picture_resizing_by_four: bool,
        #[rasn(identifier = "dynamicPictureResizingSixteenthPel")]
        pub dynamic_picture_resizing_sixteenth_pel: bool,
        #[rasn(identifier = "dynamicWarpingHalfPel")]
        pub dynamic_warping_half_pel: bool,
        #[rasn(identifier = "dynamicWarpingSixteenthPel")]
        pub dynamic_warping_sixteenth_pel: bool,
        #[rasn(identifier = "reducedResolutionUpdate")]
        pub reduced_resolution_update: bool,
        #[rasn(identifier = "independentSegmentDecoding")]
        pub independent_segment_decoding: bool,
        #[rasn(identifier = "alternateInterVLCMode")]
        pub alternate_inter_vlcmode: bool,
        #[rasn(identifier = "modifiedQuantizationMode")]
        pub modified_quantization_mode: bool,
        #[rasn(extension_addition, identifier = "enhancedReferencePicSelect")]
        pub enhanced_reference_pic_select: bool,
        #[rasn(extension_addition, identifier = "h263Version3Options")]
        pub h263_version3_options: H263Version3Options,
    }
    impl H263ModeComboFlags {
        pub fn new(
            unrestricted_vector: bool,
            arithmetic_coding: bool,
            advanced_prediction: bool,
            pb_frames: bool,
            advanced_intra_coding_mode: bool,
            deblocking_filter_mode: bool,
            unlimited_motion_vectors: bool,
            slices_in_order_non_rect: bool,
            slices_in_order_rect: bool,
            slices_no_order_non_rect: bool,
            slices_no_order_rect: bool,
            improved_pbframes_mode: bool,
            reference_pic_select: bool,
            dynamic_picture_resizing_by_four: bool,
            dynamic_picture_resizing_sixteenth_pel: bool,
            dynamic_warping_half_pel: bool,
            dynamic_warping_sixteenth_pel: bool,
            reduced_resolution_update: bool,
            independent_segment_decoding: bool,
            alternate_inter_vlcmode: bool,
            modified_quantization_mode: bool,
            enhanced_reference_pic_select: bool,
            h263_version3_options: H263Version3Options,
        ) -> Self {
            Self {
                unrestricted_vector,
                arithmetic_coding,
                advanced_prediction,
                pb_frames,
                advanced_intra_coding_mode,
                deblocking_filter_mode,
                unlimited_motion_vectors,
                slices_in_order_non_rect,
                slices_in_order_rect,
                slices_no_order_non_rect,
                slices_no_order_rect,
                improved_pbframes_mode,
                reference_pic_select,
                dynamic_picture_resizing_by_four,
                dynamic_picture_resizing_sixteenth_pel,
                dynamic_warping_half_pel,
                dynamic_warping_sixteenth_pel,
                reduced_resolution_update,
                independent_segment_decoding,
                alternate_inter_vlcmode,
                modified_quantization_mode,
                enhanced_reference_pic_select,
                h263_version3_options,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H263Options {
        #[rasn(identifier = "advancedIntraCodingMode")]
        pub advanced_intra_coding_mode: bool,
        #[rasn(identifier = "deblockingFilterMode")]
        pub deblocking_filter_mode: bool,
        #[rasn(identifier = "improvedPBFramesMode")]
        pub improved_pbframes_mode: bool,
        #[rasn(identifier = "unlimitedMotionVectors")]
        pub unlimited_motion_vectors: bool,
        #[rasn(identifier = "fullPictureFreeze")]
        pub full_picture_freeze: bool,
        #[rasn(identifier = "partialPictureFreezeAndRelease")]
        pub partial_picture_freeze_and_release: bool,
        #[rasn(identifier = "resizingPartPicFreezeAndRelease")]
        pub resizing_part_pic_freeze_and_release: bool,
        #[rasn(identifier = "fullPictureSnapshot")]
        pub full_picture_snapshot: bool,
        #[rasn(identifier = "partialPictureSnapshot")]
        pub partial_picture_snapshot: bool,
        #[rasn(identifier = "videoSegmentTagging")]
        pub video_segment_tagging: bool,
        #[rasn(identifier = "progressiveRefinement")]
        pub progressive_refinement: bool,
        #[rasn(identifier = "dynamicPictureResizingByFour")]
        pub dynamic_picture_resizing_by_four: bool,
        #[rasn(identifier = "dynamicPictureResizingSixteenthPel")]
        pub dynamic_picture_resizing_sixteenth_pel: bool,
        #[rasn(identifier = "dynamicWarpingHalfPel")]
        pub dynamic_warping_half_pel: bool,
        #[rasn(identifier = "dynamicWarpingSixteenthPel")]
        pub dynamic_warping_sixteenth_pel: bool,
        #[rasn(identifier = "independentSegmentDecoding")]
        pub independent_segment_decoding: bool,
        #[rasn(identifier = "slicesInOrder-NonRect")]
        pub slices_in_order_non_rect: bool,
        #[rasn(identifier = "slicesInOrder-Rect")]
        pub slices_in_order_rect: bool,
        #[rasn(identifier = "slicesNoOrder-NonRect")]
        pub slices_no_order_non_rect: bool,
        #[rasn(identifier = "slicesNoOrder-Rect")]
        pub slices_no_order_rect: bool,
        #[rasn(identifier = "alternateInterVLCMode")]
        pub alternate_inter_vlcmode: bool,
        #[rasn(identifier = "modifiedQuantizationMode")]
        pub modified_quantization_mode: bool,
        #[rasn(identifier = "reducedResolutionUpdate")]
        pub reduced_resolution_update: bool,
        #[rasn(identifier = "transparencyParameters")]
        pub transparency_parameters: Option<TransparencyParameters>,
        #[rasn(identifier = "separateVideoBackChannel")]
        pub separate_video_back_channel: bool,
        #[rasn(identifier = "refPictureSelection")]
        pub ref_picture_selection: Option<RefPictureSelection>,
        #[rasn(size("1..=16"), identifier = "customPictureClockFrequency")]
        pub custom_picture_clock_frequency: Option<SetOf<CustomPictureClockFrequency>>,
        #[rasn(size("1..=16"), identifier = "customPictureFormat")]
        pub custom_picture_format: Option<SetOf<CustomPictureFormat>>,
        #[rasn(size("1..=16"), identifier = "modeCombos")]
        pub mode_combos: Option<SetOf<H263VideoModeCombos>>,
        #[rasn(extension_addition, identifier = "videoBadMBsCap")]
        pub video_bad_mbs_cap: bool,
        #[rasn(extension_addition, identifier = "h263Version3Options")]
        pub h263_version3_options: H263Version3Options,
    }
    impl H263Options {
        pub fn new(
            advanced_intra_coding_mode: bool,
            deblocking_filter_mode: bool,
            improved_pbframes_mode: bool,
            unlimited_motion_vectors: bool,
            full_picture_freeze: bool,
            partial_picture_freeze_and_release: bool,
            resizing_part_pic_freeze_and_release: bool,
            full_picture_snapshot: bool,
            partial_picture_snapshot: bool,
            video_segment_tagging: bool,
            progressive_refinement: bool,
            dynamic_picture_resizing_by_four: bool,
            dynamic_picture_resizing_sixteenth_pel: bool,
            dynamic_warping_half_pel: bool,
            dynamic_warping_sixteenth_pel: bool,
            independent_segment_decoding: bool,
            slices_in_order_non_rect: bool,
            slices_in_order_rect: bool,
            slices_no_order_non_rect: bool,
            slices_no_order_rect: bool,
            alternate_inter_vlcmode: bool,
            modified_quantization_mode: bool,
            reduced_resolution_update: bool,
            transparency_parameters: Option<TransparencyParameters>,
            separate_video_back_channel: bool,
            ref_picture_selection: Option<RefPictureSelection>,
            custom_picture_clock_frequency: Option<SetOf<CustomPictureClockFrequency>>,
            custom_picture_format: Option<SetOf<CustomPictureFormat>>,
            mode_combos: Option<SetOf<H263VideoModeCombos>>,
            video_bad_mbs_cap: bool,
            h263_version3_options: H263Version3Options,
        ) -> Self {
            Self {
                advanced_intra_coding_mode,
                deblocking_filter_mode,
                improved_pbframes_mode,
                unlimited_motion_vectors,
                full_picture_freeze,
                partial_picture_freeze_and_release,
                resizing_part_pic_freeze_and_release,
                full_picture_snapshot,
                partial_picture_snapshot,
                video_segment_tagging,
                progressive_refinement,
                dynamic_picture_resizing_by_four,
                dynamic_picture_resizing_sixteenth_pel,
                dynamic_warping_half_pel,
                dynamic_warping_sixteenth_pel,
                independent_segment_decoding,
                slices_in_order_non_rect,
                slices_in_order_rect,
                slices_no_order_non_rect,
                slices_no_order_rect,
                alternate_inter_vlcmode,
                modified_quantization_mode,
                reduced_resolution_update,
                transparency_parameters,
                separate_video_back_channel,
                ref_picture_selection,
                custom_picture_clock_frequency,
                custom_picture_format,
                mode_combos,
                video_bad_mbs_cap,
                h263_version3_options,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H263Version3Options {
        #[rasn(identifier = "dataPartitionedSlices")]
        pub data_partitioned_slices: bool,
        #[rasn(identifier = "fixedPointIDCT0")]
        pub fixed_point_idct0: bool,
        #[rasn(identifier = "interlacedFields")]
        pub interlaced_fields: bool,
        #[rasn(identifier = "currentPictureHeaderRepetition")]
        pub current_picture_header_repetition: bool,
        #[rasn(identifier = "previousPictureHeaderRepetition")]
        pub previous_picture_header_repetition: bool,
        #[rasn(identifier = "nextPictureHeaderRepetition")]
        pub next_picture_header_repetition: bool,
        #[rasn(identifier = "pictureNumber")]
        pub picture_number: bool,
        #[rasn(identifier = "spareReferencePictures")]
        pub spare_reference_pictures: bool,
    }
    impl H263Version3Options {
        pub fn new(
            data_partitioned_slices: bool,
            fixed_point_idct0: bool,
            interlaced_fields: bool,
            current_picture_header_repetition: bool,
            previous_picture_header_repetition: bool,
            next_picture_header_repetition: bool,
            picture_number: bool,
            spare_reference_pictures: bool,
        ) -> Self {
            Self {
                data_partitioned_slices,
                fixed_point_idct0,
                interlaced_fields,
                current_picture_header_repetition,
                previous_picture_header_repetition,
                next_picture_header_repetition,
                picture_number,
                spare_reference_pictures,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H263VideoCapability {
        #[rasn(value("1..=32"), identifier = "sqcifMPI")]
        pub sqcif_mpi: Option<u8>,
        #[rasn(value("1..=32"), identifier = "qcifMPI")]
        pub qcif_mpi: Option<u8>,
        #[rasn(value("1..=32"), identifier = "cifMPI")]
        pub cif_mpi: Option<u8>,
        #[rasn(value("1..=32"), identifier = "cif4MPI")]
        pub cif4_mpi: Option<u8>,
        #[rasn(value("1..=32"), identifier = "cif16MPI")]
        pub cif16_mpi: Option<u8>,
        #[rasn(value("1..=192400"), identifier = "maxBitRate")]
        pub max_bit_rate: u32,
        #[rasn(identifier = "unrestrictedVector")]
        pub unrestricted_vector: bool,
        #[rasn(identifier = "arithmeticCoding")]
        pub arithmetic_coding: bool,
        #[rasn(identifier = "advancedPrediction")]
        pub advanced_prediction: bool,
        #[rasn(identifier = "pbFrames")]
        pub pb_frames: bool,
        #[rasn(identifier = "temporalSpatialTradeOffCapability")]
        pub temporal_spatial_trade_off_capability: bool,
        #[rasn(value("0..=524287"), identifier = "hrd-B")]
        pub hrd_b: Option<u32>,
        #[rasn(value("0..=65535"), identifier = "bppMaxKb")]
        pub bpp_max_kb: Option<u16>,
        #[rasn(extension_addition, value("1..=3600"), identifier = "slowSqcifMPI")]
        pub slow_sqcif_mpi: Option<u16>,
        #[rasn(extension_addition, value("1..=3600"), identifier = "slowQcifMPI")]
        pub slow_qcif_mpi: Option<u16>,
        #[rasn(extension_addition, value("1..=3600"), identifier = "slowCifMPI")]
        pub slow_cif_mpi: Option<u16>,
        #[rasn(extension_addition, value("1..=3600"), identifier = "slowCif4MPI")]
        pub slow_cif4_mpi: Option<u16>,
        #[rasn(extension_addition, value("1..=3600"), identifier = "slowCif16MPI")]
        pub slow_cif16_mpi: Option<u16>,
        #[rasn(extension_addition, identifier = "errorCompensation")]
        pub error_compensation: bool,
        #[rasn(extension_addition, identifier = "enhancementLayerInfo")]
        pub enhancement_layer_info: Option<EnhancementLayerInfo>,
        #[rasn(extension_addition, identifier = "h263Options")]
        pub h263_options: Option<H263Options>,
    }
    impl H263VideoCapability {
        pub fn new(
            sqcif_mpi: Option<u8>,
            qcif_mpi: Option<u8>,
            cif_mpi: Option<u8>,
            cif4_mpi: Option<u8>,
            cif16_mpi: Option<u8>,
            max_bit_rate: u32,
            unrestricted_vector: bool,
            arithmetic_coding: bool,
            advanced_prediction: bool,
            pb_frames: bool,
            temporal_spatial_trade_off_capability: bool,
            hrd_b: Option<u32>,
            bpp_max_kb: Option<u16>,
            slow_sqcif_mpi: Option<u16>,
            slow_qcif_mpi: Option<u16>,
            slow_cif_mpi: Option<u16>,
            slow_cif4_mpi: Option<u16>,
            slow_cif16_mpi: Option<u16>,
            error_compensation: bool,
            enhancement_layer_info: Option<EnhancementLayerInfo>,
            h263_options: Option<H263Options>,
        ) -> Self {
            Self {
                sqcif_mpi,
                qcif_mpi,
                cif_mpi,
                cif4_mpi,
                cif16_mpi,
                max_bit_rate,
                unrestricted_vector,
                arithmetic_coding,
                advanced_prediction,
                pb_frames,
                temporal_spatial_trade_off_capability,
                hrd_b,
                bpp_max_kb,
                slow_sqcif_mpi,
                slow_qcif_mpi,
                slow_cif_mpi,
                slow_cif4_mpi,
                slow_cif16_mpi,
                error_compensation,
                enhancement_layer_info,
                h263_options,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H263VideoModeResolution {
        sqcif(()),
        qcif(()),
        cif(()),
        cif4(()),
        cif16(()),
        #[rasn(extension_addition)]
        custom(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H263VideoMode {
        pub resolution: H263VideoModeResolution,
        #[rasn(value("1..=19200"), identifier = "bitRate")]
        pub bit_rate: u16,
        #[rasn(identifier = "unrestrictedVector")]
        pub unrestricted_vector: bool,
        #[rasn(identifier = "arithmeticCoding")]
        pub arithmetic_coding: bool,
        #[rasn(identifier = "advancedPrediction")]
        pub advanced_prediction: bool,
        #[rasn(identifier = "pbFrames")]
        pub pb_frames: bool,
        #[rasn(extension_addition, identifier = "errorCompensation")]
        pub error_compensation: bool,
        #[rasn(extension_addition, identifier = "enhancementLayerInfo")]
        pub enhancement_layer_info: Option<EnhancementLayerInfo>,
        #[rasn(extension_addition, identifier = "h263Options")]
        pub h263_options: Option<H263Options>,
    }
    impl H263VideoMode {
        pub fn new(
            resolution: H263VideoModeResolution,
            bit_rate: u16,
            unrestricted_vector: bool,
            arithmetic_coding: bool,
            advanced_prediction: bool,
            pb_frames: bool,
            error_compensation: bool,
            enhancement_layer_info: Option<EnhancementLayerInfo>,
            h263_options: Option<H263Options>,
        ) -> Self {
            Self {
                resolution,
                bit_rate,
                unrestricted_vector,
                arithmetic_coding,
                advanced_prediction,
                pb_frames,
                error_compensation,
                enhancement_layer_info,
                h263_options,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H263VideoModeCombos {
        #[rasn(identifier = "h263VideoUncoupledModes")]
        pub h263_video_uncoupled_modes: H263ModeComboFlags,
        #[rasn(size("1..=16"), identifier = "h263VideoCoupledModes")]
        pub h263_video_coupled_modes: SetOf<H263ModeComboFlags>,
    }
    impl H263VideoModeCombos {
        pub fn new(
            h263_video_uncoupled_modes: H263ModeComboFlags,
            h263_video_coupled_modes: SetOf<H263ModeComboFlags>,
        ) -> Self {
            Self {
                h263_video_uncoupled_modes,
                h263_video_coupled_modes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct IS11172AudioCapability {
        #[rasn(identifier = "audioLayer1")]
        pub audio_layer1: bool,
        #[rasn(identifier = "audioLayer2")]
        pub audio_layer2: bool,
        #[rasn(identifier = "audioLayer3")]
        pub audio_layer3: bool,
        #[rasn(identifier = "audioSampling32k")]
        pub audio_sampling32k: bool,
        #[rasn(identifier = "audioSampling44k1")]
        pub audio_sampling44k1: bool,
        #[rasn(identifier = "audioSampling48k")]
        pub audio_sampling48k: bool,
        #[rasn(identifier = "singleChannel")]
        pub single_channel: bool,
        #[rasn(identifier = "twoChannels")]
        pub two_channels: bool,
        #[rasn(value("1..=448"), identifier = "bitRate")]
        pub bit_rate: u16,
    }
    impl IS11172AudioCapability {
        pub fn new(
            audio_layer1: bool,
            audio_layer2: bool,
            audio_layer3: bool,
            audio_sampling32k: bool,
            audio_sampling44k1: bool,
            audio_sampling48k: bool,
            single_channel: bool,
            two_channels: bool,
            bit_rate: u16,
        ) -> Self {
            Self {
                audio_layer1,
                audio_layer2,
                audio_layer3,
                audio_sampling32k,
                audio_sampling44k1,
                audio_sampling48k,
                single_channel,
                two_channels,
                bit_rate,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum IS11172AudioModeAudioLayer {
        audioLayer1(()),
        audioLayer2(()),
        audioLayer3(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum IS11172AudioModeAudioSampling {
        audioSampling32k(()),
        audioSampling44k1(()),
        audioSampling48k(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum IS11172AudioModeMultichannelType {
        singleChannel(()),
        twoChannelStereo(()),
        twoChannelDual(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct IS11172AudioMode {
        #[rasn(identifier = "audioLayer")]
        pub audio_layer: IS11172AudioModeAudioLayer,
        #[rasn(identifier = "audioSampling")]
        pub audio_sampling: IS11172AudioModeAudioSampling,
        #[rasn(identifier = "multichannelType")]
        pub multichannel_type: IS11172AudioModeMultichannelType,
        #[rasn(value("1..=448"), identifier = "bitRate")]
        pub bit_rate: u16,
    }
    impl IS11172AudioMode {
        pub fn new(
            audio_layer: IS11172AudioModeAudioLayer,
            audio_sampling: IS11172AudioModeAudioSampling,
            multichannel_type: IS11172AudioModeMultichannelType,
            bit_rate: u16,
        ) -> Self {
            Self {
                audio_layer,
                audio_sampling,
                multichannel_type,
                bit_rate,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct IS11172VideoCapability {
        #[rasn(identifier = "constrainedBitstream")]
        pub constrained_bitstream: bool,
        #[rasn(value("0..=1073741823"), identifier = "videoBitRate")]
        pub video_bit_rate: Option<u32>,
        #[rasn(value("0..=262143"), identifier = "vbvBufferSize")]
        pub vbv_buffer_size: Option<u32>,
        #[rasn(value("0..=16383"), identifier = "samplesPerLine")]
        pub samples_per_line: Option<u16>,
        #[rasn(value("0..=16383"), identifier = "linesPerFrame")]
        pub lines_per_frame: Option<u16>,
        #[rasn(value("0..=15"), identifier = "pictureRate")]
        pub picture_rate: Option<u8>,
        #[rasn(value("0..=4294967295"), identifier = "luminanceSampleRate")]
        pub luminance_sample_rate: Option<u32>,
        #[rasn(extension_addition, identifier = "videoBadMBsCap")]
        pub video_bad_mbs_cap: bool,
    }
    impl IS11172VideoCapability {
        pub fn new(
            constrained_bitstream: bool,
            video_bit_rate: Option<u32>,
            vbv_buffer_size: Option<u32>,
            samples_per_line: Option<u16>,
            lines_per_frame: Option<u16>,
            picture_rate: Option<u8>,
            luminance_sample_rate: Option<u32>,
            video_bad_mbs_cap: bool,
        ) -> Self {
            Self {
                constrained_bitstream,
                video_bit_rate,
                vbv_buffer_size,
                samples_per_line,
                lines_per_frame,
                picture_rate,
                luminance_sample_rate,
                video_bad_mbs_cap,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct IS11172VideoMode {
        #[rasn(identifier = "constrainedBitstream")]
        pub constrained_bitstream: bool,
        #[rasn(value("0..=1073741823"), identifier = "videoBitRate")]
        pub video_bit_rate: Option<u32>,
        #[rasn(value("0..=262143"), identifier = "vbvBufferSize")]
        pub vbv_buffer_size: Option<u32>,
        #[rasn(value("0..=16383"), identifier = "samplesPerLine")]
        pub samples_per_line: Option<u16>,
        #[rasn(value("0..=16383"), identifier = "linesPerFrame")]
        pub lines_per_frame: Option<u16>,
        #[rasn(value("0..=15"), identifier = "pictureRate")]
        pub picture_rate: Option<u8>,
        #[rasn(value("0..=4294967295"), identifier = "luminanceSampleRate")]
        pub luminance_sample_rate: Option<u32>,
    }
    impl IS11172VideoMode {
        pub fn new(
            constrained_bitstream: bool,
            video_bit_rate: Option<u32>,
            vbv_buffer_size: Option<u32>,
            samples_per_line: Option<u16>,
            lines_per_frame: Option<u16>,
            picture_rate: Option<u8>,
            luminance_sample_rate: Option<u32>,
        ) -> Self {
            Self {
                constrained_bitstream,
                video_bit_rate,
                vbv_buffer_size,
                samples_per_line,
                lines_per_frame,
                picture_rate,
                luminance_sample_rate,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct IS13818AudioCapability {
        #[rasn(identifier = "audioLayer1")]
        pub audio_layer1: bool,
        #[rasn(identifier = "audioLayer2")]
        pub audio_layer2: bool,
        #[rasn(identifier = "audioLayer3")]
        pub audio_layer3: bool,
        #[rasn(identifier = "audioSampling16k")]
        pub audio_sampling16k: bool,
        #[rasn(identifier = "audioSampling22k05")]
        pub audio_sampling22k05: bool,
        #[rasn(identifier = "audioSampling24k")]
        pub audio_sampling24k: bool,
        #[rasn(identifier = "audioSampling32k")]
        pub audio_sampling32k: bool,
        #[rasn(identifier = "audioSampling44k1")]
        pub audio_sampling44k1: bool,
        #[rasn(identifier = "audioSampling48k")]
        pub audio_sampling48k: bool,
        #[rasn(identifier = "singleChannel")]
        pub single_channel: bool,
        #[rasn(identifier = "twoChannels")]
        pub two_channels: bool,
        #[rasn(identifier = "threeChannels2-1")]
        pub three_channels2_1: bool,
        #[rasn(identifier = "threeChannels3-0")]
        pub three_channels3_0: bool,
        #[rasn(identifier = "fourChannels2-0-2-0")]
        pub four_channels2_0_2_0: bool,
        #[rasn(identifier = "fourChannels2-2")]
        pub four_channels2_2: bool,
        #[rasn(identifier = "fourChannels3-1")]
        pub four_channels3_1: bool,
        #[rasn(identifier = "fiveChannels3-0-2-0")]
        pub five_channels3_0_2_0: bool,
        #[rasn(identifier = "fiveChannels3-2")]
        pub five_channels3_2: bool,
        #[rasn(identifier = "lowFrequencyEnhancement")]
        pub low_frequency_enhancement: bool,
        pub multilingual: bool,
        #[rasn(value("1..=1130"), identifier = "bitRate")]
        pub bit_rate: u16,
    }
    impl IS13818AudioCapability {
        pub fn new(
            audio_layer1: bool,
            audio_layer2: bool,
            audio_layer3: bool,
            audio_sampling16k: bool,
            audio_sampling22k05: bool,
            audio_sampling24k: bool,
            audio_sampling32k: bool,
            audio_sampling44k1: bool,
            audio_sampling48k: bool,
            single_channel: bool,
            two_channels: bool,
            three_channels2_1: bool,
            three_channels3_0: bool,
            four_channels2_0_2_0: bool,
            four_channels2_2: bool,
            four_channels3_1: bool,
            five_channels3_0_2_0: bool,
            five_channels3_2: bool,
            low_frequency_enhancement: bool,
            multilingual: bool,
            bit_rate: u16,
        ) -> Self {
            Self {
                audio_layer1,
                audio_layer2,
                audio_layer3,
                audio_sampling16k,
                audio_sampling22k05,
                audio_sampling24k,
                audio_sampling32k,
                audio_sampling44k1,
                audio_sampling48k,
                single_channel,
                two_channels,
                three_channels2_1,
                three_channels3_0,
                four_channels2_0_2_0,
                four_channels2_2,
                four_channels3_1,
                five_channels3_0_2_0,
                five_channels3_2,
                low_frequency_enhancement,
                multilingual,
                bit_rate,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum IS13818AudioModeAudioLayer {
        audioLayer1(()),
        audioLayer2(()),
        audioLayer3(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum IS13818AudioModeAudioSampling {
        audioSampling16k(()),
        audioSampling22k05(()),
        audioSampling24k(()),
        audioSampling32k(()),
        audioSampling44k1(()),
        audioSampling48k(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum IS13818AudioModeMultichannelType {
        singleChannel(()),
        twoChannelStereo(()),
        twoChannelDual(()),
        #[rasn(identifier = "threeChannels2-1")]
        threeChannels2_1(()),
        #[rasn(identifier = "threeChannels3-0")]
        threeChannels3_0(()),
        #[rasn(identifier = "fourChannels2-0-2-0")]
        fourChannels2_0_2_0(()),
        #[rasn(identifier = "fourChannels2-2")]
        fourChannels2_2(()),
        #[rasn(identifier = "fourChannels3-1")]
        fourChannels3_1(()),
        #[rasn(identifier = "fiveChannels3-0-2-0")]
        fiveChannels3_0_2_0(()),
        #[rasn(identifier = "fiveChannels3-2")]
        fiveChannels3_2(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct IS13818AudioMode {
        #[rasn(identifier = "audioLayer")]
        pub audio_layer: IS13818AudioModeAudioLayer,
        #[rasn(identifier = "audioSampling")]
        pub audio_sampling: IS13818AudioModeAudioSampling,
        #[rasn(identifier = "multichannelType")]
        pub multichannel_type: IS13818AudioModeMultichannelType,
        #[rasn(identifier = "lowFrequencyEnhancement")]
        pub low_frequency_enhancement: bool,
        pub multilingual: bool,
        #[rasn(value("1..=1130"), identifier = "bitRate")]
        pub bit_rate: u16,
    }
    impl IS13818AudioMode {
        pub fn new(
            audio_layer: IS13818AudioModeAudioLayer,
            audio_sampling: IS13818AudioModeAudioSampling,
            multichannel_type: IS13818AudioModeMultichannelType,
            low_frequency_enhancement: bool,
            multilingual: bool,
            bit_rate: u16,
        ) -> Self {
            Self {
                audio_layer,
                audio_sampling,
                multichannel_type,
                low_frequency_enhancement,
                multilingual,
                bit_rate,
            }
        }
    }
    #[doc = " initial value for"]
    #[doc = " 64-bit block ciphers"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct IV16(pub FixedOctetString<16usize>);
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : user input"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct IV8(pub FixedOctetString<8usize>);
    #[doc = " An IndicationMessage is information that does not require action or response"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum IndicationMessage {
        nonStandard(NonStandardMessage),
        functionNotUnderstood(FunctionNotUnderstood),
        masterSlaveDeterminationRelease(MasterSlaveDeterminationRelease),
        terminalCapabilitySetRelease(TerminalCapabilitySetRelease),
        openLogicalChannelConfirm(OpenLogicalChannelConfirm),
        requestChannelCloseRelease(RequestChannelCloseRelease),
        multiplexEntrySendRelease(MultiplexEntrySendRelease),
        requestMultiplexEntryRelease(RequestMultiplexEntryRelease),
        requestModeRelease(RequestModeRelease),
        miscellaneousIndication(MiscellaneousIndication),
        jitterIndication(JitterIndication),
        h223SkewIndication(H223SkewIndication),
        newATMVCIndication(NewATMVCIndication),
        userInput(UserInputIndication),
        #[rasn(extension_addition)]
        h2250MaximumSkewIndication(H2250MaximumSkewIndication),
        #[rasn(extension_addition)]
        mcLocationIndication(MCLocationIndication),
        #[rasn(extension_addition)]
        conferenceIndication(ConferenceIndication),
        #[rasn(extension_addition)]
        vendorIdentification(VendorIdentification),
        #[rasn(extension_addition)]
        functionNotSupported(FunctionNotSupported),
        #[rasn(extension_addition)]
        multilinkIndication(MultilinkIndication),
        #[rasn(extension_addition)]
        logicalChannelRateRelease(LogicalChannelRateRelease),
        #[rasn(extension_addition)]
        flowControlIndication(FlowControlIndication),
        #[rasn(extension_addition)]
        mobileMultilinkReconfigurationIndication(MobileMultilinkReconfigurationIndication),
        #[rasn(extension_addition)]
        genericIndication(GenericMessage),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct IntegrityCapability {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<NonStandardParameter>,
    }
    impl IntegrityCapability {
        pub fn new(non_standard: Option<NonStandardParameter>) -> Self {
            Self { non_standard }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum JitterIndicationScope {
        logicalChannelNumber(LogicalChannelNumber),
        #[rasn(value("0..=65535"))]
        resourceID(u16),
        wholeMultiplex(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : Jitter Indication"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct JitterIndication {
        pub scope: JitterIndicationScope,
        #[rasn(value("0..=3"), identifier = "estimatedReceivedJitterMantissa")]
        pub estimated_received_jitter_mantissa: u8,
        #[rasn(value("0..=7"), identifier = "estimatedReceivedJitterExponent")]
        pub estimated_received_jitter_exponent: u8,
        #[rasn(value("0..=15"), identifier = "skippedFrameCount")]
        pub skipped_frame_count: Option<u8>,
        #[rasn(value("0..=262143"), identifier = "additionalDecoderBuffer")]
        pub additional_decoder_buffer: Option<u32>,
    }
    impl JitterIndication {
        pub fn new(
            scope: JitterIndicationScope,
            estimated_received_jitter_mantissa: u8,
            estimated_received_jitter_exponent: u8,
            skipped_frame_count: Option<u8>,
            additional_decoder_buffer: Option<u32>,
        ) -> Self {
            Self {
                scope,
                estimated_received_jitter_mantissa,
                estimated_received_jitter_exponent,
                skipped_frame_count,
                additional_decoder_buffer,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct KeyProtectionMethod {
        #[rasn(identifier = "secureChannel")]
        pub secure_channel: bool,
        #[rasn(identifier = "sharedSecret")]
        pub shared_secret: bool,
        #[rasn(identifier = "certProtectedKey")]
        pub cert_protected_key: bool,
    }
    impl KeyProtectionMethod {
        pub fn new(secure_channel: bool, shared_secret: bool, cert_protected_key: bool) -> Self {
            Self {
                secure_channel,
                shared_secret,
                cert_protected_key,
            }
        }
    }
    #[doc = " used only by Master"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=65535"))]
    pub struct LogicalChannelNumber(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LogicalChannelRateAcknowledge {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(identifier = "logicalChannelNumber")]
        pub logical_channel_number: LogicalChannelNumber,
        #[rasn(identifier = "maximumBitRate")]
        pub maximum_bit_rate: MaximumBitRate,
    }
    impl LogicalChannelRateAcknowledge {
        pub fn new(
            sequence_number: SequenceNumber,
            logical_channel_number: LogicalChannelNumber,
            maximum_bit_rate: MaximumBitRate,
        ) -> Self {
            Self {
                sequence_number,
                logical_channel_number,
                maximum_bit_rate,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LogicalChannelRateReject {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(identifier = "logicalChannelNumber")]
        pub logical_channel_number: LogicalChannelNumber,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: LogicalChannelRateRejectReason,
        #[rasn(identifier = "currentMaximumBitRate")]
        pub current_maximum_bit_rate: Option<MaximumBitRate>,
    }
    impl LogicalChannelRateReject {
        pub fn new(
            sequence_number: SequenceNumber,
            logical_channel_number: LogicalChannelNumber,
            reject_reason: LogicalChannelRateRejectReason,
            current_maximum_bit_rate: Option<MaximumBitRate>,
        ) -> Self {
            Self {
                sequence_number,
                logical_channel_number,
                reject_reason,
                current_maximum_bit_rate,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum LogicalChannelRateRejectReason {
        undefinedReason(()),
        insufficientResources(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LogicalChannelRateRelease {}
    impl LogicalChannelRateRelease {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for LogicalChannelRateRelease {
        fn default() -> Self {
            Self {}
        }
    }
    #[doc = " units of 100 bit/s"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LogicalChannelRateRequest {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(identifier = "logicalChannelNumber")]
        pub logical_channel_number: LogicalChannelNumber,
        #[rasn(identifier = "maximumBitRate")]
        pub maximum_bit_rate: MaximumBitRate,
    }
    impl LogicalChannelRateRequest {
        pub fn new(
            sequence_number: SequenceNumber,
            logical_channel_number: LogicalChannelNumber,
            maximum_bit_rate: MaximumBitRate,
        ) -> Self {
            Self {
                sequence_number,
                logical_channel_number,
                maximum_bit_rate,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : MC Location Indication"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MCLocationIndication {
        #[rasn(identifier = "signalAddress")]
        pub signal_address: TransportAddress,
    }
    impl MCLocationIndication {
        pub fn new(signal_address: TransportAddress) -> Self {
            Self { signal_address }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MaintenanceLoopAckType {
        systemLoop(()),
        mediaLoop(LogicalChannelNumber),
        logicalChannelLoop(LogicalChannelNumber),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MaintenanceLoopAck {
        #[rasn(identifier = "type")]
        pub r_type: MaintenanceLoopAckType,
    }
    impl MaintenanceLoopAck {
        pub fn new(r_type: MaintenanceLoopAckType) -> Self {
            Self { r_type }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MaintenanceLoopOffCommand {}
    impl MaintenanceLoopOffCommand {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for MaintenanceLoopOffCommand {
        fn default() -> Self {
            Self {}
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MaintenanceLoopRejectType {
        systemLoop(()),
        mediaLoop(LogicalChannelNumber),
        logicalChannelLoop(LogicalChannelNumber),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MaintenanceLoopRejectCause {
        canNotPerformLoop(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MaintenanceLoopReject {
        #[rasn(identifier = "type")]
        pub r_type: MaintenanceLoopRejectType,
        pub cause: MaintenanceLoopRejectCause,
    }
    impl MaintenanceLoopReject {
        pub fn new(r_type: MaintenanceLoopRejectType, cause: MaintenanceLoopRejectCause) -> Self {
            Self { r_type, cause }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MaintenanceLoopRequestType {
        systemLoop(()),
        mediaLoop(LogicalChannelNumber),
        logicalChannelLoop(LogicalChannelNumber),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Maintenance Loop definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MaintenanceLoopRequest {
        #[rasn(identifier = "type")]
        pub r_type: MaintenanceLoopRequestType,
    }
    impl MaintenanceLoopRequest {
        pub fn new(r_type: MaintenanceLoopRequestType) -> Self {
            Self { r_type }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Master-slave determination definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MasterSlaveDetermination {
        #[rasn(value("0..=255"), identifier = "terminalType")]
        pub terminal_type: u8,
        #[rasn(value("0..=16777215"), identifier = "statusDeterminationNumber")]
        pub status_determination_number: u32,
    }
    impl MasterSlaveDetermination {
        pub fn new(terminal_type: u8, status_determination_number: u32) -> Self {
            Self {
                terminal_type,
                status_determination_number,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum MasterSlaveDeterminationAckDecision {
        master(()),
        slave(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MasterSlaveDeterminationAck {
        pub decision: MasterSlaveDeterminationAckDecision,
    }
    impl MasterSlaveDeterminationAck {
        pub fn new(decision: MasterSlaveDeterminationAckDecision) -> Self {
            Self { decision }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MasterSlaveDeterminationRejectCause {
        identicalNumbers(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MasterSlaveDeterminationReject {
        pub cause: MasterSlaveDeterminationRejectCause,
    }
    impl MasterSlaveDeterminationReject {
        pub fn new(cause: MasterSlaveDeterminationRejectCause) -> Self {
            Self { cause }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MasterSlaveDeterminationRelease {}
    impl MasterSlaveDeterminationRelease {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for MasterSlaveDeterminationRelease {
        fn default() -> Self {
            Self {}
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Logical channel bit-rate change definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=4294967295"))]
    pub struct MaximumBitRate(pub u32);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=192"))]
    pub struct McuNumber(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MediaChannelCapability {
        #[rasn(identifier = "mediaTransport")]
        pub media_transport: Option<MediaTransportType>,
    }
    impl MediaChannelCapability {
        pub fn new(media_transport: Option<MediaTransportType>) -> Self {
            Self { media_transport }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MediaDistributionCapability {
        #[rasn(identifier = "centralizedControl")]
        pub centralized_control: bool,
        #[rasn(identifier = "distributedControl")]
        pub distributed_control: bool,
        #[rasn(identifier = "centralizedAudio")]
        pub centralized_audio: bool,
        #[rasn(identifier = "distributedAudio")]
        pub distributed_audio: bool,
        #[rasn(identifier = "centralizedVideo")]
        pub centralized_video: bool,
        #[rasn(identifier = "distributedVideo")]
        pub distributed_video: bool,
        #[rasn(identifier = "centralizedData")]
        pub centralized_data: Option<SequenceOf<DataApplicationCapability>>,
        #[rasn(identifier = "distributedData")]
        pub distributed_data: Option<SequenceOf<DataApplicationCapability>>,
    }
    impl MediaDistributionCapability {
        pub fn new(
            centralized_control: bool,
            distributed_control: bool,
            centralized_audio: bool,
            distributed_audio: bool,
            centralized_video: bool,
            distributed_video: bool,
            centralized_data: Option<SequenceOf<DataApplicationCapability>>,
            distributed_data: Option<SequenceOf<DataApplicationCapability>>,
        ) -> Self {
            Self {
                centralized_control,
                distributed_control,
                centralized_audio,
                distributed_audio,
                centralized_video,
                distributed_video,
                centralized_data,
                distributed_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MediaEncryptionAlgorithm {
        nonStandard(NonStandardParameter),
        algorithm(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MediaPacketizationCapability {
        #[rasn(identifier = "h261aVideoPacketization")]
        pub h261a_video_packetization: bool,
        #[rasn(extension_addition, size("1..=256"), identifier = "rtpPayloadType")]
        pub rtp_payload_type: Option<SequenceOf<RTPPayloadType>>,
    }
    impl MediaPacketizationCapability {
        pub fn new(
            h261a_video_packetization: bool,
            rtp_payload_type: Option<SequenceOf<RTPPayloadType>>,
        ) -> Self {
            Self {
                h261a_video_packetization,
                rtp_payload_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MediaTransportTypeAtmAAL5Compressed {
        #[rasn(identifier = "variable-delta")]
        pub variable_delta: bool,
    }
    impl MediaTransportTypeAtmAAL5Compressed {
        pub fn new(variable_delta: bool) -> Self {
            Self { variable_delta }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MediaTransportType {
        #[rasn(identifier = "ip-UDP")]
        ip_UDP(()),
        #[rasn(identifier = "ip-TCP")]
        ip_TCP(()),
        #[rasn(identifier = "atm-AAL5-UNIDIR")]
        atm_AAL5_UNIDIR(()),
        #[rasn(identifier = "atm-AAL5-BIDIR")]
        atm_AAL5_BIDIR(()),
        #[rasn(extension_addition, identifier = "atm-AAL5-compressed")]
        atm_AAL5_compressed(MediaTransportTypeAtmAAL5Compressed),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct MiscellaneousCommandTypeVideoFastUpdateGOB {
        #[rasn(value("0..=17"), identifier = "firstGOB")]
        pub first_gob: u8,
        #[rasn(value("1..=18"), identifier = "numberOfGOBs")]
        pub number_of_gobs: u8,
    }
    impl MiscellaneousCommandTypeVideoFastUpdateGOB {
        pub fn new(first_gob: u8, number_of_gobs: u8) -> Self {
            Self {
                first_gob,
                number_of_gobs,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousCommandTypeVideoFastUpdateMB {
        #[rasn(value("0..=255"), identifier = "firstGOB")]
        pub first_gob: Option<u8>,
        #[rasn(value("1..=8192"), identifier = "firstMB")]
        pub first_mb: Option<u16>,
        #[rasn(value("1..=8192"), identifier = "numberOfMBs")]
        pub number_of_mbs: u16,
    }
    impl MiscellaneousCommandTypeVideoFastUpdateMB {
        pub fn new(first_gob: Option<u8>, first_mb: Option<u16>, number_of_mbs: u16) -> Self {
            Self {
                first_gob,
                first_mb,
                number_of_mbs,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MiscellaneousCommandTypeProgressiveRefinementStartRepeatCount {
        doOneProgression(()),
        doContinuousProgressions(()),
        doOneIndependentProgression(()),
        doContinuousIndependentProgressions(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousCommandTypeProgressiveRefinementStart {
        #[rasn(identifier = "repeatCount")]
        pub repeat_count: MiscellaneousCommandTypeProgressiveRefinementStartRepeatCount,
    }
    impl MiscellaneousCommandTypeProgressiveRefinementStart {
        pub fn new(
            repeat_count: MiscellaneousCommandTypeProgressiveRefinementStartRepeatCount,
        ) -> Self {
            Self { repeat_count }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousCommandTypeVideoBadMBs {
        #[rasn(value("1..=9216"), identifier = "firstMB")]
        pub first_mb: u16,
        #[rasn(value("1..=9216"), identifier = "numberOfMBs")]
        pub number_of_mbs: u16,
        #[rasn(value("0..=1023"), identifier = "temporalReference")]
        pub temporal_reference: u16,
    }
    impl MiscellaneousCommandTypeVideoBadMBs {
        pub fn new(first_mb: u16, number_of_mbs: u16, temporal_reference: u16) -> Self {
            Self {
                first_mb,
                number_of_mbs,
                temporal_reference,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousCommandTypeLostPartialPicture {
        #[rasn(identifier = "pictureReference")]
        pub picture_reference: PictureReference,
        #[rasn(value("1..=9216"), identifier = "firstMB")]
        pub first_mb: u16,
        #[rasn(value("1..=9216"), identifier = "numberOfMBs")]
        pub number_of_mbs: u16,
    }
    impl MiscellaneousCommandTypeLostPartialPicture {
        pub fn new(picture_reference: PictureReference, first_mb: u16, number_of_mbs: u16) -> Self {
            Self {
                picture_reference,
                first_mb,
                number_of_mbs,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousCommandTypeEncryptionUpdateCommand {
        #[rasn(identifier = "encryptionSync")]
        pub encryption_sync: EncryptionSync,
        #[rasn(identifier = "multiplePayloadStream")]
        pub multiple_payload_stream: Option<MultiplePayloadStream>,
    }
    impl MiscellaneousCommandTypeEncryptionUpdateCommand {
        pub fn new(
            encryption_sync: EncryptionSync,
            multiple_payload_stream: Option<MultiplePayloadStream>,
        ) -> Self {
            Self {
                encryption_sync,
                multiple_payload_stream,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousCommandTypeEncryptionUpdateAck {
        #[rasn(value("0..=255"), identifier = "synchFlag")]
        pub synch_flag: u8,
    }
    impl MiscellaneousCommandTypeEncryptionUpdateAck {
        pub fn new(synch_flag: u8) -> Self {
            Self { synch_flag }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MiscellaneousCommandType {
        equaliseDelay(()),
        zeroDelay(()),
        multipointModeCommand(()),
        cancelMultipointModeCommand(()),
        videoFreezePicture(()),
        videoFastUpdatePicture(()),
        videoFastUpdateGOB(MiscellaneousCommandTypeVideoFastUpdateGOB),
        #[rasn(value("0..=31"))]
        videoTemporalSpatialTradeOff(u8),
        videoSendSyncEveryGOB(()),
        videoSendSyncEveryGOBCancel(()),
        #[rasn(extension_addition)]
        videoFastUpdateMB(MiscellaneousCommandTypeVideoFastUpdateMB),
        #[rasn(extension_addition, value("1..=65535"))]
        maxH223MUXPDUsize(u16),
        #[rasn(extension_addition)]
        encryptionUpdate(EncryptionSync),
        #[rasn(extension_addition)]
        encryptionUpdateRequest(EncryptionUpdateRequest),
        #[rasn(extension_addition)]
        switchReceiveMediaOff(()),
        #[rasn(extension_addition)]
        switchReceiveMediaOn(()),
        #[rasn(extension_addition)]
        progressiveRefinementStart(MiscellaneousCommandTypeProgressiveRefinementStart),
        #[rasn(extension_addition)]
        progressiveRefinementAbortOne(()),
        #[rasn(extension_addition)]
        progressiveRefinementAbortContinuous(()),
        #[rasn(extension_addition)]
        videoBadMBs(MiscellaneousCommandTypeVideoBadMBs),
        #[rasn(extension_addition)]
        lostPicture(SequenceOf<PictureReference>),
        #[rasn(extension_addition)]
        lostPartialPicture(MiscellaneousCommandTypeLostPartialPicture),
        #[rasn(extension_addition)]
        recoveryReferencePicture(SequenceOf<PictureReference>),
        #[rasn(extension_addition)]
        encryptionUpdateCommand(MiscellaneousCommandTypeEncryptionUpdateCommand),
        #[rasn(extension_addition)]
        encryptionUpdateAck(MiscellaneousCommandTypeEncryptionUpdateAck),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousCommand {
        #[rasn(identifier = "logicalChannelNumber")]
        pub logical_channel_number: LogicalChannelNumber,
        #[rasn(identifier = "type")]
        pub r_type: MiscellaneousCommandType,
        #[rasn(extension_addition)]
        pub direction: Option<EncryptionUpdateDirection>,
    }
    impl MiscellaneousCommand {
        pub fn new(
            logical_channel_number: LogicalChannelNumber,
            r_type: MiscellaneousCommandType,
            direction: Option<EncryptionUpdateDirection>,
        ) -> Self {
            Self {
                logical_channel_number,
                r_type,
                direction,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousIndicationTypeVideoNotDecodedMBs {
        #[rasn(value("1..=8192"), identifier = "firstMB")]
        pub first_mb: u16,
        #[rasn(value("1..=8192"), identifier = "numberOfMBs")]
        pub number_of_mbs: u16,
        #[rasn(value("0..=255"), identifier = "temporalReference")]
        pub temporal_reference: u8,
    }
    impl MiscellaneousIndicationTypeVideoNotDecodedMBs {
        pub fn new(first_mb: u16, number_of_mbs: u16, temporal_reference: u8) -> Self {
            Self {
                first_mb,
                number_of_mbs,
                temporal_reference,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MiscellaneousIndicationType {
        logicalChannelActive(()),
        logicalChannelInactive(()),
        multipointConference(()),
        cancelMultipointConference(()),
        multipointZeroComm(()),
        cancelMultipointZeroComm(()),
        multipointSecondaryStatus(()),
        cancelMultipointSecondaryStatus(()),
        videoIndicateReadyToActivate(()),
        #[rasn(value("0..=31"))]
        videoTemporalSpatialTradeOff(u8),
        #[rasn(extension_addition)]
        videoNotDecodedMBs(MiscellaneousIndicationTypeVideoNotDecodedMBs),
        #[rasn(extension_addition)]
        transportCapability(TransportCapability),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : Miscellaneous H.230-like indication"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MiscellaneousIndication {
        #[rasn(identifier = "logicalChannelNumber")]
        pub logical_channel_number: LogicalChannelNumber,
        #[rasn(identifier = "type")]
        pub r_type: MiscellaneousIndicationType,
    }
    impl MiscellaneousIndication {
        pub fn new(
            logical_channel_number: LogicalChannelNumber,
            r_type: MiscellaneousIndicationType,
        ) -> Self {
            Self {
                logical_channel_number,
                r_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MobileMultilinkReconfigurationCommandStatus {
        synchronized(()),
        reconfiguration(()),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : Mobile Multilink Reconfiguration command"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MobileMultilinkReconfigurationCommand {
        #[rasn(value("1..=255"), identifier = "sampleSize")]
        pub sample_size: u8,
        #[rasn(value("1..=255"), identifier = "samplesPerFrame")]
        pub samples_per_frame: u8,
        pub status: MobileMultilinkReconfigurationCommandStatus,
    }
    impl MobileMultilinkReconfigurationCommand {
        pub fn new(
            sample_size: u8,
            samples_per_frame: u8,
            status: MobileMultilinkReconfigurationCommandStatus,
        ) -> Self {
            Self {
                sample_size,
                samples_per_frame,
                status,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : Mobile Multilink Reconfiguration indication"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MobileMultilinkReconfigurationIndication {
        #[rasn(value("1..=255"), identifier = "sampleSize")]
        pub sample_size: u8,
        #[rasn(value("1..=255"), identifier = "samplesPerFrame")]
        pub samples_per_frame: u8,
    }
    impl MobileMultilinkReconfigurationIndication {
        pub fn new(sample_size: u8, samples_per_frame: u8) -> Self {
            Self {
                sample_size,
                samples_per_frame,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Request mode definitions: Mode description"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=256"))]
    pub struct ModeDescription(pub SetOf<ModeElement>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ModeElement {
        #[rasn(identifier = "type")]
        pub r_type: ModeElementType,
        #[rasn(identifier = "h223ModeParameters")]
        pub h223_mode_parameters: Option<H223ModeParameters>,
        #[rasn(extension_addition, identifier = "v76ModeParameters")]
        pub v76_mode_parameters: Option<V76ModeParameters>,
        #[rasn(extension_addition, identifier = "h2250ModeParameters")]
        pub h2250_mode_parameters: Option<H2250ModeParameters>,
        #[rasn(extension_addition, identifier = "genericModeParameters")]
        pub generic_mode_parameters: Option<GenericCapability>,
        #[rasn(extension_addition, identifier = "multiplexedStreamModeParameters")]
        pub multiplexed_stream_mode_parameters: Option<MultiplexedStreamModeParameters>,
        #[rasn(extension_addition, identifier = "logicalChannelNumber")]
        pub logical_channel_number: Option<LogicalChannelNumber>,
    }
    impl ModeElement {
        pub fn new(
            r_type: ModeElementType,
            h223_mode_parameters: Option<H223ModeParameters>,
            v76_mode_parameters: Option<V76ModeParameters>,
            h2250_mode_parameters: Option<H2250ModeParameters>,
            generic_mode_parameters: Option<GenericCapability>,
            multiplexed_stream_mode_parameters: Option<MultiplexedStreamModeParameters>,
            logical_channel_number: Option<LogicalChannelNumber>,
        ) -> Self {
            Self {
                r_type,
                h223_mode_parameters,
                v76_mode_parameters,
                h2250_mode_parameters,
                generic_mode_parameters,
                multiplexed_stream_mode_parameters,
                logical_channel_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ModeElementType {
        nonStandard(NonStandardParameter),
        videoMode(VideoMode),
        audioMode(AudioMode),
        dataMode(DataMode),
        encryptionMode(EncryptionMode),
        #[rasn(extension_addition)]
        h235Mode(H235Mode),
        #[rasn(extension_addition)]
        multiplexedStreamMode(MultiplexedStreamParameter),
        #[rasn(extension_addition)]
        redundancyEncodingDTMode(RedundancyEncodingDTMode),
        #[rasn(extension_addition)]
        multiplePayloadStreamMode(MultiplePayloadStreamMode),
        #[rasn(extension_addition)]
        fecMode(Box<FECMode>),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MulticastAddressIPAddress {
        #[rasn(size("4"))]
        pub network: OctetString,
        #[rasn(value("0..=65535"), identifier = "tsapIdentifier")]
        pub tsap_identifier: u16,
    }
    impl MulticastAddressIPAddress {
        pub fn new(network: OctetString, tsap_identifier: u16) -> Self {
            Self {
                network,
                tsap_identifier,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MulticastAddressIP6Address {
        #[rasn(size("16"))]
        pub network: OctetString,
        #[rasn(value("0..=65535"), identifier = "tsapIdentifier")]
        pub tsap_identifier: u16,
    }
    impl MulticastAddressIP6Address {
        pub fn new(network: OctetString, tsap_identifier: u16) -> Self {
            Self {
                network,
                tsap_identifier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MulticastAddress {
        iPAddress(MulticastAddressIPAddress),
        iP6Address(MulticastAddressIP6Address),
        #[rasn(extension_addition, size("1..=20"))]
        nsap(OctetString),
        #[rasn(extension_addition)]
        nonStandardAddress(NonStandardParameter),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkIndicationCrcDesired {}
    impl MultilinkIndicationCrcDesired {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for MultilinkIndicationCrcDesired {
        fn default() -> Self {
            Self {}
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkIndicationExcessiveError {
        #[rasn(identifier = "connectionIdentifier")]
        pub connection_identifier: ConnectionIdentifier,
    }
    impl MultilinkIndicationExcessiveError {
        pub fn new(connection_identifier: ConnectionIdentifier) -> Self {
            Self {
                connection_identifier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultilinkIndication {
        nonStandard(NonStandardMessage),
        crcDesired(MultilinkIndicationCrcDesired),
        excessiveError(MultilinkIndicationExcessiveError),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkRequestCallInformation {
        #[rasn(value("1..=65535"), identifier = "maxNumberOfAdditionalConnections")]
        pub max_number_of_additional_connections: u16,
    }
    impl MultilinkRequestCallInformation {
        pub fn new(max_number_of_additional_connections: u16) -> Self {
            Self {
                max_number_of_additional_connections,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkRequestAddConnection {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(identifier = "dialingInformation")]
        pub dialing_information: DialingInformation,
    }
    impl MultilinkRequestAddConnection {
        pub fn new(
            sequence_number: SequenceNumber,
            dialing_information: DialingInformation,
        ) -> Self {
            Self {
                sequence_number,
                dialing_information,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkRequestRemoveConnection {
        #[rasn(identifier = "connectionIdentifier")]
        pub connection_identifier: ConnectionIdentifier,
    }
    impl MultilinkRequestRemoveConnection {
        pub fn new(connection_identifier: ConnectionIdentifier) -> Self {
            Self {
                connection_identifier,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultilinkRequestMaximumHeaderIntervalRequestType {
        currentIntervalInformation(()),
        #[rasn(value("0..=65535"))]
        requestedInterval(u16),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkRequestMaximumHeaderInterval {
        #[rasn(identifier = "requestType")]
        pub request_type: MultilinkRequestMaximumHeaderIntervalRequestType,
    }
    impl MultilinkRequestMaximumHeaderInterval {
        pub fn new(request_type: MultilinkRequestMaximumHeaderIntervalRequestType) -> Self {
            Self { request_type }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Multilink definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultilinkRequest {
        nonStandard(NonStandardMessage),
        callInformation(MultilinkRequestCallInformation),
        addConnection(MultilinkRequestAddConnection),
        removeConnection(MultilinkRequestRemoveConnection),
        maximumHeaderInterval(MultilinkRequestMaximumHeaderInterval),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkResponseCallInformation {
        #[rasn(identifier = "dialingInformation")]
        pub dialing_information: DialingInformation,
        #[rasn(value("0..=4294967295"), identifier = "callAssociationNumber")]
        pub call_association_number: u32,
    }
    impl MultilinkResponseCallInformation {
        pub fn new(dialing_information: DialingInformation, call_association_number: u32) -> Self {
            Self {
                dialing_information,
                call_association_number,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultilinkResponseAddConnectionResponseCodeRejected {
        connectionsNotAvailable(()),
        userRejected(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultilinkResponseAddConnectionResponseCode {
        accepted(()),
        rejected(MultilinkResponseAddConnectionResponseCodeRejected),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkResponseAddConnection {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(identifier = "responseCode")]
        pub response_code: MultilinkResponseAddConnectionResponseCode,
    }
    impl MultilinkResponseAddConnection {
        pub fn new(
            sequence_number: SequenceNumber,
            response_code: MultilinkResponseAddConnectionResponseCode,
        ) -> Self {
            Self {
                sequence_number,
                response_code,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkResponseRemoveConnection {
        #[rasn(identifier = "connectionIdentifier")]
        pub connection_identifier: ConnectionIdentifier,
    }
    impl MultilinkResponseRemoveConnection {
        pub fn new(connection_identifier: ConnectionIdentifier) -> Self {
            Self {
                connection_identifier,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultilinkResponseMaximumHeaderInterval {
        #[rasn(value("0..=65535"), identifier = "currentInterval")]
        pub current_interval: u16,
    }
    impl MultilinkResponseMaximumHeaderInterval {
        pub fn new(current_interval: u16) -> Self {
            Self { current_interval }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultilinkResponse {
        nonStandard(NonStandardMessage),
        callInformation(MultilinkResponseCallInformation),
        addConnection(MultilinkResponseAddConnection),
        removeConnection(MultilinkResponseRemoveConnection),
        maximumHeaderInterval(MultilinkResponseMaximumHeaderInterval),
    }
    #[doc = " Export all symbols"]
    #[doc = " ==================================================================================="]
    #[doc = " Top level Messages"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultimediaSystemControlMessage {
        request(RequestMessage),
        response(ResponseMessage),
        command(CommandMessage),
        indication(IndicationMessage),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplePayloadStream {
        pub elements: SequenceOf<MultiplePayloadStreamElement>,
    }
    impl MultiplePayloadStream {
        pub fn new(elements: SequenceOf<MultiplePayloadStreamElement>) -> Self {
            Self { elements }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability Exchange Definitions: MultiplePayloadStreamCapability"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplePayloadStreamCapability {
        #[rasn(size("1..=256"))]
        pub capabilities: SetOf<AlternativeCapabilitySet>,
    }
    impl MultiplePayloadStreamCapability {
        pub fn new(capabilities: SetOf<AlternativeCapabilitySet>) -> Self {
            Self { capabilities }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplePayloadStreamElement {
        #[rasn(identifier = "dataType")]
        pub data_type: DataType,
        #[rasn(value("0..=127"), identifier = "payloadType")]
        pub payload_type: Option<u8>,
    }
    impl MultiplePayloadStreamElement {
        pub fn new(data_type: DataType, payload_type: Option<u8>) -> Self {
            Self {
                data_type,
                payload_type,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplePayloadStreamElementMode {
        #[rasn(identifier = "type")]
        pub r_type: ModeElementType,
    }
    impl MultiplePayloadStreamElementMode {
        pub fn new(r_type: ModeElementType) -> Self {
            Self { r_type }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplePayloadStreamMode {
        pub elements: SequenceOf<MultiplePayloadStreamElementMode>,
    }
    impl MultiplePayloadStreamMode {
        pub fn new(elements: SequenceOf<MultiplePayloadStreamElementMode>) -> Self {
            Self { elements }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability exchange definitions: Multiplex capabilities"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultiplexCapability {
        nonStandard(NonStandardParameter),
        h222Capability(H222Capability),
        h223Capability(H223Capability),
        v76Capability(V76Capability),
        #[rasn(extension_addition)]
        h2250Capability(H2250Capability),
        #[rasn(extension_addition)]
        genericMultiplexCapability(GenericCapability),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum MultiplexElementType {
        #[rasn(value("0..=65535"))]
        logicalChannelNumber(u16),
        #[rasn(size("2..=255"))]
        subElementList(SequenceOf<MultiplexElement>),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum MultiplexElementRepeatCount {
        #[rasn(value("1..=65535"))]
        finite(u16),
        untilClosingFlag(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct MultiplexElement {
        #[rasn(identifier = "type")]
        pub r_type: MultiplexElementType,
        #[rasn(identifier = "repeatCount")]
        pub repeat_count: MultiplexElementRepeatCount,
    }
    impl MultiplexElement {
        pub fn new(
            r_type: MultiplexElementType,
            repeat_count: MultiplexElementRepeatCount,
        ) -> Self {
            Self {
                r_type,
                repeat_count,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct MultiplexEntryDescriptor {
        #[rasn(identifier = "multiplexTableEntryNumber")]
        pub multiplex_table_entry_number: MultiplexTableEntryNumber,
        #[rasn(size("1..=256"), identifier = "elementList")]
        pub element_list: Option<SequenceOf<MultiplexElement>>,
    }
    impl MultiplexEntryDescriptor {
        pub fn new(
            multiplex_table_entry_number: MultiplexTableEntryNumber,
            element_list: Option<SequenceOf<MultiplexElement>>,
        ) -> Self {
            Self {
                multiplex_table_entry_number,
                element_list,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultiplexEntryRejectionDescriptionsCause {
        unspecifiedCause(()),
        descriptorTooComplex(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplexEntryRejectionDescriptions {
        #[rasn(identifier = "multiplexTableEntryNumber")]
        pub multiplex_table_entry_number: MultiplexTableEntryNumber,
        pub cause: MultiplexEntryRejectionDescriptionsCause,
    }
    impl MultiplexEntryRejectionDescriptions {
        pub fn new(
            multiplex_table_entry_number: MultiplexTableEntryNumber,
            cause: MultiplexEntryRejectionDescriptionsCause,
        ) -> Self {
            Self {
                multiplex_table_entry_number,
                cause,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " H.223 multiplex table definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplexEntrySend {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(size("1..=15"), identifier = "multiplexEntryDescriptors")]
        pub multiplex_entry_descriptors: SetOf<MultiplexEntryDescriptor>,
    }
    impl MultiplexEntrySend {
        pub fn new(
            sequence_number: SequenceNumber,
            multiplex_entry_descriptors: SetOf<MultiplexEntryDescriptor>,
        ) -> Self {
            Self {
                sequence_number,
                multiplex_entry_descriptors,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplexEntrySendAck {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(size("1..=15"), identifier = "multiplexTableEntryNumber")]
        pub multiplex_table_entry_number: SetOf<MultiplexTableEntryNumber>,
    }
    impl MultiplexEntrySendAck {
        pub fn new(
            sequence_number: SequenceNumber,
            multiplex_table_entry_number: SetOf<MultiplexTableEntryNumber>,
        ) -> Self {
            Self {
                sequence_number,
                multiplex_table_entry_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplexEntrySendReject {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(size("1..=15"), identifier = "rejectionDescriptions")]
        pub rejection_descriptions: SetOf<MultiplexEntryRejectionDescriptions>,
    }
    impl MultiplexEntrySendReject {
        pub fn new(
            sequence_number: SequenceNumber,
            rejection_descriptions: SetOf<MultiplexEntryRejectionDescriptions>,
        ) -> Self {
            Self {
                sequence_number,
                rejection_descriptions,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplexEntrySendRelease {
        #[rasn(size("1..=15"), identifier = "multiplexTableEntryNumber")]
        pub multiplex_table_entry_number: SetOf<MultiplexTableEntryNumber>,
    }
    impl MultiplexEntrySendRelease {
        pub fn new(multiplex_table_entry_number: SetOf<MultiplexTableEntryNumber>) -> Self {
            Self {
                multiplex_table_entry_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum MultiplexFormat {
        nonStandard(NonStandardParameter),
        h222Capability(H222Capability),
        h223Capability(H223Capability),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=15"))]
    pub struct MultiplexTableEntryNumber(pub u8);
    #[doc = " ==================================================================================="]
    #[doc = " Capability Exchange Definitions: Multiplexed Stream Capability"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplexedStreamCapability {
        #[rasn(identifier = "multiplexFormat")]
        pub multiplex_format: MultiplexFormat,
        #[rasn(identifier = "controlOnMuxStream")]
        pub control_on_mux_stream: bool,
        #[rasn(size("1..=256"), identifier = "capabilityOnMuxStream")]
        pub capability_on_mux_stream: Option<SetOf<AlternativeCapabilitySet>>,
    }
    impl MultiplexedStreamCapability {
        pub fn new(
            multiplex_format: MultiplexFormat,
            control_on_mux_stream: bool,
            capability_on_mux_stream: Option<SetOf<AlternativeCapabilitySet>>,
        ) -> Self {
            Self {
                multiplex_format,
                control_on_mux_stream,
                capability_on_mux_stream,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplexedStreamModeParameters {
        #[rasn(identifier = "logicalChannelNumber")]
        pub logical_channel_number: LogicalChannelNumber,
    }
    impl MultiplexedStreamModeParameters {
        pub fn new(logical_channel_number: LogicalChannelNumber) -> Self {
            Self {
                logical_channel_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultiplexedStreamParameter {
        #[rasn(identifier = "multiplexFormat")]
        pub multiplex_format: MultiplexFormat,
        #[rasn(identifier = "controlOnMuxStream")]
        pub control_on_mux_stream: bool,
    }
    impl MultiplexedStreamParameter {
        pub fn new(multiplex_format: MultiplexFormat, control_on_mux_stream: bool) -> Self {
            Self {
                multiplex_format,
                control_on_mux_stream,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct MultipointCapability {
        #[rasn(identifier = "multicastCapability")]
        pub multicast_capability: bool,
        #[rasn(identifier = "multiUniCastConference")]
        pub multi_uni_cast_conference: bool,
        #[rasn(identifier = "mediaDistributionCapability")]
        pub media_distribution_capability: SequenceOf<MediaDistributionCapability>,
    }
    impl MultipointCapability {
        pub fn new(
            multicast_capability: bool,
            multi_uni_cast_conference: bool,
            media_distribution_capability: SequenceOf<MediaDistributionCapability>,
        ) -> Self {
            Self {
                multicast_capability,
                multi_uni_cast_conference,
                media_distribution_capability,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NetworkAccessParametersDistribution {
        unicast(()),
        multicast(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NetworkAccessParametersNetworkAddress {
        q2931Address(Q2931Address),
        #[rasn(
            size("1..=128"),
            from(
                "\u{23}", "\u{2a}", "\u{2c}", "\u{30}", "\u{31}", "\u{32}", "\u{33}", "\u{34}",
                "\u{35}", "\u{36}", "\u{37}", "\u{38}", "\u{39}"
            )
        )]
        e164Address(Ia5String),
        localAreaAddress(TransportAddress),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NetworkAccessParametersT120SetupProcedure {
        originateCall(()),
        waitForCall(()),
        issueQuery(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NetworkAccessParameters {
        pub distribution: Option<NetworkAccessParametersDistribution>,
        #[rasn(identifier = "networkAddress")]
        pub network_address: NetworkAccessParametersNetworkAddress,
        #[rasn(identifier = "associateConference")]
        pub associate_conference: bool,
        #[rasn(size("1..=255"), identifier = "externalReference")]
        pub external_reference: Option<OctetString>,
        #[rasn(extension_addition, identifier = "t120SetupProcedure")]
        pub t120_setup_procedure: Option<NetworkAccessParametersT120SetupProcedure>,
    }
    impl NetworkAccessParameters {
        pub fn new(
            distribution: Option<NetworkAccessParametersDistribution>,
            network_address: NetworkAccessParametersNetworkAddress,
            associate_conference: bool,
            external_reference: Option<OctetString>,
            t120_setup_procedure: Option<NetworkAccessParametersT120SetupProcedure>,
        ) -> Self {
            Self {
                distribution,
                network_address,
                associate_conference,
                external_reference,
                t120_setup_procedure,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCCommandAalAal1ClockRecovery {
        nullClockRecovery(()),
        srtsClockRecovery(()),
        adaptiveClockRecovery(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCCommandAalAal1ErrorCorrection {
        nullErrorCorrection(()),
        longInterleaver(()),
        shortInterleaver(()),
        errorCorrectionOnly(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NewATMVCCommandAalAal1 {
        #[rasn(identifier = "clockRecovery")]
        pub clock_recovery: NewATMVCCommandAalAal1ClockRecovery,
        #[rasn(identifier = "errorCorrection")]
        pub error_correction: NewATMVCCommandAalAal1ErrorCorrection,
        #[rasn(identifier = "structuredDataTransfer")]
        pub structured_data_transfer: bool,
        #[rasn(identifier = "partiallyFilledCells")]
        pub partially_filled_cells: bool,
    }
    impl NewATMVCCommandAalAal1 {
        pub fn new(
            clock_recovery: NewATMVCCommandAalAal1ClockRecovery,
            error_correction: NewATMVCCommandAalAal1ErrorCorrection,
            structured_data_transfer: bool,
            partially_filled_cells: bool,
        ) -> Self {
            Self {
                clock_recovery,
                error_correction,
                structured_data_transfer,
                partially_filled_cells,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NewATMVCCommandAalAal5 {
        #[rasn(value("0..=65535"), identifier = "forwardMaximumSDUSize")]
        pub forward_maximum_sdusize: u16,
        #[rasn(value("0..=65535"), identifier = "backwardMaximumSDUSize")]
        pub backward_maximum_sdusize: u16,
    }
    impl NewATMVCCommandAalAal5 {
        pub fn new(forward_maximum_sdusize: u16, backward_maximum_sdusize: u16) -> Self {
            Self {
                forward_maximum_sdusize,
                backward_maximum_sdusize,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCCommandAal {
        aal1(NewATMVCCommandAalAal1),
        aal5(NewATMVCCommandAalAal5),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCCommandMultiplex {
        noMultiplex(()),
        transportStream(()),
        programStream(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCCommandReverseParametersMultiplex {
        noMultiplex(()),
        transportStream(()),
        programStream(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NewATMVCCommandReverseParameters {
        #[rasn(value("1..=65535"), identifier = "bitRate")]
        pub bit_rate: u16,
        #[rasn(identifier = "bitRateLockedToPCRClock")]
        pub bit_rate_locked_to_pcrclock: bool,
        #[rasn(identifier = "bitRateLockedToNetworkClock")]
        pub bit_rate_locked_to_network_clock: bool,
        pub multiplex: NewATMVCCommandReverseParametersMultiplex,
    }
    impl NewATMVCCommandReverseParameters {
        pub fn new(
            bit_rate: u16,
            bit_rate_locked_to_pcrclock: bool,
            bit_rate_locked_to_network_clock: bool,
            multiplex: NewATMVCCommandReverseParametersMultiplex,
        ) -> Self {
            Self {
                bit_rate,
                bit_rate_locked_to_pcrclock,
                bit_rate_locked_to_network_clock,
                multiplex,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : New ATM virtual channel command"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NewATMVCCommand {
        #[rasn(value("0..=65535"), identifier = "resourceID")]
        pub resource_id: u16,
        #[rasn(value("1..=65535"), identifier = "bitRate")]
        pub bit_rate: u16,
        #[rasn(identifier = "bitRateLockedToPCRClock")]
        pub bit_rate_locked_to_pcrclock: bool,
        #[rasn(identifier = "bitRateLockedToNetworkClock")]
        pub bit_rate_locked_to_network_clock: bool,
        pub aal: NewATMVCCommandAal,
        pub multiplex: NewATMVCCommandMultiplex,
        #[rasn(identifier = "reverseParameters")]
        pub reverse_parameters: NewATMVCCommandReverseParameters,
    }
    impl NewATMVCCommand {
        pub fn new(
            resource_id: u16,
            bit_rate: u16,
            bit_rate_locked_to_pcrclock: bool,
            bit_rate_locked_to_network_clock: bool,
            aal: NewATMVCCommandAal,
            multiplex: NewATMVCCommandMultiplex,
            reverse_parameters: NewATMVCCommandReverseParameters,
        ) -> Self {
            Self {
                resource_id,
                bit_rate,
                bit_rate_locked_to_pcrclock,
                bit_rate_locked_to_network_clock,
                aal,
                multiplex,
                reverse_parameters,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCIndicationAalAal1ClockRecovery {
        nullClockRecovery(()),
        srtsClockRecovery(()),
        adaptiveClockRecovery(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCIndicationAalAal1ErrorCorrection {
        nullErrorCorrection(()),
        longInterleaver(()),
        shortInterleaver(()),
        errorCorrectionOnly(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NewATMVCIndicationAalAal1 {
        #[rasn(identifier = "clockRecovery")]
        pub clock_recovery: NewATMVCIndicationAalAal1ClockRecovery,
        #[rasn(identifier = "errorCorrection")]
        pub error_correction: NewATMVCIndicationAalAal1ErrorCorrection,
        #[rasn(identifier = "structuredDataTransfer")]
        pub structured_data_transfer: bool,
        #[rasn(identifier = "partiallyFilledCells")]
        pub partially_filled_cells: bool,
    }
    impl NewATMVCIndicationAalAal1 {
        pub fn new(
            clock_recovery: NewATMVCIndicationAalAal1ClockRecovery,
            error_correction: NewATMVCIndicationAalAal1ErrorCorrection,
            structured_data_transfer: bool,
            partially_filled_cells: bool,
        ) -> Self {
            Self {
                clock_recovery,
                error_correction,
                structured_data_transfer,
                partially_filled_cells,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NewATMVCIndicationAalAal5 {
        #[rasn(value("0..=65535"), identifier = "forwardMaximumSDUSize")]
        pub forward_maximum_sdusize: u16,
        #[rasn(value("0..=65535"), identifier = "backwardMaximumSDUSize")]
        pub backward_maximum_sdusize: u16,
    }
    impl NewATMVCIndicationAalAal5 {
        pub fn new(forward_maximum_sdusize: u16, backward_maximum_sdusize: u16) -> Self {
            Self {
                forward_maximum_sdusize,
                backward_maximum_sdusize,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCIndicationAal {
        aal1(NewATMVCIndicationAalAal1),
        aal5(NewATMVCIndicationAalAal5),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCIndicationMultiplex {
        noMultiplex(()),
        transportStream(()),
        programStream(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NewATMVCIndicationReverseParametersMultiplex {
        noMultiplex(()),
        transportStream(()),
        programStream(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NewATMVCIndicationReverseParameters {
        #[rasn(value("1..=65535"), identifier = "bitRate")]
        pub bit_rate: u16,
        #[rasn(identifier = "bitRateLockedToPCRClock")]
        pub bit_rate_locked_to_pcrclock: bool,
        #[rasn(identifier = "bitRateLockedToNetworkClock")]
        pub bit_rate_locked_to_network_clock: bool,
        pub multiplex: NewATMVCIndicationReverseParametersMultiplex,
    }
    impl NewATMVCIndicationReverseParameters {
        pub fn new(
            bit_rate: u16,
            bit_rate_locked_to_pcrclock: bool,
            bit_rate_locked_to_network_clock: bool,
            multiplex: NewATMVCIndicationReverseParametersMultiplex,
        ) -> Self {
            Self {
                bit_rate,
                bit_rate_locked_to_pcrclock,
                bit_rate_locked_to_network_clock,
                multiplex,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : New ATM virtual channel indication"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NewATMVCIndication {
        #[rasn(value("0..=65535"), identifier = "resourceID")]
        pub resource_id: u16,
        #[rasn(value("1..=65535"), identifier = "bitRate")]
        pub bit_rate: u16,
        #[rasn(identifier = "bitRateLockedToPCRClock")]
        pub bit_rate_locked_to_pcrclock: bool,
        #[rasn(identifier = "bitRateLockedToNetworkClock")]
        pub bit_rate_locked_to_network_clock: bool,
        pub aal: NewATMVCIndicationAal,
        pub multiplex: NewATMVCIndicationMultiplex,
        #[rasn(extension_addition, identifier = "reverseParameters")]
        pub reverse_parameters: NewATMVCIndicationReverseParameters,
    }
    impl NewATMVCIndication {
        pub fn new(
            resource_id: u16,
            bit_rate: u16,
            bit_rate_locked_to_pcrclock: bool,
            bit_rate_locked_to_network_clock: bool,
            aal: NewATMVCIndicationAal,
            multiplex: NewATMVCIndicationMultiplex,
            reverse_parameters: NewATMVCIndicationReverseParameters,
        ) -> Self {
            Self {
                resource_id,
                bit_rate,
                bit_rate_locked_to_pcrclock,
                bit_rate_locked_to_network_clock,
                aal,
                multiplex,
                reverse_parameters,
            }
        }
    }
    #[doc = " The following defintions are as above but without a Payload Type field"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NoPTAudioTelephonyEventCapability {
        #[rasn(identifier = "audioTelephoneEvent")]
        pub audio_telephone_event: GeneralString,
    }
    impl NoPTAudioTelephonyEventCapability {
        pub fn new(audio_telephone_event: GeneralString) -> Self {
            Self {
                audio_telephone_event,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NoPTAudioToneCapability {}
    impl NoPTAudioToneCapability {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for NoPTAudioToneCapability {
        fn default() -> Self {
            Self {}
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct NonStandardIdentifierH221NonStandard {
        #[rasn(value("0..=255"), identifier = "t35CountryCode")]
        pub t35_country_code: u8,
        #[rasn(value("0..=255"), identifier = "t35Extension")]
        pub t35_extension: u8,
        #[rasn(value("0..=65535"), identifier = "manufacturerCode")]
        pub manufacturer_code: u16,
    }
    impl NonStandardIdentifierH221NonStandard {
        pub fn new(t35_country_code: u8, t35_extension: u8, manufacturer_code: u16) -> Self {
            Self {
                t35_country_code,
                t35_extension,
                manufacturer_code,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum NonStandardIdentifier {
        object(ObjectIdentifier),
        h221NonStandard(NonStandardIdentifierH221NonStandard),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Non standard Message definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NonStandardMessage {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: NonStandardParameter,
    }
    impl NonStandardMessage {
        pub fn new(non_standard_data: NonStandardParameter) -> Self {
            Self { non_standard_data }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct NonStandardParameter {
        #[rasn(identifier = "nonStandardIdentifier")]
        pub non_standard_identifier: NonStandardIdentifier,
        pub data: OctetString,
    }
    impl NonStandardParameter {
        pub fn new(non_standard_identifier: NonStandardIdentifier, data: OctetString) -> Self {
            Self {
                non_standard_identifier,
                data,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum OpenLogicalChannelForwardLogicalChannelParametersMultiplexParameters {
        h222LogicalChannelParameters(H222LogicalChannelParameters),
        h223LogicalChannelParameters(H223LogicalChannelParameters),
        v76LogicalChannelParameters(V76LogicalChannelParameters),
        #[rasn(extension_addition)]
        h2250LogicalChannelParameters(H2250LogicalChannelParameters),
        #[rasn(extension_addition)]
        none(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct OpenLogicalChannelForwardLogicalChannelParameters {
        #[rasn(value("0..=65535"), identifier = "portNumber")]
        pub port_number: Option<u16>,
        #[rasn(identifier = "dataType")]
        pub data_type: DataType,
        #[rasn(identifier = "multiplexParameters")]
        pub multiplex_parameters:
            OpenLogicalChannelForwardLogicalChannelParametersMultiplexParameters,
        #[rasn(extension_addition, identifier = "forwardLogicalChannelDependency")]
        pub forward_logical_channel_dependency: Option<LogicalChannelNumber>,
        #[rasn(extension_addition, identifier = "replacementFor")]
        pub replacement_for: Option<LogicalChannelNumber>,
    }
    impl OpenLogicalChannelForwardLogicalChannelParameters {
        pub fn new(
            port_number: Option<u16>,
            data_type: DataType,
            multiplex_parameters : OpenLogicalChannelForwardLogicalChannelParametersMultiplexParameters,
            forward_logical_channel_dependency: Option<LogicalChannelNumber>,
            replacement_for: Option<LogicalChannelNumber>,
        ) -> Self {
            Self {
                port_number,
                data_type,
                multiplex_parameters,
                forward_logical_channel_dependency,
                replacement_for,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum OpenLogicalChannelReverseLogicalChannelParametersMultiplexParameters {
        h223LogicalChannelParameters(H223LogicalChannelParameters),
        v76LogicalChannelParameters(V76LogicalChannelParameters),
        #[rasn(extension_addition)]
        h2250LogicalChannelParameters(H2250LogicalChannelParameters),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct OpenLogicalChannelReverseLogicalChannelParameters {
        #[rasn(identifier = "dataType")]
        pub data_type: DataType,
        #[rasn(identifier = "multiplexParameters")]
        pub multiplex_parameters:
            Option<OpenLogicalChannelReverseLogicalChannelParametersMultiplexParameters>,
        #[rasn(extension_addition, identifier = "reverseLogicalChannelDependency")]
        pub reverse_logical_channel_dependency: Option<LogicalChannelNumber>,
        #[rasn(extension_addition, identifier = "replacementFor")]
        pub replacement_for: Option<LogicalChannelNumber>,
    }
    impl OpenLogicalChannelReverseLogicalChannelParameters {
        pub fn new(
            data_type: DataType,
            multiplex_parameters: Option<
                OpenLogicalChannelReverseLogicalChannelParametersMultiplexParameters,
            >,
            reverse_logical_channel_dependency: Option<LogicalChannelNumber>,
            replacement_for: Option<LogicalChannelNumber>,
        ) -> Self {
            Self {
                data_type,
                multiplex_parameters,
                reverse_logical_channel_dependency,
                replacement_for,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Logical channel signalling definitions"]
    #[doc = " ==================================================================================="]
    #[doc = " \"Forward\" is used to refer to transmission in the direction from the terminal making the"]
    #[doc = " original request for a logical channel to the other terminal, and \"reverse\" is used to refer"]
    #[doc = " to the opposite direction of transmission, in the case of a bi-directional channel request."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct OpenLogicalChannel {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
        #[rasn(identifier = "forwardLogicalChannelParameters")]
        pub forward_logical_channel_parameters: OpenLogicalChannelForwardLogicalChannelParameters,
        #[rasn(identifier = "reverseLogicalChannelParameters")]
        pub reverse_logical_channel_parameters:
            Option<OpenLogicalChannelReverseLogicalChannelParameters>,
        #[rasn(extension_addition, identifier = "separateStack")]
        pub separate_stack: Option<NetworkAccessParameters>,
        #[rasn(extension_addition, identifier = "encryptionSync")]
        pub encryption_sync: Option<EncryptionSync>,
    }
    impl OpenLogicalChannel {
        pub fn new(
            forward_logical_channel_number: LogicalChannelNumber,
            forward_logical_channel_parameters: OpenLogicalChannelForwardLogicalChannelParameters,
            reverse_logical_channel_parameters: Option<
                OpenLogicalChannelReverseLogicalChannelParameters,
            >,
            separate_stack: Option<NetworkAccessParameters>,
            encryption_sync: Option<EncryptionSync>,
        ) -> Self {
            Self {
                forward_logical_channel_number,
                forward_logical_channel_parameters,
                reverse_logical_channel_parameters,
                separate_stack,
                encryption_sync,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum OpenLogicalChannelAckReverseLogicalChannelParametersMultiplexParameters {
        h222LogicalChannelParameters(H222LogicalChannelParameters),
        #[rasn(extension_addition)]
        h2250LogicalChannelParameters(H2250LogicalChannelParameters),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct OpenLogicalChannelAckReverseLogicalChannelParameters {
        #[rasn(identifier = "reverseLogicalChannelNumber")]
        pub reverse_logical_channel_number: LogicalChannelNumber,
        #[rasn(value("0..=65535"), identifier = "portNumber")]
        pub port_number: Option<u16>,
        #[rasn(identifier = "multiplexParameters")]
        pub multiplex_parameters:
            Option<OpenLogicalChannelAckReverseLogicalChannelParametersMultiplexParameters>,
        #[rasn(extension_addition, identifier = "replacementFor")]
        pub replacement_for: Option<LogicalChannelNumber>,
    }
    impl OpenLogicalChannelAckReverseLogicalChannelParameters {
        pub fn new(
            reverse_logical_channel_number: LogicalChannelNumber,
            port_number: Option<u16>,
            multiplex_parameters: Option<
                OpenLogicalChannelAckReverseLogicalChannelParametersMultiplexParameters,
            >,
            replacement_for: Option<LogicalChannelNumber>,
        ) -> Self {
            Self {
                reverse_logical_channel_number,
                port_number,
                multiplex_parameters,
                replacement_for,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum OpenLogicalChannelAckForwardMultiplexAckParameters {
        h2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct OpenLogicalChannelAck {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
        #[rasn(identifier = "reverseLogicalChannelParameters")]
        pub reverse_logical_channel_parameters:
            Option<OpenLogicalChannelAckReverseLogicalChannelParameters>,
        #[rasn(extension_addition, identifier = "separateStack")]
        pub separate_stack: Option<NetworkAccessParameters>,
        #[rasn(extension_addition, identifier = "forwardMultiplexAckParameters")]
        pub forward_multiplex_ack_parameters:
            Option<OpenLogicalChannelAckForwardMultiplexAckParameters>,
        #[rasn(extension_addition, identifier = "encryptionSync")]
        pub encryption_sync: Option<EncryptionSync>,
    }
    impl OpenLogicalChannelAck {
        pub fn new(
            forward_logical_channel_number: LogicalChannelNumber,
            reverse_logical_channel_parameters: Option<
                OpenLogicalChannelAckReverseLogicalChannelParameters,
            >,
            separate_stack: Option<NetworkAccessParameters>,
            forward_multiplex_ack_parameters: Option<
                OpenLogicalChannelAckForwardMultiplexAckParameters,
            >,
            encryption_sync: Option<EncryptionSync>,
        ) -> Self {
            Self {
                forward_logical_channel_number,
                reverse_logical_channel_parameters,
                separate_stack,
                forward_multiplex_ack_parameters,
                encryption_sync,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct OpenLogicalChannelConfirm {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
    }
    impl OpenLogicalChannelConfirm {
        pub fn new(forward_logical_channel_number: LogicalChannelNumber) -> Self {
            Self {
                forward_logical_channel_number,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum OpenLogicalChannelRejectCause {
        unspecified(()),
        unsuitableReverseParameters(()),
        dataTypeNotSupported(()),
        dataTypeNotAvailable(()),
        unknownDataType(()),
        dataTypeALCombinationNotSupported(()),
        #[rasn(extension_addition)]
        multicastChannelNotAllowed(()),
        #[rasn(extension_addition)]
        insufficientBandwidth(()),
        #[rasn(extension_addition)]
        separateStackEstablishmentFailed(()),
        #[rasn(extension_addition)]
        invalidSessionID(()),
        #[rasn(extension_addition)]
        masterSlaveConflict(()),
        #[rasn(extension_addition)]
        waitForCommunicationMode(()),
        #[rasn(extension_addition)]
        invalidDependentChannel(()),
        #[rasn(extension_addition)]
        replacementForRejected(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct OpenLogicalChannelReject {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
        pub cause: OpenLogicalChannelRejectCause,
    }
    impl OpenLogicalChannelReject {
        pub fn new(
            forward_logical_channel_number: LogicalChannelNumber,
            cause: OpenLogicalChannelRejectCause,
        ) -> Self {
            Self {
                forward_logical_channel_number,
                cause,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ParameterIdentifier {
        #[rasn(value("0..=127"))]
        standard(u8),
        h221NonStandard(NonStandardParameter),
        #[rasn(size("16"))]
        uuid(OctetString),
        #[rasn(size("1..=64"))]
        domainBased(Ia5String),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ParameterValue {
        logical(()),
        #[rasn(value("0..=255"))]
        booleanArray(u8),
        #[rasn(value("0..=65535"))]
        unsignedMin(u16),
        #[rasn(value("0..=65535"))]
        unsignedMax(u16),
        #[rasn(value("0..=4294967295"))]
        unsigned32Min(u32),
        #[rasn(value("0..=4294967295"))]
        unsigned32Max(u32),
        octetString(OctetString),
        genericParameter(SequenceOf<GenericParameter>),
    }
    #[doc = " initial value for"]
    #[doc = " 128-bit block ciphers"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Params {
        pub iv8: Option<IV8>,
        pub iv16: Option<IV16>,
        pub iv: Option<OctetString>,
    }
    impl Params {
        pub fn new(iv8: Option<IV8>, iv16: Option<IV16>, iv: Option<OctetString>) -> Self {
            Self { iv8, iv16, iv }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=32"))]
    pub struct Password(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PictureReference {
        #[rasn(value("0..=1023"))]
        pictureNumber(u16),
        #[rasn(value("0..=255"))]
        longTermPictureIndex(u8),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum Q2931AddressAddress {
        #[rasn(size("1..=16"))]
        internationalNumber(NumericString),
        #[rasn(size("1..=20"))]
        nsapAddress(OctetString),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Q2931Address {
        pub address: Q2931AddressAddress,
        #[rasn(size("1..=20"))]
        pub subaddress: Option<OctetString>,
    }
    impl Q2931Address {
        pub fn new(address: Q2931AddressAddress, subaddress: Option<OctetString>) -> Self {
            Self {
                address,
                subaddress,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct QOSCapability {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "rsvpParameters")]
        pub rsvp_parameters: Option<RSVPParameters>,
        #[rasn(identifier = "atmParameters")]
        pub atm_parameters: Option<ATMParameters>,
    }
    impl QOSCapability {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            rsvp_parameters: Option<RSVPParameters>,
            atm_parameters: Option<ATMParameters>,
        ) -> Self {
            Self {
                non_standard_data,
                rsvp_parameters,
                atm_parameters,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum QOSMode {
        guaranteedQOS(()),
        controlledLoad(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RSVPParameters {
        #[rasn(identifier = "qosMode")]
        pub qos_mode: Option<QOSMode>,
        #[rasn(value("1..=4294967295"), identifier = "tokenRate")]
        pub token_rate: Option<u32>,
        #[rasn(value("1..=4294967295"), identifier = "bucketSize")]
        pub bucket_size: Option<u32>,
        #[rasn(value("1..=4294967295"), identifier = "peakRate")]
        pub peak_rate: Option<u32>,
        #[rasn(value("1..=4294967295"), identifier = "minPoliced")]
        pub min_policed: Option<u32>,
        #[rasn(value("1..=4294967295"), identifier = "maxPktSize")]
        pub max_pkt_size: Option<u32>,
    }
    impl RSVPParameters {
        pub fn new(
            qos_mode: Option<QOSMode>,
            token_rate: Option<u32>,
            bucket_size: Option<u32>,
            peak_rate: Option<u32>,
            min_policed: Option<u32>,
            max_pkt_size: Option<u32>,
        ) -> Self {
            Self {
                qos_mode,
                token_rate,
                bucket_size,
                peak_rate,
                min_policed,
                max_pkt_size,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RTPH263VideoRedundancyEncodingFrameToThreadMapping {
        roundrobin(()),
        #[rasn(size("1..=256"))]
        custom(SequenceOf<RTPH263VideoRedundancyFrameMapping>),
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER", value("0..=15"))]
    pub struct AnonymousRTPH263VideoRedundancyEncodingContainedThreads(pub u8);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=256"))]
    pub struct RTPH263VideoRedundancyEncodingContainedThreads(
        pub SequenceOf<AnonymousRTPH263VideoRedundancyEncodingContainedThreads>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RTPH263VideoRedundancyEncoding {
        #[rasn(value("1..=16"), identifier = "numberOfThreads")]
        pub number_of_threads: u8,
        #[rasn(value("1..=256"), identifier = "framesBetweenSyncPoints")]
        pub frames_between_sync_points: u16,
        #[rasn(identifier = "frameToThreadMapping")]
        pub frame_to_thread_mapping: RTPH263VideoRedundancyEncodingFrameToThreadMapping,
        #[rasn(identifier = "containedThreads")]
        pub contained_threads: Option<RTPH263VideoRedundancyEncodingContainedThreads>,
    }
    impl RTPH263VideoRedundancyEncoding {
        pub fn new(
            number_of_threads: u8,
            frames_between_sync_points: u16,
            frame_to_thread_mapping: RTPH263VideoRedundancyEncodingFrameToThreadMapping,
            contained_threads: Option<RTPH263VideoRedundancyEncodingContainedThreads>,
        ) -> Self {
            Self {
                number_of_threads,
                frames_between_sync_points,
                frame_to_thread_mapping,
                contained_threads,
            }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER", value("0..=255"))]
    pub struct AnonymousRTPH263VideoRedundancyFrameMappingFrameSequence(pub u8);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=256"))]
    pub struct RTPH263VideoRedundancyFrameMappingFrameSequence(
        pub SequenceOf<AnonymousRTPH263VideoRedundancyFrameMappingFrameSequence>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RTPH263VideoRedundancyFrameMapping {
        #[rasn(value("0..=15"), identifier = "threadNumber")]
        pub thread_number: u8,
        #[rasn(identifier = "frameSequence")]
        pub frame_sequence: RTPH263VideoRedundancyFrameMappingFrameSequence,
    }
    impl RTPH263VideoRedundancyFrameMapping {
        pub fn new(
            thread_number: u8,
            frame_sequence: RTPH263VideoRedundancyFrameMappingFrameSequence,
        ) -> Self {
            Self {
                thread_number,
                frame_sequence,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RTPPayloadTypePayloadDescriptor {
        nonStandardIdentifier(NonStandardParameter),
        #[rasn(value("1..=32768", extensible), identifier = "rfc-number")]
        rfc_number(Integer),
        oid(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RTPPayloadType {
        #[rasn(identifier = "payloadDescriptor")]
        pub payload_descriptor: RTPPayloadTypePayloadDescriptor,
        #[rasn(value("0..=127"), identifier = "payloadType")]
        pub payload_type: Option<u8>,
    }
    impl RTPPayloadType {
        pub fn new(
            payload_descriptor: RTPPayloadTypePayloadDescriptor,
            payload_type: Option<u8>,
        ) -> Self {
            Self {
                payload_descriptor,
                payload_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RedundancyEncodingRtpRedundancyEncoding {
        pub primary: Option<RedundancyEncodingElement>,
        pub secondary: Option<SequenceOf<RedundancyEncodingElement>>,
    }
    impl RedundancyEncodingRtpRedundancyEncoding {
        pub fn new(
            primary: Option<RedundancyEncodingElement>,
            secondary: Option<SequenceOf<RedundancyEncodingElement>>,
        ) -> Self {
            Self { primary, secondary }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RedundancyEncoding {
        #[rasn(identifier = "redundancyEncodingMethod")]
        pub redundancy_encoding_method: RedundancyEncodingMethod,
        #[rasn(identifier = "secondaryEncoding")]
        pub secondary_encoding: Option<Box<DataType>>,
        #[rasn(extension_addition, identifier = "rtpRedundancyEncoding")]
        pub rtp_redundancy_encoding: Option<RedundancyEncodingRtpRedundancyEncoding>,
    }
    impl RedundancyEncoding {
        pub fn new(
            redundancy_encoding_method: RedundancyEncodingMethod,
            secondary_encoding: Option<Box<DataType>>,
            rtp_redundancy_encoding: Option<RedundancyEncodingRtpRedundancyEncoding>,
        ) -> Self {
            Self {
                redundancy_encoding_method,
                secondary_encoding,
                rtp_redundancy_encoding,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RedundancyEncodingCapability {
        #[rasn(identifier = "redundancyEncodingMethod")]
        pub redundancy_encoding_method: RedundancyEncodingMethod,
        #[rasn(identifier = "primaryEncoding")]
        pub primary_encoding: CapabilityTableEntryNumber,
        #[rasn(size("1..=256"), identifier = "secondaryEncoding")]
        pub secondary_encoding: Option<SequenceOf<CapabilityTableEntryNumber>>,
    }
    impl RedundancyEncodingCapability {
        pub fn new(
            redundancy_encoding_method: RedundancyEncodingMethod,
            primary_encoding: CapabilityTableEntryNumber,
            secondary_encoding: Option<SequenceOf<CapabilityTableEntryNumber>>,
        ) -> Self {
            Self {
                redundancy_encoding_method,
                primary_encoding,
                secondary_encoding,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RedundancyEncodingDTMode {
        #[rasn(identifier = "redundancyEncodingMethod")]
        pub redundancy_encoding_method: RedundancyEncodingMethod,
        pub primary: RedundancyEncodingDTModeElement,
        pub secondary: SequenceOf<RedundancyEncodingDTModeElement>,
    }
    impl RedundancyEncodingDTMode {
        pub fn new(
            redundancy_encoding_method: RedundancyEncodingMethod,
            primary: RedundancyEncodingDTModeElement,
            secondary: SequenceOf<RedundancyEncodingDTModeElement>,
        ) -> Self {
            Self {
                redundancy_encoding_method,
                primary,
                secondary,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RedundancyEncodingDTModeElementType {
        nonStandard(NonStandardParameter),
        videoMode(VideoMode),
        audioMode(AudioMode),
        dataMode(DataMode),
        encryptionMode(EncryptionMode),
        h235Mode(H235Mode),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RedundancyEncodingDTModeElement {
        #[rasn(identifier = "type")]
        pub r_type: RedundancyEncodingDTModeElementType,
    }
    impl RedundancyEncodingDTModeElement {
        pub fn new(r_type: RedundancyEncodingDTModeElementType) -> Self {
            Self { r_type }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RedundancyEncodingElement {
        #[rasn(identifier = "dataType")]
        pub data_type: Box<DataType>,
        #[rasn(value("0..=127"), identifier = "payloadType")]
        pub payload_type: Option<u8>,
    }
    impl RedundancyEncodingElement {
        pub fn new(data_type: Box<DataType>, payload_type: Option<u8>) -> Self {
            Self {
                data_type,
                payload_type,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RedundancyEncodingMethod {
        nonStandard(NonStandardParameter),
        rtpAudioRedundancyEncoding(()),
        #[rasn(extension_addition)]
        rtpH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RedundancyEncodingModeSecondaryEncoding {
        nonStandard(NonStandardParameter),
        audioData(AudioMode),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RedundancyEncodingMode {
        #[rasn(identifier = "redundancyEncodingMethod")]
        pub redundancy_encoding_method: RedundancyEncodingMethod,
        #[rasn(identifier = "secondaryEncoding")]
        pub secondary_encoding: Option<RedundancyEncodingModeSecondaryEncoding>,
    }
    impl RedundancyEncodingMode {
        pub fn new(
            redundancy_encoding_method: RedundancyEncodingMethod,
            secondary_encoding: Option<RedundancyEncodingModeSecondaryEncoding>,
        ) -> Self {
            Self {
                redundancy_encoding_method,
                secondary_encoding,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RefPictureSelectionAdditionalPictureMemory {
        #[rasn(value("1..=256"), identifier = "sqcifAdditionalPictureMemory")]
        pub sqcif_additional_picture_memory: Option<u16>,
        #[rasn(value("1..=256"), identifier = "qcifAdditionalPictureMemory")]
        pub qcif_additional_picture_memory: Option<u16>,
        #[rasn(value("1..=256"), identifier = "cifAdditionalPictureMemory")]
        pub cif_additional_picture_memory: Option<u16>,
        #[rasn(value("1..=256"), identifier = "cif4AdditionalPictureMemory")]
        pub cif4_additional_picture_memory: Option<u16>,
        #[rasn(value("1..=256"), identifier = "cif16AdditionalPictureMemory")]
        pub cif16_additional_picture_memory: Option<u16>,
        #[rasn(value("1..=256"), identifier = "bigCpfAdditionalPictureMemory")]
        pub big_cpf_additional_picture_memory: Option<u16>,
    }
    impl RefPictureSelectionAdditionalPictureMemory {
        pub fn new(
            sqcif_additional_picture_memory: Option<u16>,
            qcif_additional_picture_memory: Option<u16>,
            cif_additional_picture_memory: Option<u16>,
            cif4_additional_picture_memory: Option<u16>,
            cif16_additional_picture_memory: Option<u16>,
            big_cpf_additional_picture_memory: Option<u16>,
        ) -> Self {
            Self {
                sqcif_additional_picture_memory,
                qcif_additional_picture_memory,
                cif_additional_picture_memory,
                cif4_additional_picture_memory,
                cif16_additional_picture_memory,
                big_cpf_additional_picture_memory,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RefPictureSelectionVideoBackChannelSend {
        none(()),
        ackMessageOnly(()),
        nackMessageOnly(()),
        ackOrNackMessageOnly(()),
        ackAndNackMessage(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RefPictureSelectionEnhancedReferencePicSelectSubPictureRemovalParameters {
        #[rasn(value("1..=128"), identifier = "mpuHorizMBs")]
        pub mpu_horiz_mbs: u8,
        #[rasn(value("1..=72"), identifier = "mpuVertMBs")]
        pub mpu_vert_mbs: u8,
        #[rasn(value("1..=65536"), identifier = "mpuTotalNumber")]
        pub mpu_total_number: u32,
    }
    impl RefPictureSelectionEnhancedReferencePicSelectSubPictureRemovalParameters {
        pub fn new(mpu_horiz_mbs: u8, mpu_vert_mbs: u8, mpu_total_number: u32) -> Self {
            Self {
                mpu_horiz_mbs,
                mpu_vert_mbs,
                mpu_total_number,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RefPictureSelectionEnhancedReferencePicSelect {
        #[rasn(identifier = "subPictureRemovalParameters")]
        pub sub_picture_removal_parameters:
            Option<RefPictureSelectionEnhancedReferencePicSelectSubPictureRemovalParameters>,
    }
    impl RefPictureSelectionEnhancedReferencePicSelect {
        pub fn new(
            sub_picture_removal_parameters: Option<
                RefPictureSelectionEnhancedReferencePicSelectSubPictureRemovalParameters,
            >,
        ) -> Self {
            Self {
                sub_picture_removal_parameters,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RefPictureSelection {
        #[rasn(identifier = "additionalPictureMemory")]
        pub additional_picture_memory: Option<RefPictureSelectionAdditionalPictureMemory>,
        #[rasn(identifier = "videoMux")]
        pub video_mux: bool,
        #[rasn(identifier = "videoBackChannelSend")]
        pub video_back_channel_send: RefPictureSelectionVideoBackChannelSend,
        #[rasn(extension_addition, identifier = "enhancedReferencePicSelect")]
        pub enhanced_reference_pic_select: RefPictureSelectionEnhancedReferencePicSelect,
    }
    impl RefPictureSelection {
        pub fn new(
            additional_picture_memory: Option<RefPictureSelectionAdditionalPictureMemory>,
            video_mux: bool,
            video_back_channel_send: RefPictureSelectionVideoBackChannelSend,
            enhanced_reference_pic_select: RefPictureSelectionEnhancedReferencePicSelect,
        ) -> Self {
            Self {
                additional_picture_memory,
                video_mux,
                video_back_channel_send,
                enhanced_reference_pic_select,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Remote MC Request definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RemoteMCRequest {
        masterActivate(()),
        slaveActivate(()),
        deActivate(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RemoteMCResponseReject {
        unspecified(()),
        functionNotSupported(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RemoteMCResponse {
        accept(()),
        reject(RemoteMCResponseReject),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestAllTerminalIDsResponse {
        #[rasn(identifier = "terminalInformation")]
        pub terminal_information: SequenceOf<TerminalInformation>,
    }
    impl RequestAllTerminalIDsResponse {
        pub fn new(terminal_information: SequenceOf<TerminalInformation>) -> Self {
            Self {
                terminal_information,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RequestChannelCloseReason {
        unknown(()),
        normal(()),
        reopen(()),
        reservationFailure(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestChannelClose {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
        #[rasn(extension_addition, identifier = "qosCapability")]
        pub qos_capability: Option<QOSCapability>,
        #[rasn(extension_addition)]
        pub reason: RequestChannelCloseReason,
    }
    impl RequestChannelClose {
        pub fn new(
            forward_logical_channel_number: LogicalChannelNumber,
            qos_capability: Option<QOSCapability>,
            reason: RequestChannelCloseReason,
        ) -> Self {
            Self {
                forward_logical_channel_number,
                qos_capability,
                reason,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestChannelCloseAck {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
    }
    impl RequestChannelCloseAck {
        pub fn new(forward_logical_channel_number: LogicalChannelNumber) -> Self {
            Self {
                forward_logical_channel_number,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RequestChannelCloseRejectCause {
        unspecified(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestChannelCloseReject {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
        pub cause: RequestChannelCloseRejectCause,
    }
    impl RequestChannelCloseReject {
        pub fn new(
            forward_logical_channel_number: LogicalChannelNumber,
            cause: RequestChannelCloseRejectCause,
        ) -> Self {
            Self {
                forward_logical_channel_number,
                cause,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestChannelCloseRelease {
        #[rasn(identifier = "forwardLogicalChannelNumber")]
        pub forward_logical_channel_number: LogicalChannelNumber,
    }
    impl RequestChannelCloseRelease {
        pub fn new(forward_logical_channel_number: LogicalChannelNumber) -> Self {
            Self {
                forward_logical_channel_number,
            }
        }
    }
    #[doc = " A RequestMessage results in action and requires an immediate response"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RequestMessage {
        nonStandard(NonStandardMessage),
        masterSlaveDetermination(MasterSlaveDetermination),
        terminalCapabilitySet(TerminalCapabilitySet),
        openLogicalChannel(OpenLogicalChannel),
        closeLogicalChannel(CloseLogicalChannel),
        requestChannelClose(RequestChannelClose),
        multiplexEntrySend(MultiplexEntrySend),
        requestMultiplexEntry(RequestMultiplexEntry),
        requestMode(RequestMode),
        roundTripDelayRequest(RoundTripDelayRequest),
        maintenanceLoopRequest(MaintenanceLoopRequest),
        #[rasn(extension_addition)]
        communicationModeRequest(CommunicationModeRequest),
        #[rasn(extension_addition)]
        conferenceRequest(ConferenceRequest),
        #[rasn(extension_addition)]
        multilinkRequest(MultilinkRequest),
        #[rasn(extension_addition)]
        logicalChannelRateRequest(LogicalChannelRateRequest),
        #[rasn(extension_addition)]
        genericRequest(GenericMessage),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Request mode definitions"]
    #[doc = " ==================================================================================="]
    #[doc = " RequestMode is a list, in order or preference, of modes that a terminal would like"]
    #[doc = " to have transmitted to it."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestMode {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(size("1..=256"), identifier = "requestedModes")]
        pub requested_modes: SequenceOf<ModeDescription>,
    }
    impl RequestMode {
        pub fn new(
            sequence_number: SequenceNumber,
            requested_modes: SequenceOf<ModeDescription>,
        ) -> Self {
            Self {
                sequence_number,
                requested_modes,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RequestModeAckResponse {
        willTransmitMostPreferredMode(()),
        willTransmitLessPreferredMode(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestModeAck {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        pub response: RequestModeAckResponse,
    }
    impl RequestModeAck {
        pub fn new(sequence_number: SequenceNumber, response: RequestModeAckResponse) -> Self {
            Self {
                sequence_number,
                response,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RequestModeRejectCause {
        modeUnavailable(()),
        multipointConstraint(()),
        requestDenied(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestModeReject {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        pub cause: RequestModeRejectCause,
    }
    impl RequestModeReject {
        pub fn new(sequence_number: SequenceNumber, cause: RequestModeRejectCause) -> Self {
            Self {
                sequence_number,
                cause,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestModeRelease {}
    impl RequestModeRelease {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for RequestModeRelease {
        fn default() -> Self {
            Self {}
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestMultiplexEntry {
        #[rasn(size("1..=15"), identifier = "entryNumbers")]
        pub entry_numbers: SetOf<MultiplexTableEntryNumber>,
    }
    impl RequestMultiplexEntry {
        pub fn new(entry_numbers: SetOf<MultiplexTableEntryNumber>) -> Self {
            Self { entry_numbers }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestMultiplexEntryAck {
        #[rasn(size("1..=15"), identifier = "entryNumbers")]
        pub entry_numbers: SetOf<MultiplexTableEntryNumber>,
    }
    impl RequestMultiplexEntryAck {
        pub fn new(entry_numbers: SetOf<MultiplexTableEntryNumber>) -> Self {
            Self { entry_numbers }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestMultiplexEntryReject {
        #[rasn(size("1..=15"), identifier = "entryNumbers")]
        pub entry_numbers: SetOf<MultiplexTableEntryNumber>,
        #[rasn(size("1..=15"), identifier = "rejectionDescriptions")]
        pub rejection_descriptions: SetOf<RequestMultiplexEntryRejectionDescriptions>,
    }
    impl RequestMultiplexEntryReject {
        pub fn new(
            entry_numbers: SetOf<MultiplexTableEntryNumber>,
            rejection_descriptions: SetOf<RequestMultiplexEntryRejectionDescriptions>,
        ) -> Self {
            Self {
                entry_numbers,
                rejection_descriptions,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RequestMultiplexEntryRejectionDescriptionsCause {
        unspecifiedCause(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestMultiplexEntryRejectionDescriptions {
        #[rasn(identifier = "multiplexTableEntryNumber")]
        pub multiplex_table_entry_number: MultiplexTableEntryNumber,
        pub cause: RequestMultiplexEntryRejectionDescriptionsCause,
    }
    impl RequestMultiplexEntryRejectionDescriptions {
        pub fn new(
            multiplex_table_entry_number: MultiplexTableEntryNumber,
            cause: RequestMultiplexEntryRejectionDescriptionsCause,
        ) -> Self {
            Self {
                multiplex_table_entry_number,
                cause,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestMultiplexEntryRelease {
        #[rasn(size("1..=15"), identifier = "entryNumbers")]
        pub entry_numbers: SetOf<MultiplexTableEntryNumber>,
    }
    impl RequestMultiplexEntryRelease {
        pub fn new(entry_numbers: SetOf<MultiplexTableEntryNumber>) -> Self {
            Self { entry_numbers }
        }
    }
    #[doc = " A ResponseMessage is the response to a request Message"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ResponseMessage {
        nonStandard(NonStandardMessage),
        masterSlaveDeterminationAck(MasterSlaveDeterminationAck),
        masterSlaveDeterminationReject(MasterSlaveDeterminationReject),
        terminalCapabilitySetAck(TerminalCapabilitySetAck),
        terminalCapabilitySetReject(TerminalCapabilitySetReject),
        openLogicalChannelAck(OpenLogicalChannelAck),
        openLogicalChannelReject(OpenLogicalChannelReject),
        closeLogicalChannelAck(CloseLogicalChannelAck),
        requestChannelCloseAck(RequestChannelCloseAck),
        requestChannelCloseReject(RequestChannelCloseReject),
        multiplexEntrySendAck(MultiplexEntrySendAck),
        multiplexEntrySendReject(MultiplexEntrySendReject),
        requestMultiplexEntryAck(RequestMultiplexEntryAck),
        requestMultiplexEntryReject(RequestMultiplexEntryReject),
        requestModeAck(RequestModeAck),
        requestModeReject(RequestModeReject),
        roundTripDelayResponse(RoundTripDelayResponse),
        maintenanceLoopAck(MaintenanceLoopAck),
        maintenanceLoopReject(MaintenanceLoopReject),
        #[rasn(extension_addition)]
        communicationModeResponse(CommunicationModeResponse),
        #[rasn(extension_addition)]
        conferenceResponse(ConferenceResponse),
        #[rasn(extension_addition)]
        multilinkResponse(MultilinkResponse),
        #[rasn(extension_addition)]
        logicalChannelRateAcknowledge(LogicalChannelRateAcknowledge),
        #[rasn(extension_addition)]
        logicalChannelRateReject(LogicalChannelRateReject),
        #[rasn(extension_addition)]
        genericResponse(GenericMessage),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Round Trip Delay definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RoundTripDelayRequest {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
    }
    impl RoundTripDelayRequest {
        pub fn new(sequence_number: SequenceNumber) -> Self {
            Self { sequence_number }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RoundTripDelayResponse {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
    }
    impl RoundTripDelayResponse {
        pub fn new(sequence_number: SequenceNumber) -> Self {
            Self { sequence_number }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SendTerminalCapabilitySetSpecificRequest {
        #[rasn(identifier = "multiplexCapability")]
        pub multiplex_capability: bool,
        #[rasn(size("1..=65535"), identifier = "capabilityTableEntryNumbers")]
        pub capability_table_entry_numbers: Option<SetOf<CapabilityTableEntryNumber>>,
        #[rasn(size("1..=256"), identifier = "capabilityDescriptorNumbers")]
        pub capability_descriptor_numbers: Option<SetOf<CapabilityDescriptorNumber>>,
    }
    impl SendTerminalCapabilitySetSpecificRequest {
        pub fn new(
            multiplex_capability: bool,
            capability_table_entry_numbers: Option<SetOf<CapabilityTableEntryNumber>>,
            capability_descriptor_numbers: Option<SetOf<CapabilityDescriptorNumber>>,
        ) -> Self {
            Self {
                multiplex_capability,
                capability_table_entry_numbers,
                capability_descriptor_numbers,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Command Message definitions"]
    #[doc = " ==================================================================================="]
    #[doc = " ==================================================================================="]
    #[doc = " Command Message : Send Terminal Capability Set"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum SendTerminalCapabilitySet {
        specificRequest(SendTerminalCapabilitySetSpecificRequest),
        genericRequest(()),
    }
    #[doc = " SequenceNumber is defined here as it is used in a number of Messages"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=255"))]
    pub struct SequenceNumber(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SubstituteConferenceIDCommand {
        #[rasn(size("16"), identifier = "conferenceIdentifier")]
        pub conference_identifier: OctetString,
    }
    impl SubstituteConferenceIDCommand {
        pub fn new(conference_identifier: OctetString) -> Self {
            Self {
                conference_identifier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct T38FaxProfile {
        #[rasn(identifier = "fillBitRemoval")]
        pub fill_bit_removal: bool,
        #[rasn(identifier = "transcodingJBIG")]
        pub transcoding_jbig: bool,
        #[rasn(identifier = "transcodingMMR")]
        pub transcoding_mmr: bool,
        #[rasn(extension_addition, value("0..=255"))]
        pub version: u8,
        #[rasn(extension_addition, identifier = "t38FaxRateManagement")]
        pub t38_fax_rate_management: T38FaxRateManagement,
        #[rasn(extension_addition, identifier = "t38FaxUdpOptions")]
        pub t38_fax_udp_options: Option<T38FaxUdpOptions>,
        #[rasn(extension_addition, identifier = "t38FaxTcpOptions")]
        pub t38_fax_tcp_options: Option<T38FaxTcpOptions>,
    }
    impl T38FaxProfile {
        pub fn new(
            fill_bit_removal: bool,
            transcoding_jbig: bool,
            transcoding_mmr: bool,
            version: u8,
            t38_fax_rate_management: T38FaxRateManagement,
            t38_fax_udp_options: Option<T38FaxUdpOptions>,
            t38_fax_tcp_options: Option<T38FaxTcpOptions>,
        ) -> Self {
            Self {
                fill_bit_removal,
                transcoding_jbig,
                transcoding_mmr,
                version,
                t38_fax_rate_management,
                t38_fax_udp_options,
                t38_fax_tcp_options,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum T38FaxRateManagement {
        localTCF(()),
        transferredTCF(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct T38FaxTcpOptions {
        #[rasn(identifier = "t38TCPBidirectionalMode")]
        pub t38_tcpbidirectional_mode: bool,
    }
    impl T38FaxTcpOptions {
        pub fn new(t38_tcpbidirectional_mode: bool) -> Self {
            Self {
                t38_tcpbidirectional_mode,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum T38FaxUdpOptionsT38FaxUdpEC {
        t38UDPFEC(()),
        t38UDPRedundancy(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct T38FaxUdpOptions {
        #[rasn(identifier = "t38FaxMaxBuffer")]
        pub t38_fax_max_buffer: Option<Integer>,
        #[rasn(identifier = "t38FaxMaxDatagram")]
        pub t38_fax_max_datagram: Option<Integer>,
        #[rasn(identifier = "t38FaxUdpEC")]
        pub t38_fax_udp_ec: T38FaxUdpOptionsT38FaxUdpEC,
    }
    impl T38FaxUdpOptions {
        pub fn new(
            t38_fax_max_buffer: Option<Integer>,
            t38_fax_max_datagram: Option<Integer>,
            t38_fax_udp_ec: T38FaxUdpOptionsT38FaxUdpEC,
        ) -> Self {
            Self {
                t38_fax_max_buffer,
                t38_fax_max_datagram,
                t38_fax_udp_ec,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct T84ProfileT84Restricted {
        pub qcif: bool,
        pub cif: bool,
        #[rasn(identifier = "ccir601Seq")]
        pub ccir601_seq: bool,
        #[rasn(identifier = "ccir601Prog")]
        pub ccir601_prog: bool,
        #[rasn(identifier = "hdtvSeq")]
        pub hdtv_seq: bool,
        #[rasn(identifier = "hdtvProg")]
        pub hdtv_prog: bool,
        #[rasn(identifier = "g3FacsMH200x100")]
        pub g3_facs_mh200x100: bool,
        #[rasn(identifier = "g3FacsMH200x200")]
        pub g3_facs_mh200x200: bool,
        #[rasn(identifier = "g4FacsMMR200x100")]
        pub g4_facs_mmr200x100: bool,
        #[rasn(identifier = "g4FacsMMR200x200")]
        pub g4_facs_mmr200x200: bool,
        #[rasn(identifier = "jbig200x200Seq")]
        pub jbig200x200_seq: bool,
        #[rasn(identifier = "jbig200x200Prog")]
        pub jbig200x200_prog: bool,
        #[rasn(identifier = "jbig300x300Seq")]
        pub jbig300x300_seq: bool,
        #[rasn(identifier = "jbig300x300Prog")]
        pub jbig300x300_prog: bool,
        #[rasn(identifier = "digPhotoLow")]
        pub dig_photo_low: bool,
        #[rasn(identifier = "digPhotoMedSeq")]
        pub dig_photo_med_seq: bool,
        #[rasn(identifier = "digPhotoMedProg")]
        pub dig_photo_med_prog: bool,
        #[rasn(identifier = "digPhotoHighSeq")]
        pub dig_photo_high_seq: bool,
        #[rasn(identifier = "digPhotoHighProg")]
        pub dig_photo_high_prog: bool,
    }
    impl T84ProfileT84Restricted {
        pub fn new(
            qcif: bool,
            cif: bool,
            ccir601_seq: bool,
            ccir601_prog: bool,
            hdtv_seq: bool,
            hdtv_prog: bool,
            g3_facs_mh200x100: bool,
            g3_facs_mh200x200: bool,
            g4_facs_mmr200x100: bool,
            g4_facs_mmr200x200: bool,
            jbig200x200_seq: bool,
            jbig200x200_prog: bool,
            jbig300x300_seq: bool,
            jbig300x300_prog: bool,
            dig_photo_low: bool,
            dig_photo_med_seq: bool,
            dig_photo_med_prog: bool,
            dig_photo_high_seq: bool,
            dig_photo_high_prog: bool,
        ) -> Self {
            Self {
                qcif,
                cif,
                ccir601_seq,
                ccir601_prog,
                hdtv_seq,
                hdtv_prog,
                g3_facs_mh200x100,
                g3_facs_mh200x200,
                g4_facs_mmr200x100,
                g4_facs_mmr200x200,
                jbig200x200_seq,
                jbig200x200_prog,
                jbig300x300_seq,
                jbig300x300_prog,
                dig_photo_low,
                dig_photo_med_seq,
                dig_photo_med_prog,
                dig_photo_high_seq,
                dig_photo_high_prog,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum T84Profile {
        t84Unrestricted(()),
        t84Restricted(T84ProfileT84Restricted),
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability exchange definitions"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalCapabilitySet {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ObjectIdentifier,
        #[rasn(identifier = "multiplexCapability")]
        pub multiplex_capability: Option<MultiplexCapability>,
        #[rasn(size("1..=256"), identifier = "capabilityTable")]
        pub capability_table: Option<SetOf<CapabilityTableEntry>>,
        #[rasn(size("1..=256"), identifier = "capabilityDescriptors")]
        pub capability_descriptors: Option<SetOf<CapabilityDescriptor>>,
    }
    impl TerminalCapabilitySet {
        pub fn new(
            sequence_number: SequenceNumber,
            protocol_identifier: ObjectIdentifier,
            multiplex_capability: Option<MultiplexCapability>,
            capability_table: Option<SetOf<CapabilityTableEntry>>,
            capability_descriptors: Option<SetOf<CapabilityDescriptor>>,
        ) -> Self {
            Self {
                sequence_number,
                protocol_identifier,
                multiplex_capability,
                capability_table,
                capability_descriptors,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalCapabilitySetAck {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
    }
    impl TerminalCapabilitySetAck {
        pub fn new(sequence_number: SequenceNumber) -> Self {
            Self { sequence_number }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum TerminalCapabilitySetRejectCauseTableEntryCapacityExceeded {
        highestEntryNumberProcessed(CapabilityTableEntryNumber),
        noneProcessed(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TerminalCapabilitySetRejectCause {
        unspecified(()),
        undefinedTableEntryUsed(()),
        descriptorCapacityExceeded(()),
        tableEntryCapacityExceeded(TerminalCapabilitySetRejectCauseTableEntryCapacityExceeded),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalCapabilitySetReject {
        #[rasn(identifier = "sequenceNumber")]
        pub sequence_number: SequenceNumber,
        pub cause: TerminalCapabilitySetRejectCause,
    }
    impl TerminalCapabilitySetReject {
        pub fn new(
            sequence_number: SequenceNumber,
            cause: TerminalCapabilitySetRejectCause,
        ) -> Self {
            Self {
                sequence_number,
                cause,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalCapabilitySetRelease {}
    impl TerminalCapabilitySetRelease {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl std::default::Default for TerminalCapabilitySetRelease {
        fn default() -> Self {
            Self {}
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=128"))]
    pub struct TerminalID(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalInformation {
        #[rasn(identifier = "terminalLabel")]
        pub terminal_label: TerminalLabel,
        #[rasn(identifier = "terminalID")]
        pub terminal_id: TerminalID,
    }
    impl TerminalInformation {
        pub fn new(terminal_label: TerminalLabel, terminal_id: TerminalID) -> Self {
            Self {
                terminal_label,
                terminal_id,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalLabel {
        #[rasn(identifier = "mcuNumber")]
        pub mcu_number: McuNumber,
        #[rasn(identifier = "terminalNumber")]
        pub terminal_number: TerminalNumber,
    }
    impl TerminalLabel {
        pub fn new(mcu_number: McuNumber, terminal_number: TerminalNumber) -> Self {
            Self {
                mcu_number,
                terminal_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=192"))]
    pub struct TerminalNumber(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalYouAreSeeingInSubPictureNumber {
        #[rasn(identifier = "terminalNumber")]
        pub terminal_number: TerminalNumber,
        #[rasn(value("0..=255"), identifier = "subPictureNumber")]
        pub sub_picture_number: u8,
    }
    impl TerminalYouAreSeeingInSubPictureNumber {
        pub fn new(terminal_number: TerminalNumber, sub_picture_number: u8) -> Self {
            Self {
                terminal_number,
                sub_picture_number,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TransparencyParameters {
        #[rasn(value("1..=256"), identifier = "presentationOrder")]
        pub presentation_order: u16,
        #[rasn(value("-262144..=262143"), identifier = "offset-x")]
        pub offset_x: i32,
        #[rasn(value("-262144..=262143"), identifier = "offset-y")]
        pub offset_y: i32,
        #[rasn(value("1..=255"), identifier = "scale-x")]
        pub scale_x: u8,
        #[rasn(value("1..=255"), identifier = "scale-y")]
        pub scale_y: u8,
    }
    impl TransparencyParameters {
        pub fn new(
            presentation_order: u16,
            offset_x: i32,
            offset_y: i32,
            scale_x: u8,
            scale_y: u8,
        ) -> Self {
            Self {
                presentation_order,
                offset_x,
                offset_y,
                scale_x,
                scale_y,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TransportAddress {
        unicastAddress(UnicastAddress),
        multicastAddress(MulticastAddress),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TransportCapability {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<NonStandardParameter>,
        #[rasn(size("1..=256"), identifier = "qOSCapabilities")]
        pub q_oscapabilities: Option<SequenceOf<QOSCapability>>,
        #[rasn(size("1..=256"), identifier = "mediaChannelCapabilities")]
        pub media_channel_capabilities: Option<SequenceOf<MediaChannelCapability>>,
    }
    impl TransportCapability {
        pub fn new(
            non_standard: Option<NonStandardParameter>,
            q_oscapabilities: Option<SequenceOf<QOSCapability>>,
            media_channel_capabilities: Option<SequenceOf<MediaChannelCapability>>,
        ) -> Self {
            Self {
                non_standard,
                q_oscapabilities,
                media_channel_capabilities,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnicastAddressIPAddress {
        #[rasn(size("4"))]
        pub network: OctetString,
        #[rasn(value("0..=65535"), identifier = "tsapIdentifier")]
        pub tsap_identifier: u16,
    }
    impl UnicastAddressIPAddress {
        pub fn new(network: OctetString, tsap_identifier: u16) -> Self {
            Self {
                network,
                tsap_identifier,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnicastAddressIPXAddress {
        #[rasn(size("6"))]
        pub node: OctetString,
        #[rasn(size("4"))]
        pub netnum: OctetString,
        #[rasn(size("2"), identifier = "tsapIdentifier")]
        pub tsap_identifier: OctetString,
    }
    impl UnicastAddressIPXAddress {
        pub fn new(node: OctetString, netnum: OctetString, tsap_identifier: OctetString) -> Self {
            Self {
                node,
                netnum,
                tsap_identifier,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnicastAddressIP6Address {
        #[rasn(size("16"))]
        pub network: OctetString,
        #[rasn(value("0..=65535"), identifier = "tsapIdentifier")]
        pub tsap_identifier: u16,
    }
    impl UnicastAddressIP6Address {
        pub fn new(network: OctetString, tsap_identifier: u16) -> Self {
            Self {
                network,
                tsap_identifier,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum UnicastAddressIPSourceRouteAddressRouting {
        strict(()),
        loose(()),
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "OCTET_STRING")]
    pub struct AnonymousUnicastAddressIPSourceRouteAddressRoute(pub FixedOctetString<4usize>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct UnicastAddressIPSourceRouteAddressRoute(
        pub SequenceOf<AnonymousUnicastAddressIPSourceRouteAddressRoute>,
    );
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnicastAddressIPSourceRouteAddress {
        pub routing: UnicastAddressIPSourceRouteAddressRouting,
        #[rasn(size("4"))]
        pub network: OctetString,
        #[rasn(value("0..=65535"), identifier = "tsapIdentifier")]
        pub tsap_identifier: u16,
        pub route: UnicastAddressIPSourceRouteAddressRoute,
    }
    impl UnicastAddressIPSourceRouteAddress {
        pub fn new(
            routing: UnicastAddressIPSourceRouteAddressRouting,
            network: OctetString,
            tsap_identifier: u16,
            route: UnicastAddressIPSourceRouteAddressRoute,
        ) -> Self {
            Self {
                routing,
                network,
                tsap_identifier,
                route,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UnicastAddress {
        iPAddress(UnicastAddressIPAddress),
        iPXAddress(UnicastAddressIPXAddress),
        iP6Address(UnicastAddressIP6Address),
        #[rasn(size("16"))]
        netBios(OctetString),
        iPSourceRouteAddress(UnicastAddressIPSourceRouteAddress),
        #[rasn(extension_addition, size("1..=20"))]
        nsap(OctetString),
        #[rasn(extension_addition)]
        nonStandardAddress(NonStandardParameter),
    }
    #[doc = " ================================================================================"]
    #[doc = " Capability Exchange Definitions: UserInput"]
    #[doc = " ================================================================================"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UserInputCapability {
        #[rasn(size("1..=16"))]
        nonStandard(SequenceOf<NonStandardParameter>),
        basicString(()),
        iA5String(()),
        generalString(()),
        dtmf(()),
        hookflash(()),
        #[rasn(extension_addition)]
        extendedAlphanumeric(()),
        #[rasn(extension_addition)]
        encryptedBasicString(()),
        #[rasn(extension_addition)]
        encryptedIA5String(()),
        #[rasn(extension_addition)]
        encryptedGeneralString(()),
        #[rasn(extension_addition)]
        secureDTMF(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UserInputIndicationUserInputSupportIndication {
        nonStandard(NonStandardParameter),
        basicString(()),
        iA5String(()),
        generalString(()),
        #[rasn(extension_addition)]
        encryptedBasicString(()),
        #[rasn(extension_addition)]
        encryptedIA5String(()),
        #[rasn(extension_addition)]
        encryptedGeneralString(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UserInputIndicationSignalRtp {
        #[rasn(value("0..=4294967295"))]
        pub timestamp: Option<u32>,
        #[rasn(value("0..=4294967295"), identifier = "expirationTime")]
        pub expiration_time: Option<u32>,
        #[rasn(identifier = "logicalChannelNumber")]
        pub logical_channel_number: LogicalChannelNumber,
    }
    impl UserInputIndicationSignalRtp {
        pub fn new(
            timestamp: Option<u32>,
            expiration_time: Option<u32>,
            logical_channel_number: LogicalChannelNumber,
        ) -> Self {
            Self {
                timestamp,
                expiration_time,
                logical_channel_number,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UserInputIndicationSignal {
        #[rasn(
            size("1"),
            from(
                "\u{21}", "\u{23}", "\u{2a}", "\u{30}", "\u{31}", "\u{32}", "\u{33}", "\u{34}",
                "\u{35}", "\u{36}", "\u{37}", "\u{38}", "\u{39}", "\u{41}", "\u{42}", "\u{43}",
                "\u{44}"
            ),
            identifier = "signalType"
        )]
        pub signal_type: Ia5String,
        #[rasn(value("1..=65535"))]
        pub duration: Option<u16>,
        pub rtp: Option<UserInputIndicationSignalRtp>,
        #[rasn(extension_addition, identifier = "rtpPayloadIndication")]
        pub rtp_payload_indication: Option<()>,
        #[rasn(extension_addition, identifier = "paramS")]
        pub param_s: Option<Params>,
        #[rasn(extension_addition, size("1"), identifier = "encryptedSignalType")]
        pub encrypted_signal_type: Option<OctetString>,
    }
    impl UserInputIndicationSignal {
        pub fn new(
            signal_type: Ia5String,
            duration: Option<u16>,
            rtp: Option<UserInputIndicationSignalRtp>,
            rtp_payload_indication: Option<()>,
            param_s: Option<Params>,
            encrypted_signal_type: Option<OctetString>,
        ) -> Self {
            Self {
                signal_type,
                duration,
                rtp,
                rtp_payload_indication,
                param_s,
                encrypted_signal_type,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UserInputIndicationSignalUpdateRtp {
        #[rasn(identifier = "logicalChannelNumber")]
        pub logical_channel_number: LogicalChannelNumber,
    }
    impl UserInputIndicationSignalUpdateRtp {
        pub fn new(logical_channel_number: LogicalChannelNumber) -> Self {
            Self {
                logical_channel_number,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UserInputIndicationSignalUpdate {
        #[rasn(value("1..=65535"))]
        pub duration: u16,
        pub rtp: Option<UserInputIndicationSignalUpdateRtp>,
    }
    impl UserInputIndicationSignalUpdate {
        pub fn new(duration: u16, rtp: Option<UserInputIndicationSignalUpdateRtp>) -> Self {
            Self { duration, rtp }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UserInputIndicationExtendedAlphanumericEncryptedAlphanumeric {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: Option<Params>,
        pub encrypted: OctetString,
    }
    impl UserInputIndicationExtendedAlphanumericEncryptedAlphanumeric {
        pub fn new(
            algorithm_oid: ObjectIdentifier,
            param_s: Option<Params>,
            encrypted: OctetString,
        ) -> Self {
            Self {
                algorithm_oid,
                param_s,
                encrypted,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UserInputIndicationExtendedAlphanumeric {
        pub alphanumeric: GeneralString,
        #[rasn(identifier = "rtpPayloadIndication")]
        pub rtp_payload_indication: Option<()>,
        #[rasn(extension_addition, identifier = "encryptedAlphanumeric")]
        pub encrypted_alphanumeric:
            Option<UserInputIndicationExtendedAlphanumericEncryptedAlphanumeric>,
    }
    impl UserInputIndicationExtendedAlphanumeric {
        pub fn new(
            alphanumeric: GeneralString,
            rtp_payload_indication: Option<()>,
            encrypted_alphanumeric: Option<
                UserInputIndicationExtendedAlphanumericEncryptedAlphanumeric,
            >,
        ) -> Self {
            Self {
                alphanumeric,
                rtp_payload_indication,
                encrypted_alphanumeric,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UserInputIndicationEncryptedAlphanumeric {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        #[rasn(identifier = "paramS")]
        pub param_s: Option<Params>,
        pub encrypted: OctetString,
    }
    impl UserInputIndicationEncryptedAlphanumeric {
        pub fn new(
            algorithm_oid: ObjectIdentifier,
            param_s: Option<Params>,
            encrypted: OctetString,
        ) -> Self {
            Self {
                algorithm_oid,
                param_s,
                encrypted,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UserInputIndication {
        nonStandard(NonStandardParameter),
        alphanumeric(GeneralString),
        #[rasn(extension_addition)]
        userInputSupportIndication(UserInputIndicationUserInputSupportIndication),
        #[rasn(extension_addition)]
        signal(UserInputIndicationSignal),
        #[rasn(extension_addition)]
        signalUpdate(UserInputIndicationSignalUpdate),
        #[rasn(extension_addition)]
        extendedAlphanumeric(UserInputIndicationExtendedAlphanumeric),
        #[rasn(extension_addition)]
        encryptedAlphanumeric(UserInputIndicationEncryptedAlphanumeric),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct V42bis {
        #[rasn(value("1..=65536"), identifier = "numberOfCodewords")]
        pub number_of_codewords: u32,
        #[rasn(value("1..=256"), identifier = "maximumStringLength")]
        pub maximum_string_length: u16,
    }
    impl V42bis {
        pub fn new(number_of_codewords: u32, maximum_string_length: u16) -> Self {
            Self {
                number_of_codewords,
                maximum_string_length,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct V75Capability {
        #[rasn(identifier = "audioHeader")]
        pub audio_header: bool,
    }
    impl V75Capability {
        pub fn new(audio_header: bool) -> Self {
            Self { audio_header }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct V75Parameters {
        #[rasn(identifier = "audioHeaderPresent")]
        pub audio_header_present: bool,
    }
    impl V75Parameters {
        pub fn new(audio_header_present: bool) -> Self {
            Self {
                audio_header_present,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct V76Capability {
        #[rasn(identifier = "suspendResumeCapabilitywAddress")]
        pub suspend_resume_capabilityw_address: bool,
        #[rasn(identifier = "suspendResumeCapabilitywoAddress")]
        pub suspend_resume_capabilitywo_address: bool,
        #[rasn(identifier = "rejCapability")]
        pub rej_capability: bool,
        #[rasn(identifier = "sREJCapability")]
        pub s_rejcapability: bool,
        #[rasn(identifier = "mREJCapability")]
        pub m_rejcapability: bool,
        #[rasn(identifier = "crc8bitCapability")]
        pub crc8bit_capability: bool,
        #[rasn(identifier = "crc16bitCapability")]
        pub crc16bit_capability: bool,
        #[rasn(identifier = "crc32bitCapability")]
        pub crc32bit_capability: bool,
        #[rasn(identifier = "uihCapability")]
        pub uih_capability: bool,
        #[rasn(value("2..=8191"), identifier = "numOfDLCS")]
        pub num_of_dlcs: u16,
        #[rasn(identifier = "twoOctetAddressFieldCapability")]
        pub two_octet_address_field_capability: bool,
        #[rasn(identifier = "loopBackTestCapability")]
        pub loop_back_test_capability: bool,
        #[rasn(value("1..=4095"), identifier = "n401Capability")]
        pub n401_capability: u16,
        #[rasn(value("1..=127"), identifier = "maxWindowSizeCapability")]
        pub max_window_size_capability: u8,
        #[rasn(identifier = "v75Capability")]
        pub v75_capability: V75Capability,
    }
    impl V76Capability {
        pub fn new(
            suspend_resume_capabilityw_address: bool,
            suspend_resume_capabilitywo_address: bool,
            rej_capability: bool,
            s_rejcapability: bool,
            m_rejcapability: bool,
            crc8bit_capability: bool,
            crc16bit_capability: bool,
            crc32bit_capability: bool,
            uih_capability: bool,
            num_of_dlcs: u16,
            two_octet_address_field_capability: bool,
            loop_back_test_capability: bool,
            n401_capability: u16,
            max_window_size_capability: u8,
            v75_capability: V75Capability,
        ) -> Self {
            Self {
                suspend_resume_capabilityw_address,
                suspend_resume_capabilitywo_address,
                rej_capability,
                s_rejcapability,
                m_rejcapability,
                crc8bit_capability,
                crc16bit_capability,
                crc32bit_capability,
                uih_capability,
                num_of_dlcs,
                two_octet_address_field_capability,
                loop_back_test_capability,
                n401_capability,
                max_window_size_capability,
                v75_capability,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct V76HDLCParameters {
        #[rasn(identifier = "crcLength")]
        pub crc_length: CRCLength,
        #[rasn(value("1..=4095"))]
        pub n401: u16,
        #[rasn(identifier = "loopbackTestProcedure")]
        pub loopback_test_procedure: bool,
    }
    impl V76HDLCParameters {
        pub fn new(crc_length: CRCLength, n401: u16, loopback_test_procedure: bool) -> Self {
            Self {
                crc_length,
                n401,
                loopback_test_procedure,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum V76LogicalChannelParametersSuspendResume {
        noSuspendResume(()),
        suspendResumewAddress(()),
        suspendResumewoAddress(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum V76LogicalChannelParametersModeERMRecovery {
        rej(()),
        sREJ(()),
        mSREJ(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct V76LogicalChannelParametersModeERM {
        #[rasn(value("1..=127"), identifier = "windowSize")]
        pub window_size: u8,
        pub recovery: V76LogicalChannelParametersModeERMRecovery,
    }
    impl V76LogicalChannelParametersModeERM {
        pub fn new(window_size: u8, recovery: V76LogicalChannelParametersModeERMRecovery) -> Self {
            Self {
                window_size,
                recovery,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum V76LogicalChannelParametersMode {
        eRM(V76LogicalChannelParametersModeERM),
        uNERM(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct V76LogicalChannelParameters {
        #[rasn(identifier = "hdlcParameters")]
        pub hdlc_parameters: V76HDLCParameters,
        #[rasn(identifier = "suspendResume")]
        pub suspend_resume: V76LogicalChannelParametersSuspendResume,
        #[rasn(identifier = "uIH")]
        pub u_ih: bool,
        pub mode: V76LogicalChannelParametersMode,
        #[rasn(identifier = "v75Parameters")]
        pub v75_parameters: V75Parameters,
    }
    impl V76LogicalChannelParameters {
        pub fn new(
            hdlc_parameters: V76HDLCParameters,
            suspend_resume: V76LogicalChannelParametersSuspendResume,
            u_ih: bool,
            mode: V76LogicalChannelParametersMode,
            v75_parameters: V75Parameters,
        ) -> Self {
            Self {
                hdlc_parameters,
                suspend_resume,
                u_ih,
                mode,
                v75_parameters,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum V76ModeParameters {
        suspendResumewAddress(()),
        suspendResumewoAddress(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VBDCapability {
        #[rasn(identifier = "type")]
        pub r_type: Box<AudioCapability>,
    }
    impl VBDCapability {
        pub fn new(r_type: Box<AudioCapability>) -> Self {
            Self { r_type }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VBDMode {
        #[rasn(identifier = "type")]
        pub r_type: Box<AudioMode>,
    }
    impl VBDMode {
        pub fn new(r_type: Box<AudioMode>) -> Self {
            Self { r_type }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VCCapabilityAal1 {
        #[rasn(identifier = "nullClockRecovery")]
        pub null_clock_recovery: bool,
        #[rasn(identifier = "srtsClockRecovery")]
        pub srts_clock_recovery: bool,
        #[rasn(identifier = "adaptiveClockRecovery")]
        pub adaptive_clock_recovery: bool,
        #[rasn(identifier = "nullErrorCorrection")]
        pub null_error_correction: bool,
        #[rasn(identifier = "longInterleaver")]
        pub long_interleaver: bool,
        #[rasn(identifier = "shortInterleaver")]
        pub short_interleaver: bool,
        #[rasn(identifier = "errorCorrectionOnly")]
        pub error_correction_only: bool,
        #[rasn(identifier = "structuredDataTransfer")]
        pub structured_data_transfer: bool,
        #[rasn(identifier = "partiallyFilledCells")]
        pub partially_filled_cells: bool,
    }
    impl VCCapabilityAal1 {
        pub fn new(
            null_clock_recovery: bool,
            srts_clock_recovery: bool,
            adaptive_clock_recovery: bool,
            null_error_correction: bool,
            long_interleaver: bool,
            short_interleaver: bool,
            error_correction_only: bool,
            structured_data_transfer: bool,
            partially_filled_cells: bool,
        ) -> Self {
            Self {
                null_clock_recovery,
                srts_clock_recovery,
                adaptive_clock_recovery,
                null_error_correction,
                long_interleaver,
                short_interleaver,
                error_correction_only,
                structured_data_transfer,
                partially_filled_cells,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VCCapabilityAal5 {
        #[rasn(value("0..=65535"), identifier = "forwardMaximumSDUSize")]
        pub forward_maximum_sdusize: u16,
        #[rasn(value("0..=65535"), identifier = "backwardMaximumSDUSize")]
        pub backward_maximum_sdusize: u16,
    }
    impl VCCapabilityAal5 {
        pub fn new(forward_maximum_sdusize: u16, backward_maximum_sdusize: u16) -> Self {
            Self {
                forward_maximum_sdusize,
                backward_maximum_sdusize,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct VCCapabilityAvailableBitRatesTypeRangeOfBitRates {
        #[rasn(value("1..=65535"), identifier = "lowerBitRate")]
        pub lower_bit_rate: u16,
        #[rasn(value("1..=65535"), identifier = "higherBitRate")]
        pub higher_bit_rate: u16,
    }
    impl VCCapabilityAvailableBitRatesTypeRangeOfBitRates {
        pub fn new(lower_bit_rate: u16, higher_bit_rate: u16) -> Self {
            Self {
                lower_bit_rate,
                higher_bit_rate,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    pub enum VCCapabilityAvailableBitRatesType {
        #[rasn(value("1..=65535"))]
        singleBitRate(u16),
        rangeOfBitRates(VCCapabilityAvailableBitRatesTypeRangeOfBitRates),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VCCapabilityAvailableBitRates {
        #[rasn(identifier = "type")]
        pub r_type: VCCapabilityAvailableBitRatesType,
    }
    impl VCCapabilityAvailableBitRates {
        pub fn new(r_type: VCCapabilityAvailableBitRatesType) -> Self {
            Self { r_type }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VCCapabilityAal1ViaGateway {
        #[rasn(size("1..=256"), identifier = "gatewayAddress")]
        pub gateway_address: SetOf<Q2931Address>,
        #[rasn(identifier = "nullClockRecovery")]
        pub null_clock_recovery: bool,
        #[rasn(identifier = "srtsClockRecovery")]
        pub srts_clock_recovery: bool,
        #[rasn(identifier = "adaptiveClockRecovery")]
        pub adaptive_clock_recovery: bool,
        #[rasn(identifier = "nullErrorCorrection")]
        pub null_error_correction: bool,
        #[rasn(identifier = "longInterleaver")]
        pub long_interleaver: bool,
        #[rasn(identifier = "shortInterleaver")]
        pub short_interleaver: bool,
        #[rasn(identifier = "errorCorrectionOnly")]
        pub error_correction_only: bool,
        #[rasn(identifier = "structuredDataTransfer")]
        pub structured_data_transfer: bool,
        #[rasn(identifier = "partiallyFilledCells")]
        pub partially_filled_cells: bool,
    }
    impl VCCapabilityAal1ViaGateway {
        pub fn new(
            gateway_address: SetOf<Q2931Address>,
            null_clock_recovery: bool,
            srts_clock_recovery: bool,
            adaptive_clock_recovery: bool,
            null_error_correction: bool,
            long_interleaver: bool,
            short_interleaver: bool,
            error_correction_only: bool,
            structured_data_transfer: bool,
            partially_filled_cells: bool,
        ) -> Self {
            Self {
                gateway_address,
                null_clock_recovery,
                srts_clock_recovery,
                adaptive_clock_recovery,
                null_error_correction,
                long_interleaver,
                short_interleaver,
                error_correction_only,
                structured_data_transfer,
                partially_filled_cells,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VCCapability {
        pub aal1: Option<VCCapabilityAal1>,
        pub aal5: Option<VCCapabilityAal5>,
        #[rasn(identifier = "transportStream")]
        pub transport_stream: bool,
        #[rasn(identifier = "programStream")]
        pub program_stream: bool,
        #[rasn(identifier = "availableBitRates")]
        pub available_bit_rates: VCCapabilityAvailableBitRates,
        #[rasn(extension_addition, identifier = "aal1ViaGateway")]
        pub aal1_via_gateway: Option<VCCapabilityAal1ViaGateway>,
    }
    impl VCCapability {
        pub fn new(
            aal1: Option<VCCapabilityAal1>,
            aal5: Option<VCCapabilityAal5>,
            transport_stream: bool,
            program_stream: bool,
            available_bit_rates: VCCapabilityAvailableBitRates,
            aal1_via_gateway: Option<VCCapabilityAal1ViaGateway>,
        ) -> Self {
            Self {
                aal1,
                aal5,
                transport_stream,
                program_stream,
                available_bit_rates,
                aal1_via_gateway,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Indication Message : Vendor Identification"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VendorIdentification {
        pub vendor: NonStandardIdentifier,
        #[rasn(size("1..=256"), identifier = "productNumber")]
        pub product_number: Option<OctetString>,
        #[rasn(size("1..=256"), identifier = "versionNumber")]
        pub version_number: Option<OctetString>,
    }
    impl VendorIdentification {
        pub fn new(
            vendor: NonStandardIdentifier,
            product_number: Option<OctetString>,
            version_number: Option<OctetString>,
        ) -> Self {
            Self {
                vendor,
                product_number,
                version_number,
            }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Capability exchange definitions: Video capabilities"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum VideoCapability {
        nonStandard(NonStandardParameter),
        h261VideoCapability(H261VideoCapability),
        h262VideoCapability(H262VideoCapability),
        h263VideoCapability(H263VideoCapability),
        is11172VideoCapability(IS11172VideoCapability),
        #[rasn(extension_addition)]
        genericVideoCapability(GenericCapability),
        #[rasn(extension_addition)]
        extendedVideoCapability(ExtendedVideoCapability),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VideoIndicateCompose {
        #[rasn(value("0..=255"), identifier = "compositionNumber")]
        pub composition_number: u8,
    }
    impl VideoIndicateCompose {
        pub fn new(composition_number: u8) -> Self {
            Self { composition_number }
        }
    }
    #[doc = " ==================================================================================="]
    #[doc = " Request mode definitions: Video modes"]
    #[doc = " ==================================================================================="]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum VideoMode {
        nonStandard(NonStandardParameter),
        h261VideoMode(H261VideoMode),
        h262VideoMode(H262VideoMode),
        h263VideoMode(H263VideoMode),
        is11172VideoMode(IS11172VideoMode),
        #[rasn(extension_addition)]
        genericVideoMode(GenericCapability),
    }
}
