---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x1085_2016_XBHSM.asn1
---
Warnings:
LinkerError in ASN grammar: No syntax definition for information object class found!
LinkerError in ASN grammar: No syntax definition for information object class found!
LinkerError in ASN grammar: Failed to resolve supertype AlgorithmIdentifier of parameterized implementation.
LinkerError in ASN grammar: Failed to resolve supertype AlgorithmIdentifier of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod xbhsm {
    extern crate alloc;
    use super::authentication_framework::*;
    use super::useful_definitions::AUTHENTICATION_FRAMEWORK;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct DataSetForEncryptedPSID {
        #[rasn(default = "data_set_for_encrypted_psid_version_default")]
        pub version: Integer,
        #[rasn(identifier = "psidEncAlg")]
        pub psid_enc_alg: PSIDEncryptionAlgorithm,
        #[rasn(identifier = "encryptedPsid")]
        pub encrypted_psid: EncryptedPsid,
    }
    impl DataSetForEncryptedPSID {
        pub fn new(
            version: Integer,
            psid_enc_alg: PSIDEncryptionAlgorithm,
            encrypted_psid: EncryptedPsid,
        ) -> Self {
            Self {
                version,
                psid_enc_alg,
                encrypted_psid,
            }
        }
    }
    fn data_set_for_encrypted_psid_version_default() -> Integer {
        Integer::from(0i128)
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EncryptedPsid(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct HashAlgorithm(pub AlgorithmIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct HashContent {
        #[rasn(identifier = "bR")]
        pub b_r: PrintableString,
        #[rasn(identifier = "randomNum")]
        pub random_num: BitString,
    }
    impl HashContent {
        pub fn new(b_r: PrintableString, random_num: BitString) -> Self {
            Self { b_r, random_num }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "InstanceOfBHSM-PID")]
    pub struct InstanceOfBHSMPID(pub BHSMPSID);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct PSID {
        #[rasn(identifier = "hashAlg")]
        pub hash_alg: HashAlgorithm,
        #[rasn(identifier = "hashContent")]
        pub hash_content: HashContent,
    }
    impl PSID {
        pub fn new(hash_alg: HashAlgorithm, hash_content: HashContent) -> Self {
            Self {
                hash_alg,
                hash_content,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PSIDEncryptionAlgorithm(pub AlgorithmIdentifier);
    pub static BHSMPSID: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[1u32, 0u32, 17922u32, 2u32, 1u32]).to_owned());
}
