---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_q_q1228_1997_IN-CS2-datatypes.asn1
---
Warnings:
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMessageContentLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMessageContentLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxAmount
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minUSIServiceIndicatorLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minUSIInformationLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minScfIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minScfIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minGenericNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minServiceInteractionIndicatorsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minScfIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minScfAddressLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minSFBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minSCIBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minRouteListLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minRequestedUTSINum
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minUSIServiceIndicatorLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minRedirectingPartyIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minReceivedInformationLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minReasonLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minOriginalCalledPartyIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxCauseLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMidCallControlInfoNum
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMessageContentLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMailBoxIDLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMessageContentLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxRecordingTime
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMessageContentLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMessageContentLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minIPSSPCapabilitiesLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minIPAvailableLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.numOfInServiceCompatibilityIndLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.numOfGenericNumbers
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minGenericNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minGenericNameLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMessageContentLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minForwardGVNSLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minSFBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minFCIBillingChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minEventTypeChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minEventSpecificInformationChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMidCallControlInfoNum
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxBearerCapabilityLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDisplayInformationLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxAmount
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxAmount
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxUnitsPerInterval
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minEventTypeChargingLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxCauseLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCallingPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCallingPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.numOfCSs
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCallResultLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCallingPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minCalledPartyNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.numOfCSAs
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.maxBearerCapabilityLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minBackwardGVNSLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minMidCallControlInfoNum
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minDigitsLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minLocationNumberLength
NotYetInplemented in ASN grammar: Value references of path length > 2 are not yet supported! Found reference bound.&.minAChBillingChargingLength


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod in_cs2_datatypes {
    extern crate alloc;
    use super::in_cs2_classes::*;
    use super::in_cs2_object_identifiers::{CLASSES, TC_MESSAGES};
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " An access code from a business group dialling plan attendant access codes, access codes to escape"]
    #[doc = " to the public network, access code to access a private facility/network, and feature access codes."]
    #[doc = " Uses the LocationNumber format which is based on the Q.763 Location Number format."]
    #[doc = " The Nature of Address indicator field shall be set to \"Spare\" (value 00000000)."]
    #[doc = " The Numbering Plan Indicator field shall be set to \"Spare\" (value 000)."]
    #[doc = " Of local significance."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=151"))]
    pub struct AccountNumber(pub NumericString);
    #[doc = " The AChBillingChargingCharacteristics parameter specifies the charging related information"]
    #[doc = " to be provided by the SSF and the conditions on which this information has to be reported"]
    #[doc = " back to the SCF with the ApplyChargingReport operation."]
    #[doc = " Examples of charging related information to be provided by the SSF may be: bulk counter"]
    #[doc = " values, costs, tariff change and time of charge, time stamps, durations, etc."]
    #[doc = " Examples of conditions on which the charging related information are to be reported may be:"]
    #[doc = " threshold value reached, timer expiration, tariff change, end of connection configuration, etc."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ActionIndicator {
        activate = 1,
        deactivate = 2,
        retrieve = 3,
    }
    #[doc = " indicates the action to be performed by the ManageTriggerData operation (activate, deactivate"]
    #[doc = " or retrieve the status of a TDP."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ActionPerformed {
        activated = 1,
        deactivated = 2,
        alreadyActive = 3,
        alreadyInactive = 4,
        isActive = 5,
        isInactive = 6,
    }
    #[doc = " indicates the result of the operation ManageTriggerData"]
    #[doc = " activated: response of activate TDP"]
    #[doc = " deactivated: response of deactivate TDP"]
    #[doc = " alreadyActive: response of activate TDP"]
    #[doc = " alreadyInactive: response of deactivate TDP"]
    #[doc = " isActive: response of retrieve status of TDP"]
    #[doc = " isInactive: response of retrieve status of TDP"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ActivableServices(pub BitString);
    #[doc = " Indicates the Additional Calling Party Number. Refer to Rec. Q.763 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AlertingPattern(pub FixedOctetString<3usize>);
    #[doc = " Indicates a specific pattern that is used to alert a subscriber (e.g. distinctive ringing, tones, etc.)."]
    #[doc = " Only applies if SSF is the terminating local exchange for the subscriber. Refer to the Q.931"]
    #[doc = " Signal parameter for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=2047"))]
    pub struct ApplicationTimer(pub u16);
    #[doc = " Indicates the BCSM Event information for monitoring."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct BCUSMEvent {
        #[rasn(tag(context, 0), identifier = "eventType")]
        pub event_type: EventTypeBCUSM,
        #[rasn(tag(context, 1), identifier = "monitorMode")]
        pub monitor_mode: MonitorMode,
    }
    impl BCUSMEvent {
        pub fn new(event_type: EventTypeBCUSM, monitor_mode: MonitorMode) -> Self {
            Self {
                event_type,
                monitor_mode,
            }
        }
    }
    #[doc = " Indicates the GVNS Backward information. Refer to clause 6/Q.735 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct BackwardServiceInteractionInd {
        #[rasn(
            size("1"),
            tag(context, 1),
            identifier = "conferenceTreatmentIndicator"
        )]
        pub conference_treatment_indicator: Option<OctetString>,
        #[rasn(
            size("1"),
            tag(context, 2),
            identifier = "callCompletionTreatmentIndicator"
        )]
        pub call_completion_treatment_indicator: Option<OctetString>,
    }
    impl BackwardServiceInteractionInd {
        pub fn new(
            conference_treatment_indicator: Option<OctetString>,
            call_completion_treatment_indicator: Option<OctetString>,
        ) -> Self {
            Self {
                conference_treatment_indicator,
                call_completion_treatment_indicator,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct BearerCapabilities(pub BitString);
    #[doc = " Indicates the type of bearer capability connection to the user. For bearerCapability, either"]
    #[doc = " DSS 1 (Rec. Q.931) or the ISUP User Service Information (Rec. Q.763) encoding can be used. Refer"]
    #[doc = " to the Q.763 Transmission Medium Requirement parameter for tmr encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum BothwayThroughConnectionInd {
        bothwayPathRequired = 0,
        bothwayPathNotRequired = 1,
    }
    #[doc = "type extracted from Cause parameter in Rec. Q.763."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CGEncountered {
        noCGencountered = 0,
        manualCGencountered = 1,
        scpOverload = 2,
    }
    #[doc = " Indicates the Called Party Subaddress. Refer to Rec. Q.931 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=2147483647"))]
    pub struct CallIdentifier(pub u32);
    #[doc = " Indicates the type of calling party (e.g. operator, payphone, ordinary subscriber). Refer to Rec. Q.763"]
    #[doc = " for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CallProcessingOperationCorrelationID {
        aLERTing = 1,
        sETUP = 5,
        cONNect = 7,
        dISConnect = 69,
        rELease = 77,
        rELeaseCOMPlete = 90,
        fACility = 98,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CalledPartyBusinessGroupID(pub OctetString);
    #[doc = " Indicates the Called Party Number. Refer to Rec. Q.763 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CalledPartySubaddress(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallingPartyBusinessGroupID(pub OctetString);
    #[doc = " Indicates the Calling Party Number. Refer to Rec. Q.763 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallingPartySubaddress(pub OctetString);
    #[doc = " Indicates the Calling Party Subaddress. Refer to Rec. Q.931 for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CallingPartysCategory(pub FixedOctetString<1usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Carrier(pub OctetString);
    #[doc = " Indicates the cause for interface related information. Refer to the Q.763 Cause parameter for encoding."]
    #[doc = " For the use of cause and location values, refer to Rec. Q.850"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CauseValue(pub FixedOctetString<1usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CollectedDigits {
        #[rasn(
            value("1..=127"),
            tag(context, 0),
            default = "collected_digits_minimum_nb_of_digits_default",
            identifier = "minimumNbOfDigits"
        )]
        pub minimum_nb_of_digits: u8,
        #[rasn(value("1..=127"), tag(context, 1), identifier = "maximumNbOfDigits")]
        pub maximum_nb_of_digits: u8,
        #[rasn(size("1..=2"), tag(context, 2), identifier = "endOfReplyDigit")]
        pub end_of_reply_digit: Option<OctetString>,
        #[rasn(size("1..=2"), tag(context, 3), identifier = "cancelDigit")]
        pub cancel_digit: Option<OctetString>,
        #[rasn(size("1..=2"), tag(context, 4), identifier = "startDigit")]
        pub start_digit: Option<OctetString>,
        #[rasn(value("1..=127"), tag(context, 5), identifier = "firstDigitTimeOut")]
        pub first_digit_time_out: Option<u8>,
        #[rasn(value("1..=127"), tag(context, 6), identifier = "interDigitTimeOut")]
        pub inter_digit_time_out: Option<u8>,
        #[rasn(
            tag(context, 7),
            default = "collected_digits_error_treatment_default",
            identifier = "errorTreatment"
        )]
        pub error_treatment: ErrorTreatment,
        #[rasn(
            tag(context, 8),
            default = "collected_digits_interruptable_ann_ind_default",
            identifier = "interruptableAnnInd"
        )]
        pub interruptable_ann_ind: bool,
        #[rasn(
            tag(context, 9),
            default = "collected_digits_voice_information_default",
            identifier = "voiceInformation"
        )]
        pub voice_information: bool,
        #[rasn(
            tag(context, 10),
            default = "collected_digits_voice_back_default",
            identifier = "voiceBack"
        )]
        pub voice_back: bool,
    }
    impl CollectedDigits {
        pub fn new(
            minimum_nb_of_digits: u8,
            maximum_nb_of_digits: u8,
            end_of_reply_digit: Option<OctetString>,
            cancel_digit: Option<OctetString>,
            start_digit: Option<OctetString>,
            first_digit_time_out: Option<u8>,
            inter_digit_time_out: Option<u8>,
            error_treatment: ErrorTreatment,
            interruptable_ann_ind: bool,
            voice_information: bool,
            voice_back: bool,
        ) -> Self {
            Self {
                minimum_nb_of_digits,
                maximum_nb_of_digits,
                end_of_reply_digit,
                cancel_digit,
                start_digit,
                first_digit_time_out,
                inter_digit_time_out,
                error_treatment,
                interruptable_ann_ind,
                voice_information,
                voice_back,
            }
        }
    }
    fn collected_digits_minimum_nb_of_digits_default() -> u8 {
        1
    }
    fn collected_digits_error_treatment_default() -> ErrorTreatment {
        ErrorTreatment::reportErrorToScf
    }
    fn collected_digits_interruptable_ann_ind_default() -> bool {
        true
    }
    fn collected_digits_voice_information_default() -> bool {
        false
    }
    fn collected_digits_voice_back_default() -> bool {
        false
    }
    #[doc = " The use of voiceBack is network-operator specific."]
    #[doc = " The endOfReplyDigit, cancelDigit, and startDigit parameters have been designated as OCTET STRING,"]
    #[doc = " and are to be encoded as  BCD, one digit per octet only, contained"]
    #[doc = " in the four least significant bits of each OCTET. The usage is service dependent."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum CollectedInfo {
        #[rasn(tag(context, 0))]
        collectedDigits(CollectedDigits),
        #[rasn(tag(context, 1))]
        iA5Information(bool),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Component {
        #[rasn(size("1..=118"), tag(context, 0))]
        componentInfo(OctetString),
        #[rasn(tag(context, 1))]
        relayedComponent(Any),
    }
    #[doc = " If componentInfo is chosen, then it is necessary to use this parameter in sequence with ComponentType and"]
    #[doc = " ComponentCorrelationID"]
    #[doc = " If relayedComponent is chosen, then ComponentType and ComponentCorrelationID may not be used in the"]
    #[doc = " sequence"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ComponentCorrelationID(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ComponentType {
        any = 0,
        invoke = 1,
        rResult = 2,
        rError = 3,
        rReject = 4,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ConnectedNumberTreatmentInd {
        noINImpact = 0,
        presentationRestricted = 1,
        presentCalledINNumber = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Constraints {
        #[rasn(
            value("1..=127"),
            tag(context, 1),
            identifier = "maximumNumberOfDigits"
        )]
        pub maximum_number_of_digits: u8,
        #[rasn(
            value("1..=127"),
            tag(context, 2),
            identifier = "minimumNumberOfDigits"
        )]
        pub minimum_number_of_digits: u8,
        #[rasn(
            tag(context, 3),
            default = "constraints_type_of_requested_info_default",
            identifier = "typeOfRequestedInfo"
        )]
        pub type_of_requested_info: InfoType,
        #[rasn(
            value("0..=127"),
            tag(context, 4),
            default = "constraints_number_of_allowed_retries_default",
            identifier = "numberOfAllowedRetries"
        )]
        pub number_of_allowed_retries: u8,
    }
    impl Constraints {
        pub fn new(
            maximum_number_of_digits: u8,
            minimum_number_of_digits: u8,
            type_of_requested_info: InfoType,
            number_of_allowed_retries: u8,
        ) -> Self {
            Self {
                maximum_number_of_digits,
                minimum_number_of_digits,
                type_of_requested_info,
                number_of_allowed_retries,
            }
        }
    }
    fn constraints_type_of_requested_info_default() -> InfoType {
        InfoType::numericString
    }
    fn constraints_number_of_allowed_retries_default() -> u8 {
        0
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ControlConditionByCallParty {
        #[rasn(
            size("1..=2"),
            tag(context, 0),
            identifier = "endOfMessageSendingDigit"
        )]
        pub end_of_message_sending_digit: Option<OctetString>,
        #[rasn(size("1..=2"), tag(context, 1), identifier = "replayDigit")]
        pub replay_digit: Option<OctetString>,
    }
    impl ControlConditionByCallParty {
        pub fn new(
            end_of_message_sending_digit: Option<OctetString>,
            replay_digit: Option<OctetString>,
        ) -> Self {
            Self {
                end_of_message_sending_digit,
                replay_digit,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ControlType {
        sCPOverloaded = 0,
        manuallyInitiated = 1,
        destinationOverload = 2,
    }
    #[doc = " used by SCF for correlation with a previous operation. Refer to clause 17 for a description of the procedures"]
    #[doc = " associated with this parameter."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct CounterAndValue {
        #[rasn(tag(context, 0), identifier = "counterID")]
        pub counter_id: CounterID,
        #[rasn(tag(context, 1), identifier = "counterValue")]
        pub counter_value: Integer4,
    }
    impl CounterAndValue {
        pub fn new(counter_id: CounterID, counter_value: Integer4) -> Self {
            Self {
                counter_id,
                counter_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=99"))]
    pub struct CounterID(pub u8);
    #[doc = " Indicates the counters to be incremented."]
    #[doc = " The counterIDs can be addressed by using the last digits of the dialled number."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("0..=100"))]
    pub struct CountersValue(pub SequenceOf<CounterAndValue>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=65536"))]
    pub struct CreditUnit(pub u32);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum CriticalityType {
        ignore = 0,
        abort = 1,
    }
    #[doc = " Indicates the SSF CSA identifier"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("3"))]
    pub struct CurrencyID(pub PrintableString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=22"))]
    pub struct CutAndPaste(pub u8);
    #[doc = " Indicates the number of digits to be deleted. Refer to Rec. Q.1224 for additional information."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DateAndTime(pub FixedOctetString<6usize>);
    #[doc = " The SCF may specify the number of digits to be collected by the SSF for the CollectedInfo event."]
    #[doc = " When all digits are collected, the SSF reports the event to the SCF."]
    #[doc = " The SCF may set a timer in the SSF for the No Answer event. If the user does not answer the call"]
    #[doc = " within the allotted time, the SSF reports the event to the SCF"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("-2..=86400"))]
    pub struct Duration(pub i32);
    #[doc = " Values are seconds"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ElementaryMessageID(pub Integer4);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Entry {
        #[rasn(tag(context, 0))]
        agreements(ObjectIdentifier),
        #[rasn(tag(context, 1))]
        networkSpecific(Integer4),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ErrorTreatment {
        reportErrorToScf = 0,
        help = 1,
        repeatPrompt = 2,
    }
    #[doc = " defined by network operator."]
    #[doc = " Indicates the charging related information specific to the event."]
    #[doc = " An example data type definition for this parameter is given below:"]
    #[doc = "\t\tchargePulses\t\t\t[0] Integer4,"]
    #[doc = "\t\tchargeMessages\t\t[1] OCTET STRING (SIZE (min..max))"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum EventTypeBCSM {
        origAttemptAuthorized = 1,
        collectedInfo = 2,
        analysedInformation = 3,
        routeSelectFailure = 4,
        oCalledPartyBusy = 5,
        oNoAnswer = 6,
        oAnswer = 7,
        oMidCall = 8,
        oDisconnect = 9,
        oAbandon = 10,
        termAttemptAuthorized = 12,
        tBusy = 13,
        tNoAnswer = 14,
        tAnswer = 15,
        tMidCall = 16,
        tDisconnect = 17,
        tAbandon = 18,
        oTermSeized = 19,
        oSuspended = 20,
        tSuspended = 21,
        origAttempt = 22,
        termAttempt = 23,
        oReAnswer = 24,
        tReAnswer = 25,
        facilitySelectedAndAvailable = 26,
        callAccepted = 27,
    }
    #[doc = " Indicates the BCSM detection point event. Refer to Rec. Q.1224 for additional information on the events."]
    #[doc = " Values origAttemptAuthorized and termAttemptAuthorized can only be used for TDPs"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum EventTypeBCUSM {
        componentReceived = 127,
        associationReleaseRequested = 126,
    }
    #[doc = "This parameter indicates an extension of an argument data type. Its content is network-operator specific"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum FacilityGroup {
        #[rasn(tag(context, 0))]
        trunkGroupID(Integer),
        #[rasn(tag(context, 1))]
        privateFacilityID(Integer),
        #[rasn(tag(context, 2))]
        huntGroup(OctetString),
        #[rasn(tag(context, 3))]
        routeIndex(OctetString),
    }
    #[doc = " Indicates the particular group of facilities to route the call. huntGroup and routeIndex are encoded as"]
    #[doc = " network-operator specific."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FacilityGroupMember(pub Integer);
    #[doc = " Indicates the specific member of a trunk group or multi-line hunt group."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FailureCause(pub OctetString);
    #[doc = " The two-digit feature code preceded by \"*\" or \"11\"."]
    #[doc = " Uses the LocationNumber format which is based on the Q.763 Location Number format."]
    #[doc = " The Nature of Address indicator field shall be set to \"Spare\" (value 00000000)."]
    #[doc = " The Numbering Plan Indicator field shall be set to \"Spare\" (value 000)"]
    #[doc = " Used for stimulus signalling (Rec. Q.932)."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum FeatureRequestIndicator {
        hold = 0,
        retrieve = 1,
        featureActivation = 2,
        spare1 = 3,
        sparen = 127,
    }
    #[doc = " If releaseCause is not present, the default value is the same as the ISUP cause value decimal 31."]
    #[doc = " If informationToSend is present, the call will be released after the end of the announcement"]
    #[doc = " with the indicated or default releaseCause."]
    #[doc = " If maximumNumberOfCounters is not present, ServiceFilteringResponse will be sent with"]
    #[doc = " CountersValue::= SEQUENCE SIZE (0) OF CountersAndValue"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum FilteringCharacteristics {
        #[rasn(value("1..=32000"), tag(context, 0))]
        interval(u16),
        #[rasn(tag(context, 1))]
        numberOfCalls(Integer4),
    }
    #[doc = " In case calledAddressValue is specified, the numbers to be filtered are from calledAddressValue"]
    #[doc = " up to and including calledAddressValue + maximumNumberOfCounters?1."]
    #[doc = " The last two digits of calledAddressvalue cannot exceed 100?maximumNumberOfCounters."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum FilteringTimeOut {
        #[rasn(tag(context, 0))]
        duration(Duration),
        #[rasn(tag(context, 1))]
        stopTime(DateAndTime),
    }
    #[doc = " Indicates the maximum duration of the filtering. When the timer expires, a ServiceFilteringResponse"]
    #[doc = " is sent to the SCF."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ForwardCallIndicators(pub FixedOctetString<2usize>);
    #[doc = " Indicates the condition that must be met to complete the connect."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ForwardServiceInteractionInd {
        #[rasn(
            size("1"),
            tag(context, 1),
            identifier = "conferenceTreatmentIndicator"
        )]
        pub conference_treatment_indicator: Option<OctetString>,
        #[rasn(
            size("1"),
            tag(context, 2),
            identifier = "callDiversionTreatmentIndicator"
        )]
        pub call_diversion_treatment_indicator: Option<OctetString>,
        #[rasn(
            size("1"),
            tag(context, 3),
            identifier = "callOfferingTreatmentIndicator"
        )]
        pub call_offering_treatment_indicator: Option<OctetString>,
    }
    impl ForwardServiceInteractionInd {
        pub fn new(
            conference_treatment_indicator: Option<OctetString>,
            call_diversion_treatment_indicator: Option<OctetString>,
            call_offering_treatment_indicator: Option<OctetString>,
        ) -> Self {
            Self {
                conference_treatment_indicator,
                call_diversion_treatment_indicator,
                call_offering_treatment_indicator,
            }
        }
    }
    #[doc = " Indicates the GVNS Forward information. Refer to clause 6/Q.735, for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ForwardingCondition {
        busy = 0,
        noanswer = 1,
        any = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct GapIndicators {
        #[rasn(tag(context, 0))]
        pub duration: Duration,
        #[rasn(tag(context, 1), identifier = "gapInterval")]
        pub gap_interval: Interval,
    }
    impl GapIndicators {
        pub fn new(duration: Duration, gap_interval: Interval) -> Self {
            Self {
                duration,
                gap_interval,
            }
        }
    }
    #[doc = " Both calledAddressValue and callingAddressValue can be"]
    #[doc = " incomplete numbers, in the sense that a limited amount of digits can be given."]
    #[doc = ""]
    #[doc = " For the handling of numbers starting with the same digit string refer to the detailed procedure"]
    #[doc = " of the CallGap operation in 17.12."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct GapOnService {
        #[rasn(tag(context, 0), identifier = "serviceKey")]
        pub service_key: ServiceKey,
        #[rasn(tag(context, 1), identifier = "dpCriteria")]
        pub dp_criteria: Option<EventTypeBCSM>,
    }
    impl GapOnService {
        pub fn new(service_key: ServiceKey, dp_criteria: Option<EventTypeBCSM>) -> Self {
            Self {
                service_key,
                dp_criteria,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct HighLayerCompatibilities(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct HighLayerCompatibility(pub FixedOctetString<2usize>);
    #[doc = " Indicates the teleservice. For encoding, DSS 1 (Rec.Q.931) is used."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct HoldCause(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct INServiceCompatibilityResponse(pub Entry);
    #[doc = " defined by network operator."]
    #[doc = " Indicates the SRF resources available at the SSP."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ISDNAccessRelatedInformation(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum InfoType {
        numericString = 0,
        characterString = 1,
        iA5String = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=2147483647"))]
    pub struct Integer4(pub u32);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum InteractionStrategy {
        stopOnError = 1,
        bestEffort = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("-1..=60000"))]
    pub struct Interval(pub i32);
    #[doc = " Units are milliseconds. A ?1 value denotes infinite."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum InvokableService {
        callingLineIdentificationRestriction = 1,
        connectedLineIdentificationRestriction = 2,
        callWaiting = 3,
        callHold = 4,
        reverseCharging = 5,
        explicitCallTransfer = 6,
        callCompletionOnBusySubscriber = 7,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct InvokeID(pub InvokeIdType);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("-128..=127"))]
    pub struct InvokeIdType(pub i8);
    #[doc = " Indicates the destination user network interface related information. Refer to the Q.763 Access"]
    #[doc = " Transport parameter for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("3"))]
    pub struct Language(pub PrintableString);
    #[doc = " ISO 639 codes only;"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum LegID {
        #[rasn(tag(context, 0))]
        sendingSideID(LegType),
        #[rasn(tag(context, 1))]
        receivingSideID(LegType),
    }
    #[doc = " Indicates a reference to a specific party in a call. OPTIONAL denotes network-operator specific use"]
    #[doc = " with a choice of unilateral ID assignment or bilateral ID assignment."]
    #[doc = " OPTIONAL for LegID also denotes the following:"]
    #[doc = " when only one party exists in the call, this parameter is not needed (as no ambiguity exists);"]
    #[doc = " when more than one party exists in the call, one of the following alternatives applies:"]
    #[doc = "\t 1. LegID is present and indicates which party is concerned."]
    #[doc = "\t 2. LegID is not present and a default value is assumed (e.g. calling party in the case of the"]
    #[doc = "\t    ApplyCharging operation)."]
    #[doc = " Choice between these two alternatives is kept a network-operator option."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct LegType(pub FixedOctetString<1usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=100"))]
    pub struct MaximumNumberOfCounters(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum Media {
        voiceMail = 0,
        faxGroup3 = 1,
        faxGroup4 = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum Message {
        rELease = 77,
        rELeaseCOMPlete = 90,
        fACility = 98,
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum MiscCallInfoMessageType {
        request = 0,
        notification = 1,
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum MiscCallInfoDpAssignment {
        individualLine = 0,
        groupBased = 1,
        officeBased = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MiscCallInfo {
        #[rasn(tag(context, 0), identifier = "messageType")]
        pub message_type: MiscCallInfoMessageType,
        #[rasn(tag(context, 1), identifier = "dpAssignment")]
        pub dp_assignment: Option<MiscCallInfoDpAssignment>,
    }
    impl MiscCallInfo {
        pub fn new(
            message_type: MiscCallInfoMessageType,
            dp_assignment: Option<MiscCallInfoDpAssignment>,
        ) -> Self {
            Self {
                message_type,
                dp_assignment,
            }
        }
    }
    #[doc = " Indicates detection point related information."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum MonitorMode {
        interrupted = 0,
        notifyAndContinue = 1,
        transparent = 2,
    }
    #[doc = " Indicates the event is relayed and/or processed by the SSP."]
    #[doc = " If this parameter is used in the context of charging events, the following definitions apply for the"]
    #[doc = " handling of charging events:"]
    #[doc = " Interrupted means that the SSF notifies the SCF of the charging event using"]
    #[doc = " EventNotificationCharging, does not process the event but discards it."]
    #[doc = " NotifyAndContinue means that SSF notifies the SCF of the charging event using"]
    #[doc = " EventNotificationCharging, and continues processing the event or signal without waiting for SCF instructions."]
    #[doc = " Transparent means that the SSF does not notify the SCF of the event. This value is used to end the monitoring"]
    #[doc = " of a previously requested charging event. Previously requested charging events are monitored"]
    #[doc = " until ended by a transparent monitor mode, or until the end of the connection configuration."]
    #[doc = " For the use of this parameter in the context of BCSM events, refer to clause 17."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum Notification {
        userAbandon = 0,
        callFailure = 1,
        noReply = 2,
        callRelease = 3,
        ssInvocation = 4,
        creditLimitReached = 5,
        callDuration = 6,
        calledNumber = 7,
        answeredCall = 8,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=255"))]
    pub struct NumberOfDigits(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct NumberingPlan(pub FixedOctetString<1usize>);
    #[doc = " Indicates the number of digits to be collected"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum OperationCode {
        globalCode(ObjectIdentifier),
        local(Integer),
    }
    #[doc = " Indicates the original called number. Refer to the Q.763 Original Called Number for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PartyID(pub Integer);
    #[doc = " size limit to be added"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ReceivedStatus {
        messageComplete = 0,
        messageInterrupted = 1,
        messageTimeOut = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RecordedMessageID(pub Integer4);
    #[doc = " Indicates redirecting number. Refer to the Q.763 Redirecting number for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RedirectionInformation(pub FixedOctetString<2usize>);
    #[doc = " Indicates redirection information. Refer to the Q.763 Redirection Information for encoding."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RegistratorIdentifier(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ReportCondition {
        statusReport = 0,
        timerExpired = 1,
        cancelled = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum RequestedInformationType {
        callAttemptElapsedTime = 0,
        callStopTime = 1,
        callConnectedElapsedTime = 2,
        calledAddress = 3,
        releaseCause = 30,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=5"))]
    pub struct RequestedInformationTypeList(pub SequenceOf<RequestedInformationType>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=127"))]
    pub struct RequestedType(pub u8);
    #[doc = " Indicates a logical identifier for the physical termination resource."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ResourceStatus {
        busy = 0,
        idle = 1,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum ResponseCondition {
        intermediateResponse = 0,
        lastResponse = 1,
    }
    #[doc = " This parameter indicates the billing and/or charging characteristics. Its content is network-operator specific."]
    #[doc = " An example datatype definition for this parameter is given below:"]
    #[doc = " SCIBillingChargingCharacteristics ::= CHOICE {"]
    #[doc = " \tchargeLevel\t\t\t[0] OCTET STRING (SIZE (min..max),"]
    #[doc = " \tchargePulses\t\t\t[1] Integer4,"]
    #[doc = " \tchargeMessages\t\t[2] OCTET STRING (SIZE (min..max)"]
    #[doc = "\t}"]
    #[doc = " Depending on the applied charging scenario the following information elements"]
    #[doc = " can be included (refer to Appendix II/Q.1214):"]
    #[doc = " chargeLevel (scenario 3.2)"]
    #[doc = " chargePulses (scenario 3.2)"]
    #[doc = " chargeMessages (scenario 3.2)"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ServiceAddressInformation {
        #[rasn(tag(context, 0), identifier = "serviceKey")]
        pub service_key: Option<ServiceKey>,
        #[rasn(tag(context, 1), identifier = "miscCallInfo")]
        pub misc_call_info: MiscCallInfo,
        #[rasn(tag(context, 2), identifier = "triggerType")]
        pub trigger_type: Option<TriggerType>,
    }
    impl ServiceAddressInformation {
        pub fn new(
            service_key: Option<ServiceKey>,
            misc_call_info: MiscCallInfo,
            trigger_type: Option<TriggerType>,
        ) -> Self {
            Self {
                service_key,
                misc_call_info,
                trigger_type,
            }
        }
    }
    #[doc = " Indicators which are exchanged between SSP and SCP to resolve interactions between IN-based services"]
    #[doc = " and network-based services, respectively between different IN-based services."]
    #[doc = " The contents are network specific."]
    #[doc = " Note this parameter is kept in CS-2 for backward compatibility to CS-1R, for CS-2 see new"]
    #[doc = " parameter ServiceInteractionIndicatorsTwo"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[non_exhaustive]
    pub struct ServiceInteractionIndicatorsTwo {
        #[rasn(tag(context, 0), identifier = "forwardServiceInteractionInd")]
        pub forward_service_interaction_ind: Option<ForwardServiceInteractionInd>,
        #[rasn(tag(context, 1), identifier = "backwardServiceInteractionInd")]
        pub backward_service_interaction_ind: Option<BackwardServiceInteractionInd>,
        #[rasn(tag(context, 2), identifier = "bothwayThroughConnectionInd")]
        pub bothway_through_connection_ind: Option<BothwayThroughConnectionInd>,
        #[rasn(tag(context, 3), identifier = "suspendTimer")]
        pub suspend_timer: Option<SuspendTimer>,
        #[rasn(tag(context, 4), identifier = "connectedNumberTreatmentInd")]
        pub connected_number_treatment_ind: Option<ConnectedNumberTreatmentInd>,
        #[rasn(tag(context, 5), identifier = "suppressCallDiversionNotification")]
        pub suppress_call_diversion_notification: Option<bool>,
        #[rasn(tag(context, 6), identifier = "suppressCallTransferNotification")]
        pub suppress_call_transfer_notification: Option<bool>,
        #[rasn(tag(context, 7), identifier = "allowCdINNoPresentationInd")]
        pub allow_cd_inno_presentation_ind: Option<bool>,
        #[rasn(
            tag(context, 8),
            default = "service_interaction_indicators_two_user_dialogue_duration_ind_default",
            identifier = "userDialogueDurationInd"
        )]
        pub user_dialogue_duration_ind: bool,
    }
    impl ServiceInteractionIndicatorsTwo {
        pub fn new(
            forward_service_interaction_ind: Option<ForwardServiceInteractionInd>,
            backward_service_interaction_ind: Option<BackwardServiceInteractionInd>,
            bothway_through_connection_ind: Option<BothwayThroughConnectionInd>,
            suspend_timer: Option<SuspendTimer>,
            connected_number_treatment_ind: Option<ConnectedNumberTreatmentInd>,
            suppress_call_diversion_notification: Option<bool>,
            suppress_call_transfer_notification: Option<bool>,
            allow_cd_inno_presentation_ind: Option<bool>,
            user_dialogue_duration_ind: bool,
        ) -> Self {
            Self {
                forward_service_interaction_ind,
                backward_service_interaction_ind,
                bothway_through_connection_ind,
                suspend_timer,
                connected_number_treatment_ind,
                suppress_call_diversion_notification,
                suppress_call_transfer_notification,
                allow_cd_inno_presentation_ind,
                user_dialogue_duration_ind,
            }
        }
    }
    fn service_interaction_indicators_two_user_dialogue_duration_ind_default() -> bool {
        true
    }
    #[doc = " Indicators which are exchanged between SSP and SCP to resolve interactions between IN-based services"]
    #[doc = " and network-based services, respectively between different IN-based services."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ServiceKey(pub Integer4);
    #[doc = " Information that allows the SCF to choose the appropriate service logic."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ServiceProfileIdentifier(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SupplementaryServices(pub BitString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=120"))]
    pub struct SuspendTimer(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TerminalType {
        unknown = 0,
        dialPulse = 1,
        dtmf = 2,
        isdn = 3,
        isdnNoDtmf = 4,
        spare = 16,
    }
    #[doc = " Identifies the terminal type so that the SCF can specify, to the SRF, the appropriate type of capability"]
    #[doc = " (voice recognition, DTMF, display capability, etc.). Since present signalling systems do not convey"]
    #[doc = " terminal type, this parameter applies only at originating or terminating local exchanges."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TimerID {
        tssf = 0,
    }
    #[doc = " Indicates the timer to be reset."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TimerValue(pub Integer4);
    #[doc = " Indicates the timer value (in seconds)."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Tone {
        #[rasn(tag(context, 0), identifier = "toneID")]
        pub tone_id: Integer4,
        #[rasn(tag(context, 1))]
        pub duration: Option<Integer4>,
    }
    impl Tone {
        pub fn new(tone_id: Integer4, duration: Option<Integer4>) -> Self {
            Self { tone_id, duration }
        }
    }
    #[doc = " The duration specifies the length of the tone in seconds, value 0 indicates infinite duration."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ToneId {
        #[rasn(tag(context, 0))]
        local(Integer4),
        #[rasn(tag(context, 1))]
        global(ObjectIdentifier),
    }
    #[doc = " It is for further study whether all TDP types really apply"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TriggerType {
        featureActivation = 0,
        verticalServiceCode = 1,
        customizedAccess = 2,
        customizedIntercom = 3,
        emergencyService = 12,
        aFR = 13,
        sharedIOTrunk = 14,
        offHookDelay = 17,
        channelSetupPRI = 18,
        tNoAnswer = 25,
        tBusy = 26,
        oCalledPartyBusy = 27,
        oNoAnswer = 29,
        originationAttemptAuthorized = 30,
        oAnswer = 31,
        oDisconnect = 32,
        termAttemptAuthorized = 33,
        tAnswer = 34,
        tDisconnect = 35,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum USIMonitorMode {
        monitoringActive = 0,
        monitoringInactive = 1,
    }
    #[doc = " The type of trigger which caused call suspension"]
    #[doc = " 4-11: Reserved; 15,16: Reserved; 19-24: Reserved"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum UnavailableNetworkResource {
        unavailableResources = 0,
        componentFailure = 1,
        basicCallProcessingException = 2,
        resourceStatusFailure = 3,
        endUserFailure = 4,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct UserInteractionModes(pub BitString);
    #[doc = " Indicates the variable part of the message."]
    #[doc = " BCD coded variable parts are encoded as described in the examples below."]
    #[doc = " For example, time = 12:15 would be encoded as:"]
    #[doc = "\tBits\t\t\t\t\tHGFE \tDCBA"]
    #[doc = " \tleading octet\t\t\t\t        2\t        1"]
    #[doc = "\t\t\t\t\t\t       5\t       1"]
    #[doc = " date = 1993 September 30th would be encoded as:"]
    #[doc = "\tBits\t\t\t\t\tHGFE\tDCBA"]
    #[doc = "\tleading octet\t\t\t\t        3\t        9"]
    #[doc = "\t\t\t\t\t\t       9\t       0"]
    #[doc = "\t\t\t\t\t\t      0\t\t       3"]
    #[doc = " The Definition of range of constants Follows"]
    pub static HIGH_LAYER_COMPATIBILITY_LENGTH: LazyLock<Integer> =
        LazyLock::new(|| Integer::from(2));
    pub static INITIAL_CALL_SEGMENT: LazyLock<Integer> = LazyLock::new(|| Integer::from(1));
    pub static LEG1: LazyLock<LegType> =
        LazyLock::new(|| LegType(<OctetString as From<&'static [u8]>>::from(&[1])));
    pub static LEG2: LazyLock<LegType> =
        LazyLock::new(|| LegType(<OctetString as From<&'static [u8]>>::from(&[2])));
    pub static MAX_CREDIT_UNIT: LazyLock<Integer> = LazyLock::new(|| Integer::from(65536));
    pub static MIN_CAUSE_LENGTH: LazyLock<Integer> = LazyLock::new(|| Integer::from(2));
    pub static NUM_OF_COUNTERS: LazyLock<Integer> = LazyLock::new(|| Integer::from(100));
    pub static NUM_OF_INFO_ITEMS: LazyLock<Integer> = LazyLock::new(|| Integer::from(5));
}
