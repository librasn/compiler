---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x282_1999_DLM.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod dlm {
    extern crate alloc;
    use super::attribute_asn1_module::{GroupObjects, ObservedValue, PerceivedSeverity};
    use super::cmip_1::{AttributeId, ObjectInstance, SetInfoStatus};
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FRMRSyntax(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Integer(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum InterfaceType {
        dTE = 0,
        dCE = 1,
    }
    #[doc = "  in bits, 1080 (135 octets) minimum"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MW {
        #[rasn(value("0..=4095"), tag(context, 0), identifier = "mWSend")]
        pub m_wsend: u16,
        #[rasn(value("0..=4095"), tag(context, 1), identifier = "mWReceive")]
        pub m_wreceive: u16,
    }
    impl MW {
        pub fn new(m_wsend: u16, m_wreceive: u16) -> Self {
            Self {
                m_wsend,
                m_wreceive,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct MX {
        #[rasn(value("0..=4095"), tag(context, 0), identifier = "mXSend")]
        pub m_xsend: u16,
        #[rasn(value("0..=4095"), tag(context, 1), identifier = "mXReceive")]
        pub m_xreceive: u16,
    }
    impl MX {
        pub fn new(m_xsend: u16, m_xreceive: u16) -> Self {
            Self {
                m_xsend,
                m_xreceive,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct MaximumIFrameSize(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct NamingString(pub GraphicString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Octet(pub FixedOctetString<1usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct OctetString(pub OctetString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum SLPProtocolState {
        disconnectedPhase = 0,
        #[rasn(identifier = "linkdisconnection-phase")]
        linkdisconnection_phase = 1,
        #[rasn(identifier = "link-set-up-phase")]
        link_set_up_phase = 2,
        #[rasn(identifier = "information-Transfer-phase")]
        information_Transfer_phase = 3,
        #[rasn(identifier = "frame-Reject-condition")]
        frame_Reject_condition = 4,
        #[rasn(identifier = "busy-condition")]
        busy_condition = 5,
        #[rasn(identifier = "sent-Reject-condition")]
        sent_Reject_condition = 6,
        #[rasn(identifier = "system-Parameters-and-error-recovery")]
        system_Parameters_and_error_recovery = 7,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SequenceModulus(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum WindowSize {
        #[rasn(value("1..=7"), tag(context, 0))]
        modulo8ws(u8),
        #[rasn(value("1..=127"), tag(context, 1))]
        modulo128ws(u8),
    }
    pub static ACOI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[9u32]].concat()).unwrap().to_owned());
    #[doc = ""]
    #[doc = "  value assignments for Data Link layer specific errorIds for activate action processingFailure"]
    #[doc = "  errors."]
    pub static ACTIVATE_FAILURE: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***SSEOI, &[9u32, 1u32, 1u32, 1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static ACTIVATE_FAILURE_INSUFFICIENT_RESOURCES: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ACTIVATE_FAILURE, &[1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ACTIVATE_FAILURE_PROVIDER_DOES_NOT_EXIST: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ACTIVATE_FAILURE, &[2u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ACTIVATE_FAILURE_PROVIDER_NOT_AVAILABLE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ACTIVATE_FAILURE, &[3u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ACTIVATE_FAILURE_REQUIRED_SERVICE_NOT_AVAILABLE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***ACTIVATE_FAILURE, &[4u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static ACTIVATE_FAILURE_SYSTEM_SPECIFIC: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ACTIVATE_FAILURE, &[5u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static AGOI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[8u32]].concat()).unwrap().to_owned());
    pub static AOI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[7u32]].concat()).unwrap().to_owned());
    #[doc = "  \"infrastructure\" object identifier definitions"]
    pub static DATALINK_LAYER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 15u32]).to_owned());
    #[doc = ""]
    #[doc = "  other definitions"]
    pub static DATALINK_SUBSYSTEM_ID_VALUE: LazyLock<GraphicString> =
        LazyLock::new(|| GraphicString::try_from(String::from("datalinkSubsystem")).unwrap());
    pub static DLOI: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***DATALINK_LAYER, &[0u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static F_RMRREASONS: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***SSEOI, &[11u32, 6u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static F_RMRREASONS_CONTROL_FIELD_UNDEFINED_OR_UNIMPLEMENTED: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***SSEOI, &[11u32, 6u32, 1u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static F_RMRREASONS_FORMAT_ERROR: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***SSEOI, &[11u32, 6u32, 2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static F_RMRREASONS_INFO_FIELD_LENGTH_GREATER_THAN_MAXIMUM: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| {
            Oid::new(&[&***SSEOI, &[11u32, 6u32, 3u32]].concat())
                .unwrap()
                .to_owned()
        });
    pub static F_RMRREASONS_INVALID_NR: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***SSEOI, &[11u32, 6u32, 4u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static F_RMRREASONS_NON_SPECIFIC: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***SSEOI, &[11u32, 6u32, 5u32]].concat())
            .unwrap()
            .to_owned()
    });
    #[doc = ""]
    #[doc = "  value assignments for Data Link layer specificProblems"]
    pub static F_RMRRECEIVED: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***SSEOI, &[11u32, 5u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub const INTERFACE_TYPE_DEFAULT: InterfaceType = InterfaceType::dTE;
    pub static K: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***AOI, &[19u32]].concat()).unwrap().to_owned());
    pub static MOI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[3u32]].concat()).unwrap().to_owned());
    pub static N1: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***AOI, &[20u32]].concat()).unwrap().to_owned());
    pub static N2: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***AOI, &[21u32]].concat()).unwrap().to_owned());
    pub static NBOI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[6u32]].concat()).unwrap().to_owned());
    pub static NOI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[10u32]].concat()).unwrap().to_owned());
    pub static POI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[4u32]].concat()).unwrap().to_owned());
    pub static PROI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[5u32]].concat()).unwrap().to_owned());
    pub static SEQUENCE_MODULUS: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***AOI, &[24u32]].concat()).unwrap().to_owned());
    pub static SSEOI: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***DLOI, &[0u32]].concat()).unwrap().to_owned());
    pub static T1_TIMER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***AOI, &[25u32]].concat()).unwrap().to_owned());
    pub static T2_TIMER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***AOI, &[26u32]].concat()).unwrap().to_owned());
    pub static T3_TIMER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***AOI, &[27u32]].concat()).unwrap().to_owned());
    pub static T4_TIMER: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::new(&[&***AOI, &[28u32]].concat()).unwrap().to_owned());
}
