---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_h_h225-0_1998_H323-MESSAGES.asn1
---
Warnings:
LinkerError in ASN grammar: Failed to resolve supertype HASHED of parameterized implementation.


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod h323_messages {
    extern crate alloc;
    use super::h235_security_messages::*;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AdmissionConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "callModel")]
        pub call_model: CallModel,
        #[rasn(identifier = "destCallSignalAddress")]
        pub dest_call_signal_address: TransportAddress,
        #[rasn(value("1..=65535"), identifier = "irrFrequency")]
        pub irr_frequency: Option<u16>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "destinationInfo")]
        pub destination_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "destinationType")]
        pub destination_type: Option<EndpointType>,
        #[rasn(extension_addition, identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "transportQOS")]
        pub transport_qos: Option<TransportQOS>,
        #[rasn(extension_addition, identifier = "willRespondToIRR")]
        pub will_respond_to_irr: bool,
        #[rasn(extension_addition, identifier = "uuiesRequested")]
        pub uuies_requested: UUIEsRequested,
    }
    impl AdmissionConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            band_width: BandWidth,
            call_model: CallModel,
            dest_call_signal_address: TransportAddress,
            irr_frequency: Option<u16>,
            non_standard_data: Option<NonStandardParameter>,
            destination_info: Option<SequenceOf<AliasAddress>>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            destination_type: Option<EndpointType>,
            remote_extension_address: Option<SequenceOf<AliasAddress>>,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            transport_qos: Option<TransportQOS>,
            will_respond_to_irr: bool,
            uuies_requested: UUIEsRequested,
        ) -> Self {
            Self {
                request_seq_num,
                band_width,
                call_model,
                dest_call_signal_address,
                irr_frequency,
                non_standard_data,
                destination_info,
                dest_extra_call_info,
                destination_type,
                remote_extension_address,
                alternate_endpoints,
                tokens,
                crypto_tokens,
                integrity_check_value,
                transport_qos,
                will_respond_to_irr,
                uuies_requested,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AdmissionReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: AdmissionRejectReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "callSignalAddress")]
        pub call_signal_address: Option<SequenceOf<TransportAddress>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl AdmissionReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: AdmissionRejectReason,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            call_signal_address: Option<SequenceOf<TransportAddress>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                non_standard_data,
                alt_gkinfo,
                tokens,
                call_signal_address,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AdmissionRejectReason {
        calledPartyNotRegistered(()),
        invalidPermission(()),
        requestDenied(()),
        undefinedReason(()),
        callerNotRegistered(()),
        routeCallToGatekeeper(()),
        invalidEndpointIdentifier(()),
        resourceUnavailable(()),
        #[rasn(extension_addition)]
        securityDenial(()),
        #[rasn(extension_addition)]
        qosControlNotSupported(()),
        #[rasn(extension_addition)]
        incompleteAddress(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AdmissionRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "callType")]
        pub call_type: CallType,
        #[rasn(identifier = "callModel")]
        pub call_model: Option<CallModel>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "destCallSignalAddress")]
        pub dest_call_signal_address: Option<TransportAddress>,
        #[rasn(identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "srcInfo")]
        pub src_info: SequenceOf<AliasAddress>,
        #[rasn(identifier = "srcCallSignalAddress")]
        pub src_call_signal_address: Option<TransportAddress>,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "callServices")]
        pub call_services: Option<QseriesOptions>,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "activeMC")]
        pub active_mc: bool,
        #[rasn(identifier = "answerCall")]
        pub answer_call: bool,
        #[rasn(extension_addition, identifier = "canMapAlias")]
        pub can_map_alias: bool,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "srcAlternatives")]
        pub src_alternatives: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition, identifier = "destAlternatives")]
        pub dest_alternatives: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "transportQOS")]
        pub transport_qos: Option<TransportQOS>,
        #[rasn(extension_addition, identifier = "willSupplyUUIEs")]
        pub will_supply_uuies: bool,
    }
    impl AdmissionRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            call_type: CallType,
            call_model: Option<CallModel>,
            endpoint_identifier: EndpointIdentifier,
            destination_info: Option<SequenceOf<AliasAddress>>,
            dest_call_signal_address: Option<TransportAddress>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            src_info: SequenceOf<AliasAddress>,
            src_call_signal_address: Option<TransportAddress>,
            band_width: BandWidth,
            call_reference_value: CallReferenceValue,
            non_standard_data: Option<NonStandardParameter>,
            call_services: Option<QseriesOptions>,
            conference_id: ConferenceIdentifier,
            active_mc: bool,
            answer_call: bool,
            can_map_alias: bool,
            call_identifier: CallIdentifier,
            src_alternatives: Option<SequenceOf<Endpoint>>,
            dest_alternatives: Option<SequenceOf<Endpoint>>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            transport_qos: Option<TransportQOS>,
            will_supply_uuies: bool,
        ) -> Self {
            Self {
                request_seq_num,
                call_type,
                call_model,
                endpoint_identifier,
                destination_info,
                dest_call_signal_address,
                dest_extra_call_info,
                src_info,
                src_call_signal_address,
                band_width,
                call_reference_value,
                non_standard_data,
                call_services,
                conference_id,
                active_mc,
                answer_call,
                can_map_alias,
                call_identifier,
                src_alternatives,
                dest_alternatives,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                transport_qos,
                will_supply_uuies,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Alerting-UUIE")]
    #[non_exhaustive]
    pub struct AlertingUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: EndpointType,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
    }
    impl AlertingUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            destination_info: EndpointType,
            h245_address: Option<TransportAddress>,
            call_identifier: CallIdentifier,
            h245_security_mode: Option<H245Security>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
        ) -> Self {
            Self {
                protocol_identifier,
                destination_info,
                h245_address,
                call_identifier,
                h245_security_mode,
                tokens,
                crypto_tokens,
                fast_start,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum AliasAddress {
        #[rasn(
            size("1..=128"),
            from(
                "\u{20}", "\u{2a}", "\u{2c}", "\u{2e}", "\u{30}", "\u{31}", "\u{32}", "\u{33}",
                "\u{34}", "\u{35}", "\u{36}", "\u{37}", "\u{38}", "\u{39}", "\u{4e}", "\u{6f}"
            )
        )]
        e164(Ia5String),
        #[rasn(size("1..=256"), identifier = "h323-ID")]
        h323_ID(BmpString),
        #[rasn(extension_addition, size("1..=512"), identifier = "url-ID")]
        url_ID(Ia5String),
        #[rasn(extension_addition)]
        transportID(TransportAddress),
        #[rasn(extension_addition, size("1..=512"), identifier = "email-ID")]
        email_ID(Ia5String),
        #[rasn(extension_addition)]
        partyNumber(PartyNumber),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AltGKInfo {
        pub alternategatekeeper: SequenceOf<AlternateGK>,
        #[rasn(identifier = "altGKisPermanent")]
        pub alt_gkis_permanent: bool,
    }
    impl AltGKInfo {
        pub fn new(alternategatekeeper: SequenceOf<AlternateGK>, alt_gkis_permanent: bool) -> Self {
            Self {
                alternategatekeeper,
                alt_gkis_permanent,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct AlternateGK {
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "needToRegister")]
        pub need_to_register: bool,
        #[rasn(value("0..=127"))]
        pub priority: u8,
    }
    impl AlternateGK {
        pub fn new(
            ras_address: TransportAddress,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            need_to_register: bool,
            priority: u8,
        ) -> Self {
            Self {
                ras_address,
                gatekeeper_identifier,
                need_to_register,
                priority,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum BandRejectReason {
        notBound(()),
        invalidConferenceID(()),
        invalidPermission(()),
        insufficientResources(()),
        invalidRevision(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=4294967295"))]
    pub struct BandWidth(pub u32);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BandwidthConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl BandwidthConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            band_width: BandWidth,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                band_width,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BandwidthReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: BandRejectReason,
        #[rasn(identifier = "allowedBandWidth")]
        pub allowed_band_width: BandWidth,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl BandwidthReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: BandRejectReason,
            allowed_band_width: BandWidth,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                allowed_band_width,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct BandwidthRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "callType")]
        pub call_type: Option<CallType>,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "answeredCall")]
        pub answered_call: bool,
    }
    impl BandwidthRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            endpoint_identifier: EndpointIdentifier,
            conference_id: ConferenceIdentifier,
            call_reference_value: CallReferenceValue,
            call_type: Option<CallType>,
            band_width: BandWidth,
            non_standard_data: Option<NonStandardParameter>,
            call_identifier: CallIdentifier,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            answered_call: bool,
        ) -> Self {
            Self {
                request_seq_num,
                endpoint_identifier,
                conference_id,
                call_reference_value,
                call_type,
                band_width,
                non_standard_data,
                call_identifier,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                answered_call,
            }
        }
    }
    #[doc = "in seconds"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct CallIdentifier {
        pub guid: GloballyUniqueID,
    }
    impl CallIdentifier {
        pub fn new(guid: GloballyUniqueID) -> Self {
            Self { guid }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CallModel {
        direct(()),
        gatekeeperRouted(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "CallProceeding-UUIE")]
    #[non_exhaustive]
    pub struct CallProceedingUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: EndpointType,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
    }
    impl CallProceedingUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            destination_info: EndpointType,
            h245_address: Option<TransportAddress>,
            call_identifier: CallIdentifier,
            h245_security_mode: Option<H245Security>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
        ) -> Self {
            Self {
                protocol_identifier,
                destination_info,
                h245_address,
                call_identifier,
                h245_security_mode,
                tokens,
                crypto_tokens,
                fast_start,
            }
        }
    }
    #[doc = " in 100s of bits"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=65535"))]
    pub struct CallReferenceValue(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CallType {
        pointToPoint(()),
        oneToN(()),
        nToOne(()),
        nToN(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ConferenceIdentifier(pub GloballyUniqueID);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ConferenceList {
        #[rasn(identifier = "conferenceID")]
        pub conference_id: Option<ConferenceIdentifier>,
        #[rasn(identifier = "conferenceAlias")]
        pub conference_alias: Option<AliasAddress>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl ConferenceList {
        pub fn new(
            conference_id: Option<ConferenceIdentifier>,
            conference_alias: Option<AliasAddress>,
            non_standard_data: Option<NonStandardParameter>,
        ) -> Self {
            Self {
                conference_id,
                conference_alias,
                non_standard_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Connect-UUIE")]
    #[non_exhaustive]
    pub struct ConnectUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: EndpointType,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
    }
    impl ConnectUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            h245_address: Option<TransportAddress>,
            destination_info: EndpointType,
            conference_id: ConferenceIdentifier,
            call_identifier: CallIdentifier,
            h245_security_mode: Option<H245Security>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
        ) -> Self {
            Self {
                protocol_identifier,
                h245_address,
                destination_info,
                conference_id,
                call_identifier,
                h245_security_mode,
                tokens,
                crypto_tokens,
                fast_start,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoH323TokenCryptoEPPwdHash {
        pub alias: AliasAddress,
        #[rasn(identifier = "timeStamp")]
        pub time_stamp: TimeStamp,
        #[rasn(value("0.."))]
        pub token: HASHED,
    }
    impl CryptoH323TokenCryptoEPPwdHash {
        pub fn new(alias: AliasAddress, time_stamp: TimeStamp, token: HASHED) -> Self {
            Self {
                alias,
                time_stamp,
                token,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct CryptoH323TokenCryptoGKPwdHash {
        #[rasn(identifier = "gatekeeperId")]
        pub gatekeeper_id: GatekeeperIdentifier,
        #[rasn(identifier = "timeStamp")]
        pub time_stamp: TimeStamp,
        #[rasn(value("0.."))]
        pub token: HASHED,
    }
    impl CryptoH323TokenCryptoGKPwdHash {
        pub fn new(
            gatekeeper_id: GatekeeperIdentifier,
            time_stamp: TimeStamp,
            token: HASHED,
        ) -> Self {
            Self {
                gatekeeper_id,
                time_stamp,
                token,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum CryptoH323Token {
        cryptoEPPwdHash(CryptoH323TokenCryptoEPPwdHash),
        cryptoGKPwdHash(CryptoH323TokenCryptoGKPwdHash),
        #[rasn(value("0.."))]
        cryptoEPPwdEncr(ENCRYPTED),
        #[rasn(value("0.."))]
        cryptoGKPwdEncr(ENCRYPTED),
        #[rasn(value("0.."))]
        cryptoEPCert(SIGNED),
        #[rasn(value("0.."))]
        cryptoGKCert(SIGNED),
        #[rasn(value("0.."))]
        cryptoFastStart(SIGNED),
        nestedcryptoToken(CryptoToken),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DataRate {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "channelRate")]
        pub channel_rate: BandWidth,
        #[rasn(value("1..=256"), identifier = "channelMultiplier")]
        pub channel_multiplier: Option<u16>,
    }
    impl DataRate {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            channel_rate: BandWidth,
            channel_multiplier: Option<u16>,
        ) -> Self {
            Self {
                non_standard_data,
                channel_rate,
                channel_multiplier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DisengageConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl DisengageConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DisengageReason {
        forcedDrop(()),
        normalDrop(()),
        undefinedReason(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DisengageReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: DisengageRejectReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl DisengageReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: DisengageRejectReason,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum DisengageRejectReason {
        notRegistered(()),
        requestToDropOther(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct DisengageRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "disengageReason")]
        pub disengage_reason: DisengageReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "answeredCall")]
        pub answered_call: bool,
    }
    impl DisengageRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            endpoint_identifier: EndpointIdentifier,
            conference_id: ConferenceIdentifier,
            call_reference_value: CallReferenceValue,
            disengage_reason: DisengageReason,
            non_standard_data: Option<NonStandardParameter>,
            call_identifier: CallIdentifier,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            answered_call: bool,
        ) -> Self {
            Self {
                request_seq_num,
                endpoint_identifier,
                conference_id,
                call_reference_value,
                disengage_reason,
                non_standard_data,
                call_identifier,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                answered_call,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EncodedFastStartToken(pub Any);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum EncryptIntAlg {
        nonStandard(NonStandardParameter),
        isoAlgorithm(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Endpoint {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "aliasAddress")]
        pub alias_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: Option<SequenceOf<TransportAddress>>,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: Option<SequenceOf<TransportAddress>>,
        #[rasn(identifier = "endpointType")]
        pub endpoint_type: Option<EndpointType>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(value("0..=127"))]
        pub priority: Option<u8>,
        #[rasn(identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
    }
    impl Endpoint {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            alias_address: Option<SequenceOf<AliasAddress>>,
            call_signal_address: Option<SequenceOf<TransportAddress>>,
            ras_address: Option<SequenceOf<TransportAddress>>,
            endpoint_type: Option<EndpointType>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            priority: Option<u8>,
            remote_extension_address: Option<SequenceOf<AliasAddress>>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        ) -> Self {
            Self {
                non_standard_data,
                alias_address,
                call_signal_address,
                ras_address,
                endpoint_type,
                tokens,
                crypto_tokens,
                priority,
                remote_extension_address,
                dest_extra_call_info,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=128"))]
    pub struct EndpointIdentifier(pub BmpString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct EndpointType {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub vendor: Option<VendorIdentifier>,
        pub gatekeeper: Option<GatekeeperInfo>,
        pub gateway: Option<GatewayInfo>,
        pub mcu: Option<McuInfo>,
        pub terminal: Option<TerminalInfo>,
        pub mc: bool,
        #[rasn(identifier = "undefinedNode")]
        pub undefined_node: bool,
    }
    impl EndpointType {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            vendor: Option<VendorIdentifier>,
            gatekeeper: Option<GatekeeperInfo>,
            gateway: Option<GatewayInfo>,
            mcu: Option<McuInfo>,
            terminal: Option<TerminalInfo>,
            mc: bool,
            undefined_node: bool,
        ) -> Self {
            Self {
                non_standard_data,
                vendor,
                gatekeeper,
                gateway,
                mcu,
                terminal,
                mc,
                undefined_node,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Facility-UUIE")]
    #[non_exhaustive]
    pub struct FacilityUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "alternativeAddress")]
        pub alternative_address: Option<TransportAddress>,
        #[rasn(identifier = "alternativeAliasAddress")]
        pub alternative_alias_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: Option<ConferenceIdentifier>,
        pub reason: FacilityReason,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<AliasAddress>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition)]
        pub conferences: Option<SequenceOf<ConferenceList>>,
        #[rasn(extension_addition, identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
    }
    impl FacilityUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            alternative_address: Option<TransportAddress>,
            alternative_alias_address: Option<SequenceOf<AliasAddress>>,
            conference_id: Option<ConferenceIdentifier>,
            reason: FacilityReason,
            call_identifier: CallIdentifier,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            remote_extension_address: Option<AliasAddress>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            conferences: Option<SequenceOf<ConferenceList>>,
            h245_address: Option<TransportAddress>,
        ) -> Self {
            Self {
                protocol_identifier,
                alternative_address,
                alternative_alias_address,
                conference_id,
                reason,
                call_identifier,
                dest_extra_call_info,
                remote_extension_address,
                tokens,
                crypto_tokens,
                conferences,
                h245_address,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum FacilityReason {
        routeCallToGatekeeper(()),
        callForwarded(()),
        routeCallToMC(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        conferenceListChoice(()),
        #[rasn(extension_addition)]
        starth245(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct FastStartToken(pub ClearToken);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatekeeperConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(extension_addition, identifier = "alternateGatekeeper")]
        pub alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
        #[rasn(extension_addition, identifier = "authenticationMode")]
        pub authentication_mode: Option<AuthenticationMechanism>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "algorithmOID")]
        pub algorithm_oid: Option<ObjectIdentifier>,
        #[rasn(extension_addition)]
        pub integrity: Option<SequenceOf<IntegrityMechanism>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl GatekeeperConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            ras_address: TransportAddress,
            alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
            authentication_mode: Option<AuthenticationMechanism>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            algorithm_oid: Option<ObjectIdentifier>,
            integrity: Option<SequenceOf<IntegrityMechanism>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                gatekeeper_identifier,
                ras_address,
                alternate_gatekeeper,
                authentication_mode,
                tokens,
                crypto_tokens,
                algorithm_oid,
                integrity,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, size("1..=128"))]
    pub struct GatekeeperIdentifier(pub BmpString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatekeeperInfo {
        pub vendor: H221NonStandard,
        #[rasn(size("1..=256"), identifier = "productId")]
        pub product_id: Option<OctetString>,
        #[rasn(size("1..=256"), identifier = "versionId")]
        pub version_id: Option<OctetString>,
    }
    impl GatekeeperInfo {
        pub fn new(
            vendor: H221NonStandard,
            product_id: Option<OctetString>,
            version_id: Option<OctetString>,
        ) -> Self {
            Self {
                vendor,
                product_id,
                version_id,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatekeeperReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: GatekeeperRejectReason,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl GatekeeperReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            reject_reason: GatekeeperRejectReason,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                gatekeeper_identifier,
                reject_reason,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum GatekeeperRejectReason {
        resourceUnavailable(()),
        terminalExcluded(()),
        invalidRevision(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatekeeperRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(identifier = "endpointType")]
        pub endpoint_type: EndpointType,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "callServices")]
        pub call_services: Option<QseriesOptions>,
        #[rasn(identifier = "endpointAlias")]
        pub endpoint_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "authenticationCapability")]
        pub authentication_capability: Option<SequenceOf<AuthenticationMechanism>>,
        #[rasn(extension_addition, identifier = "algorithmOIDs")]
        pub algorithm_oids: Option<SequenceOf<ObjectIdentifier>>,
        #[rasn(extension_addition)]
        pub integrity: Option<SequenceOf<IntegrityMechanism>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl GatekeeperRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            ras_address: TransportAddress,
            endpoint_type: EndpointType,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            call_services: Option<QseriesOptions>,
            endpoint_alias: Option<SequenceOf<AliasAddress>>,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            authentication_capability: Option<SequenceOf<AuthenticationMechanism>>,
            algorithm_oids: Option<SequenceOf<ObjectIdentifier>>,
            integrity: Option<SequenceOf<IntegrityMechanism>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                ras_address,
                endpoint_type,
                gatekeeper_identifier,
                call_services,
                endpoint_alias,
                alternate_endpoints,
                tokens,
                crypto_tokens,
                authentication_capability,
                algorithm_oids,
                integrity,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct GatewayInfo {
        pub protocol: Option<SequenceOf<SupportedProtocols>>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl GatewayInfo {
        pub fn new(
            protocol: Option<SequenceOf<SupportedProtocols>>,
            non_standard_data: Option<NonStandardParameter>,
        ) -> Self {
            Self {
                protocol,
                non_standard_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GloballyUniqueID(pub FixedOctetString<16usize>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H221NonStandard {
        #[rasn(value("0..=255"), identifier = "t35CountryCode")]
        pub t35_country_code: u8,
        #[rasn(value("0..=255"), identifier = "t35Extension")]
        pub t35_extension: u8,
        #[rasn(value("0..=65535"), identifier = "manufacturerCode")]
        pub manufacturer_code: u16,
    }
    impl H221NonStandard {
        pub fn new(t35_country_code: u8, t35_extension: u8, manufacturer_code: u16) -> Self {
            Self {
                t35_country_code,
                t35_extension,
                manufacturer_code,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H245Security {
        nonStandard(NonStandardParameter),
        noSecurity(()),
        tls(SecurityCapabilities),
        ipsec(SecurityCapabilities),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H310Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H310Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H320Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H320Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H321Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H321Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H322Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H322Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum H323UUPDUH323MessageBody {
        setup(SetupUUIE),
        callProceeding(CallProceedingUUIE),
        connect(ConnectUUIE),
        alerting(AlertingUUIE),
        userInformation(InformationUUIE),
        releaseComplete(ReleaseCompleteUUIE),
        facility(FacilityUUIE),
        #[rasn(extension_addition)]
        progress(ProgressUUIE),
        #[rasn(extension_addition)]
        empty(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "H323-UU-PDU")]
    #[non_exhaustive]
    pub struct H323UUPDU {
        #[rasn(identifier = "h323-message-body")]
        pub h323_message_body: H323UUPDUH323MessageBody,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "h4501SupplementaryService")]
        pub h4501_supplementary_service: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "h245Tunneling")]
        pub h245_tunneling: bool,
        #[rasn(extension_addition, identifier = "h245Control")]
        pub h245_control: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "nonStandardControl")]
        pub non_standard_control: Option<SequenceOf<NonStandardParameter>>,
    }
    impl H323UUPDU {
        pub fn new(
            h323_message_body: H323UUPDUH323MessageBody,
            non_standard_data: Option<NonStandardParameter>,
            h4501_supplementary_service: Option<SequenceOf<OctetString>>,
            h245_tunneling: bool,
            h245_control: Option<SequenceOf<OctetString>>,
            non_standard_control: Option<SequenceOf<NonStandardParameter>>,
        ) -> Self {
            Self {
                h323_message_body,
                non_standard_data,
                h4501_supplementary_service,
                h245_tunneling,
                h245_control,
                non_standard_control,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H323UserInformationUserData {
        #[rasn(value("0..=255"), identifier = "protocol-discriminator")]
        pub protocol_discriminator: u8,
        #[rasn(size("1..=131"), identifier = "user-information")]
        pub user_information: OctetString,
    }
    impl H323UserInformationUserData {
        pub fn new(protocol_discriminator: u8, user_information: OctetString) -> Self {
            Self {
                protocol_discriminator,
                user_information,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "H323-UserInformation")]
    #[non_exhaustive]
    pub struct H323UserInformation {
        #[rasn(identifier = "h323-uu-pdu")]
        pub h323_uu_pdu: H323UUPDU,
        #[rasn(identifier = "user-data")]
        pub user_data: Option<H323UserInformationUserData>,
    }
    impl H323UserInformation {
        pub fn new(h323_uu_pdu: H323UUPDU, user_data: Option<H323UserInformationUserData>) -> Self {
            Self {
                h323_uu_pdu,
                user_data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H323Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H323Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct H324Caps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl H324Caps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct ICV {
        #[rasn(identifier = "algorithmOID")]
        pub algorithm_oid: ObjectIdentifier,
        pub icv: BitString,
    }
    impl ICV {
        pub fn new(algorithm_oid: ObjectIdentifier, icv: BitString) -> Self {
            Self { algorithm_oid, icv }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct InfoRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "replyAddress")]
        pub reply_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "uuiesRequested")]
        pub uuies_requested: Option<UUIEsRequested>,
    }
    impl InfoRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            call_reference_value: CallReferenceValue,
            non_standard_data: Option<NonStandardParameter>,
            reply_address: Option<TransportAddress>,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            uuies_requested: Option<UUIEsRequested>,
        ) -> Self {
            Self {
                request_seq_num,
                call_reference_value,
                non_standard_data,
                reply_address,
                call_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                uuies_requested,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct InfoRequestAck {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl InfoRequestAck {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct InfoRequestNak {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "nakReason")]
        pub nak_reason: InfoRequestNakReason,
        #[rasn(identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl InfoRequestNak {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            nak_reason: InfoRequestNakReason,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                nak_reason,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum InfoRequestNakReason {
        notRegistered(()),
        securityDenial(()),
        undefinedReason(()),
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "SEQUENCE")]
    pub struct AnonymousAnonymousInfoRequestResponsePerCallInfoPdu {
        pub h323pdu: H323UUPDU,
        pub sent: bool,
    }
    impl AnonymousAnonymousInfoRequestResponsePerCallInfoPdu {
        pub fn new(h323pdu: H323UUPDU, sent: bool) -> Self {
            Self { h323pdu, sent }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AnonymousInfoRequestResponsePerCallInfoPdu(
        pub SequenceOf<AnonymousAnonymousInfoRequestResponsePerCallInfoPdu>,
    );
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "SEQUENCE")]
    #[non_exhaustive]
    pub struct AnonymousInfoRequestResponsePerCallInfo {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "callReferenceValue")]
        pub call_reference_value: CallReferenceValue,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        pub originator: Option<bool>,
        pub audio: Option<SequenceOf<RTPSession>>,
        pub video: Option<SequenceOf<RTPSession>>,
        pub data: Option<SequenceOf<TransportChannelInfo>>,
        pub h245: TransportChannelInfo,
        #[rasn(identifier = "callSignaling")]
        pub call_signaling: TransportChannelInfo,
        #[rasn(identifier = "callType")]
        pub call_type: CallType,
        #[rasn(identifier = "bandWidth")]
        pub band_width: BandWidth,
        #[rasn(identifier = "callModel")]
        pub call_model: CallModel,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "substituteConfIDs")]
        pub substitute_conf_ids: SequenceOf<ConferenceIdentifier>,
        #[rasn(extension_addition)]
        pub pdu: Option<AnonymousInfoRequestResponsePerCallInfoPdu>,
    }
    impl AnonymousInfoRequestResponsePerCallInfo {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            call_reference_value: CallReferenceValue,
            conference_id: ConferenceIdentifier,
            originator: Option<bool>,
            audio: Option<SequenceOf<RTPSession>>,
            video: Option<SequenceOf<RTPSession>>,
            data: Option<SequenceOf<TransportChannelInfo>>,
            h245: TransportChannelInfo,
            call_signaling: TransportChannelInfo,
            call_type: CallType,
            band_width: BandWidth,
            call_model: CallModel,
            call_identifier: CallIdentifier,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            substitute_conf_ids: SequenceOf<ConferenceIdentifier>,
            pdu: Option<AnonymousInfoRequestResponsePerCallInfoPdu>,
        ) -> Self {
            Self {
                non_standard_data,
                call_reference_value,
                conference_id,
                originator,
                audio,
                video,
                data,
                h245,
                call_signaling,
                call_type,
                band_width,
                call_model,
                call_identifier,
                tokens,
                crypto_tokens,
                substitute_conf_ids,
                pdu,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct InfoRequestResponsePerCallInfo(
        pub SequenceOf<AnonymousInfoRequestResponsePerCallInfo>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct InfoRequestResponse {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "endpointType")]
        pub endpoint_type: EndpointType,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "endpointAlias")]
        pub endpoint_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "perCallInfo")]
        pub per_call_info: Option<InfoRequestResponsePerCallInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "needResponse")]
        pub need_response: bool,
    }
    impl InfoRequestResponse {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            request_seq_num: RequestSeqNum,
            endpoint_type: EndpointType,
            endpoint_identifier: EndpointIdentifier,
            ras_address: TransportAddress,
            call_signal_address: SequenceOf<TransportAddress>,
            endpoint_alias: Option<SequenceOf<AliasAddress>>,
            per_call_info: Option<InfoRequestResponsePerCallInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            need_response: bool,
        ) -> Self {
            Self {
                non_standard_data,
                request_seq_num,
                endpoint_type,
                endpoint_identifier,
                ras_address,
                call_signal_address,
                endpoint_alias,
                per_call_info,
                tokens,
                crypto_tokens,
                integrity_check_value,
                need_response,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Information-UUIE")]
    #[non_exhaustive]
    pub struct InformationUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
    }
    impl InformationUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            call_identifier: CallIdentifier,
        ) -> Self {
            Self {
                protocol_identifier,
                call_identifier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum IntegrityMechanism {
        nonStandard(NonStandardParameter),
        digSig(()),
        iso9797(ObjectIdentifier),
        nonIsoIM(NonIsoIntegrityMechanism),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LocationConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: TransportAddress,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: TransportAddress,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "destinationInfo")]
        pub destination_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "destinationType")]
        pub destination_type: Option<EndpointType>,
        #[rasn(extension_addition, identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl LocationConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            call_signal_address: TransportAddress,
            ras_address: TransportAddress,
            non_standard_data: Option<NonStandardParameter>,
            destination_info: Option<SequenceOf<AliasAddress>>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            destination_type: Option<EndpointType>,
            remote_extension_address: Option<SequenceOf<AliasAddress>>,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                call_signal_address,
                ras_address,
                non_standard_data,
                destination_info,
                dest_extra_call_info,
                destination_type,
                remote_extension_address,
                alternate_endpoints,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LocationReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: LocationRejectReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl LocationReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: LocationRejectReason,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum LocationRejectReason {
        notRegistered(()),
        invalidPermission(()),
        requestDenied(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct LocationRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: Option<EndpointIdentifier>,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: SequenceOf<AliasAddress>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "replyAddress")]
        pub reply_address: TransportAddress,
        #[rasn(extension_addition, identifier = "sourceInfo")]
        pub source_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(extension_addition, identifier = "canMapAlias")]
        pub can_map_alias: bool,
    }
    impl LocationRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            endpoint_identifier: Option<EndpointIdentifier>,
            destination_info: SequenceOf<AliasAddress>,
            non_standard_data: Option<NonStandardParameter>,
            reply_address: TransportAddress,
            source_info: Option<SequenceOf<AliasAddress>>,
            can_map_alias: bool,
        ) -> Self {
            Self {
                request_seq_num,
                endpoint_identifier,
                destination_info,
                non_standard_data,
                reply_address,
                source_info,
                can_map_alias,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct McuInfo {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl McuInfo {
        pub fn new(non_standard_data: Option<NonStandardParameter>) -> Self {
            Self { non_standard_data }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NonIsoIntegrityMechanism {
        #[rasn(identifier = "hMAC-MD5")]
        hMAC_MD5(()),
        #[rasn(identifier = "hMAC-iso10118-2-s")]
        hMAC_iso10118_2_s(EncryptIntAlg),
        #[rasn(identifier = "hMAC-iso10118-2-l")]
        hMAC_iso10118_2_l(EncryptIntAlg),
        #[rasn(identifier = "hMAC-iso10118-3")]
        hMAC_iso10118_3(ObjectIdentifier),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum NonStandardIdentifier {
        object(ObjectIdentifier),
        h221NonStandard(H221NonStandard),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NonStandardMessage {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: NonStandardParameter,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl NonStandardMessage {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: NonStandardParameter,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct NonStandardParameter {
        #[rasn(identifier = "nonStandardIdentifier")]
        pub non_standard_identifier: NonStandardIdentifier,
        pub data: OctetString,
    }
    impl NonStandardParameter {
        pub fn new(non_standard_identifier: NonStandardIdentifier, data: OctetString) -> Self {
            Self {
                non_standard_identifier,
                data,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct NonStandardProtocol {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl NonStandardProtocol {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(
        delegate,
        size("1..=128"),
        from(
            "\u{20}", "\u{2a}", "\u{2c}", "\u{2e}", "\u{30}", "\u{31}", "\u{32}", "\u{33}",
            "\u{34}", "\u{35}", "\u{36}", "\u{37}", "\u{38}", "\u{39}", "\u{4e}", "\u{6f}"
        )
    )]
    pub struct NumberDigits(pub Ia5String);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PartyNumber {
        publicNumber(PublicPartyNumber),
        dataPartyNumber(NumberDigits),
        telexPartyNumber(NumberDigits),
        privateNumber(PrivatePartyNumber),
        nationalStandardPartyNumber(NumberDigits),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct PrivatePartyNumber {
        #[rasn(identifier = "privateTypeOfNumber")]
        pub private_type_of_number: PrivateTypeOfNumber,
        #[rasn(identifier = "privateNumberDigits")]
        pub private_number_digits: NumberDigits,
    }
    impl PrivatePartyNumber {
        pub fn new(
            private_type_of_number: PrivateTypeOfNumber,
            private_number_digits: NumberDigits,
        ) -> Self {
            Self {
                private_type_of_number,
                private_number_digits,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PrivateTypeOfNumber {
        unknown(()),
        level2RegionalNumber(()),
        level1RegionalNumber(()),
        pISNSpecificNumber(()),
        localNumber(()),
        abbreviatedNumber(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Progress-UUIE")]
    #[non_exhaustive]
    pub struct ProgressUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "destinationInfo")]
        pub destination_info: EndpointType,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(identifier = "h245SecurityMode")]
        pub h245_security_mode: Option<H245Security>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
    }
    impl ProgressUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            destination_info: EndpointType,
            h245_address: Option<TransportAddress>,
            call_identifier: CallIdentifier,
            h245_security_mode: Option<H245Security>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
        ) -> Self {
            Self {
                protocol_identifier,
                destination_info,
                h245_address,
                call_identifier,
                h245_security_mode,
                tokens,
                crypto_tokens,
                fast_start,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ProtocolIdentifier(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct PublicPartyNumber {
        #[rasn(identifier = "publicTypeOfNumber")]
        pub public_type_of_number: PublicTypeOfNumber,
        #[rasn(identifier = "publicNumberDigits")]
        pub public_number_digits: NumberDigits,
    }
    impl PublicPartyNumber {
        pub fn new(
            public_type_of_number: PublicTypeOfNumber,
            public_number_digits: NumberDigits,
        ) -> Self {
            Self {
                public_type_of_number,
                public_number_digits,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum PublicTypeOfNumber {
        unknown(()),
        internationalNumber(()),
        nationalNumber(()),
        networkSpecificNumber(()),
        subscriberNumber(()),
        abbreviatedNumber(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct Q954Details {
        #[rasn(identifier = "conferenceCalling")]
        pub conference_calling: bool,
        #[rasn(identifier = "threePartyService")]
        pub three_party_service: bool,
    }
    impl Q954Details {
        pub fn new(conference_calling: bool, three_party_service: bool) -> Self {
            Self {
                conference_calling,
                three_party_service,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct QseriesOptions {
        #[rasn(identifier = "q932Full")]
        pub q932_full: bool,
        #[rasn(identifier = "q951Full")]
        pub q951_full: bool,
        #[rasn(identifier = "q952Full")]
        pub q952_full: bool,
        #[rasn(identifier = "q953Full")]
        pub q953_full: bool,
        #[rasn(identifier = "q955Full")]
        pub q955_full: bool,
        #[rasn(identifier = "q956Full")]
        pub q956_full: bool,
        #[rasn(identifier = "q957Full")]
        pub q957_full: bool,
        #[rasn(identifier = "q954Info")]
        pub q954_info: Q954Details,
    }
    impl QseriesOptions {
        pub fn new(
            q932_full: bool,
            q951_full: bool,
            q952_full: bool,
            q953_full: bool,
            q955_full: bool,
            q956_full: bool,
            q957_full: bool,
            q954_info: Q954Details,
        ) -> Self {
            Self {
                q932_full,
                q951_full,
                q952_full,
                q953_full,
                q955_full,
                q956_full,
                q957_full,
                q954_info,
            }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER", value("1..=255"))]
    pub struct AnonymousRTPSessionAssociatedSessionIds(pub u8);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct RTPSessionAssociatedSessionIds(
        pub SequenceOf<AnonymousRTPSessionAssociatedSessionIds>,
    );
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RTPSession {
        #[rasn(identifier = "rtpAddress")]
        pub rtp_address: TransportChannelInfo,
        #[rasn(identifier = "rtcpAddress")]
        pub rtcp_address: TransportChannelInfo,
        pub cname: PrintableString,
        #[rasn(value("1..=4294967295"))]
        pub ssrc: u32,
        #[rasn(value("1..=255"), identifier = "sessionId")]
        pub session_id: u8,
        #[rasn(identifier = "associatedSessionIds")]
        pub associated_session_ids: RTPSessionAssociatedSessionIds,
    }
    impl RTPSession {
        pub fn new(
            rtp_address: TransportChannelInfo,
            rtcp_address: TransportChannelInfo,
            cname: PrintableString,
            ssrc: u32,
            session_id: u8,
            associated_session_ids: RTPSessionAssociatedSessionIds,
        ) -> Self {
            Self {
                rtp_address,
                rtcp_address,
                cname,
                ssrc,
                session_id,
                associated_session_ids,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RasMessage {
        gatekeeperRequest(GatekeeperRequest),
        gatekeeperConfirm(GatekeeperConfirm),
        gatekeeperReject(GatekeeperReject),
        registrationRequest(RegistrationRequest),
        registrationConfirm(RegistrationConfirm),
        registrationReject(RegistrationReject),
        unregistrationRequest(UnregistrationRequest),
        unregistrationConfirm(UnregistrationConfirm),
        unregistrationReject(UnregistrationReject),
        admissionRequest(AdmissionRequest),
        admissionConfirm(AdmissionConfirm),
        admissionReject(AdmissionReject),
        bandwidthRequest(BandwidthRequest),
        bandwidthConfirm(BandwidthConfirm),
        bandwidthReject(BandwidthReject),
        disengageRequest(DisengageRequest),
        disengageConfirm(DisengageConfirm),
        disengageReject(DisengageReject),
        locationRequest(LocationRequest),
        locationConfirm(LocationConfirm),
        locationReject(LocationReject),
        infoRequest(InfoRequest),
        infoRequestResponse(InfoRequestResponse),
        nonStandardMessage(NonStandardMessage),
        unknownMessageResponse(UnknownMessageResponse),
        #[rasn(extension_addition)]
        requestInProgress(RequestInProgress),
        #[rasn(extension_addition)]
        resourcesAvailableIndicate(ResourcesAvailableIndicate),
        #[rasn(extension_addition)]
        resourcesAvailableConfirm(ResourcesAvailableConfirm),
        #[rasn(extension_addition)]
        infoRequestAck(InfoRequestAck),
        #[rasn(extension_addition)]
        infoRequestNak(InfoRequestNak),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationConfirmPreGrantedARQ {
        #[rasn(identifier = "makeCall")]
        pub make_call: bool,
        #[rasn(identifier = "useGKCallSignalAddressToMakeCall")]
        pub use_gkcall_signal_address_to_make_call: bool,
        #[rasn(identifier = "answerCall")]
        pub answer_call: bool,
        #[rasn(identifier = "useGKCallSignalAddressToAnswer")]
        pub use_gkcall_signal_address_to_answer: bool,
    }
    impl RegistrationConfirmPreGrantedARQ {
        pub fn new(
            make_call: bool,
            use_gkcall_signal_address_to_make_call: bool,
            answer_call: bool,
            use_gkcall_signal_address_to_answer: bool,
        ) -> Self {
            Self {
                make_call,
                use_gkcall_signal_address_to_make_call,
                answer_call,
                use_gkcall_signal_address_to_answer,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "terminalAlias")]
        pub terminal_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        #[rasn(extension_addition, identifier = "alternateGatekeeper")]
        pub alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
        #[rasn(extension_addition, identifier = "timeToLive")]
        pub time_to_live: Option<TimeToLive>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "willRespondToIRR")]
        pub will_respond_to_irr: bool,
        #[rasn(extension_addition, identifier = "preGrantedARQ")]
        pub pre_granted_arq: Option<RegistrationConfirmPreGrantedARQ>,
    }
    impl RegistrationConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            call_signal_address: SequenceOf<TransportAddress>,
            terminal_alias: Option<SequenceOf<AliasAddress>>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            endpoint_identifier: EndpointIdentifier,
            alternate_gatekeeper: Option<SequenceOf<AlternateGK>>,
            time_to_live: Option<TimeToLive>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            will_respond_to_irr: bool,
            pre_granted_arq: Option<RegistrationConfirmPreGrantedARQ>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                call_signal_address,
                terminal_alias,
                gatekeeper_identifier,
                endpoint_identifier,
                alternate_gatekeeper,
                time_to_live,
                tokens,
                crypto_tokens,
                integrity_check_value,
                will_respond_to_irr,
                pre_granted_arq,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: RegistrationRejectReason,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl RegistrationReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            reject_reason: RegistrationRejectReason,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                reject_reason,
                gatekeeper_identifier,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum RegistrationRejectReason {
        discoveryRequired(()),
        invalidRevision(()),
        invalidCallSignalAddress(()),
        invalidRASAddress(()),
        duplicateAlias(SequenceOf<AliasAddress>),
        invalidTerminalType(()),
        undefinedReason(()),
        transportNotSupported(()),
        #[rasn(extension_addition)]
        transportQOSNotSupported(()),
        #[rasn(extension_addition)]
        resourceUnavailable(()),
        #[rasn(extension_addition)]
        invalidAlias(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RegistrationRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "discoveryComplete")]
        pub discovery_complete: bool,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "rasAddress")]
        pub ras_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "terminalType")]
        pub terminal_type: EndpointType,
        #[rasn(identifier = "terminalAlias")]
        pub terminal_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(identifier = "endpointVendor")]
        pub endpoint_vendor: VendorIdentifier,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition, identifier = "timeToLive")]
        pub time_to_live: Option<TimeToLive>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition, identifier = "keepAlive")]
        pub keep_alive: bool,
        #[rasn(extension_addition, identifier = "endpointIdentifier")]
        pub endpoint_identifier: Option<EndpointIdentifier>,
        #[rasn(extension_addition, identifier = "willSupplyUUIEs")]
        pub will_supply_uuies: bool,
    }
    impl RegistrationRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            discovery_complete: bool,
            call_signal_address: SequenceOf<TransportAddress>,
            ras_address: SequenceOf<TransportAddress>,
            terminal_type: EndpointType,
            terminal_alias: Option<SequenceOf<AliasAddress>>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            endpoint_vendor: VendorIdentifier,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            time_to_live: Option<TimeToLive>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            keep_alive: bool,
            endpoint_identifier: Option<EndpointIdentifier>,
            will_supply_uuies: bool,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                discovery_complete,
                call_signal_address,
                ras_address,
                terminal_type,
                terminal_alias,
                gatekeeper_identifier,
                endpoint_vendor,
                alternate_endpoints,
                time_to_live,
                tokens,
                crypto_tokens,
                integrity_check_value,
                keep_alive,
                endpoint_identifier,
                will_supply_uuies,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "ReleaseComplete-UUIE")]
    #[non_exhaustive]
    pub struct ReleaseCompleteUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        pub reason: Option<ReleaseCompleteReason>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
    }
    impl ReleaseCompleteUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            reason: Option<ReleaseCompleteReason>,
            call_identifier: CallIdentifier,
        ) -> Self {
            Self {
                protocol_identifier,
                reason,
                call_identifier,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum ReleaseCompleteReason {
        noBandwidth(()),
        gatekeeperResources(()),
        unreachableDestination(()),
        destinationRejection(()),
        invalidRevision(()),
        noPermission(()),
        unreachableGatekeeper(()),
        gatewayResources(()),
        badFormatAddress(()),
        adaptiveBusy(()),
        inConf(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        facilityCallDeflection(()),
        #[rasn(extension_addition)]
        securityDenied(()),
        #[rasn(extension_addition)]
        calledPartyNotRegistered(()),
        #[rasn(extension_addition)]
        callerNotRegistered(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct RequestInProgress {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(value("1..=65535"))]
        pub delay: u16,
    }
    impl RequestInProgress {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            delay: u16,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
                delay,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=65535"))]
    pub struct RequestSeqNum(pub u16);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ResourcesAvailableConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl ResourcesAvailableConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct ResourcesAvailableIndicate {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: EndpointIdentifier,
        pub protocols: SequenceOf<SupportedProtocols>,
        #[rasn(identifier = "almostOutOfResources")]
        pub almost_out_of_resources: bool,
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl ResourcesAvailableIndicate {
        pub fn new(
            request_seq_num: RequestSeqNum,
            protocol_identifier: ProtocolIdentifier,
            non_standard_data: Option<NonStandardParameter>,
            endpoint_identifier: EndpointIdentifier,
            protocols: SequenceOf<SupportedProtocols>,
            almost_out_of_resources: bool,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                protocol_identifier,
                non_standard_data,
                endpoint_identifier,
                protocols,
                almost_out_of_resources,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SecurityCapabilities {
        #[rasn(identifier = "nonStandard")]
        pub non_standard: Option<NonStandardParameter>,
        pub encryption: SecurityServiceMode,
        pub authenticaton: SecurityServiceMode,
        pub integrity: SecurityServiceMode,
    }
    impl SecurityCapabilities {
        pub fn new(
            non_standard: Option<NonStandardParameter>,
            encryption: SecurityServiceMode,
            authenticaton: SecurityServiceMode,
            integrity: SecurityServiceMode,
        ) -> Self {
            Self {
                non_standard,
                encryption,
                authenticaton,
                integrity,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum SecurityServiceMode {
        nonStandard(NonStandardParameter),
        none(()),
        default(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum SetupUUIEConferenceGoal {
        create(()),
        join(()),
        invite(()),
        #[rasn(extension_addition, identifier = "capability-negotiation")]
        capability_negotiation(()),
        #[rasn(extension_addition)]
        callIndependentSupplementaryService(()),
    }
    #[doc = " used by gatekeeper when endpoint has"]
    #[doc = " preGrantedARQ to bypass ARQ/ACF"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags, identifier = "Setup-UUIE")]
    #[non_exhaustive]
    pub struct SetupUUIE {
        #[rasn(identifier = "protocolIdentifier")]
        pub protocol_identifier: ProtocolIdentifier,
        #[rasn(identifier = "h245Address")]
        pub h245_address: Option<TransportAddress>,
        #[rasn(identifier = "sourceAddress")]
        pub source_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "sourceInfo")]
        pub source_info: EndpointType,
        #[rasn(identifier = "destinationAddress")]
        pub destination_address: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "destCallSignalAddress")]
        pub dest_call_signal_address: Option<TransportAddress>,
        #[rasn(identifier = "destExtraCallInfo")]
        pub dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "destExtraCRV")]
        pub dest_extra_crv: Option<SequenceOf<CallReferenceValue>>,
        #[rasn(identifier = "activeMC")]
        pub active_mc: bool,
        #[rasn(identifier = "conferenceID")]
        pub conference_id: ConferenceIdentifier,
        #[rasn(identifier = "conferenceGoal")]
        pub conference_goal: SetupUUIEConferenceGoal,
        #[rasn(identifier = "callServices")]
        pub call_services: Option<QseriesOptions>,
        #[rasn(identifier = "callType")]
        pub call_type: CallType,
        #[rasn(extension_addition, identifier = "sourceCallSignalAddress")]
        pub source_call_signal_address: Option<TransportAddress>,
        #[rasn(extension_addition, identifier = "remoteExtensionAddress")]
        pub remote_extension_address: Option<AliasAddress>,
        #[rasn(extension_addition, identifier = "callIdentifier")]
        pub call_identifier: CallIdentifier,
        #[rasn(extension_addition, identifier = "h245SecurityCapability")]
        pub h245_security_capability: Option<SequenceOf<H245Security>>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "fastStart")]
        pub fast_start: Option<SequenceOf<OctetString>>,
        #[rasn(extension_addition, identifier = "mediaWaitForConnect")]
        pub media_wait_for_connect: bool,
        #[rasn(extension_addition, identifier = "canOverlapSend")]
        pub can_overlap_send: bool,
    }
    impl SetupUUIE {
        pub fn new(
            protocol_identifier: ProtocolIdentifier,
            h245_address: Option<TransportAddress>,
            source_address: Option<SequenceOf<AliasAddress>>,
            source_info: EndpointType,
            destination_address: Option<SequenceOf<AliasAddress>>,
            dest_call_signal_address: Option<TransportAddress>,
            dest_extra_call_info: Option<SequenceOf<AliasAddress>>,
            dest_extra_crv: Option<SequenceOf<CallReferenceValue>>,
            active_mc: bool,
            conference_id: ConferenceIdentifier,
            conference_goal: SetupUUIEConferenceGoal,
            call_services: Option<QseriesOptions>,
            call_type: CallType,
            source_call_signal_address: Option<TransportAddress>,
            remote_extension_address: Option<AliasAddress>,
            call_identifier: CallIdentifier,
            h245_security_capability: Option<SequenceOf<H245Security>>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            fast_start: Option<SequenceOf<OctetString>>,
            media_wait_for_connect: bool,
            can_overlap_send: bool,
        ) -> Self {
            Self {
                protocol_identifier,
                h245_address,
                source_address,
                source_info,
                destination_address,
                dest_call_signal_address,
                dest_extra_call_info,
                dest_extra_crv,
                active_mc,
                conference_id,
                conference_goal,
                call_services,
                call_type,
                source_call_signal_address,
                remote_extension_address,
                call_identifier,
                h245_security_capability,
                tokens,
                crypto_tokens,
                fast_start,
                media_wait_for_connect,
                can_overlap_send,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct SupportedPrefix {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        pub prefix: AliasAddress,
    }
    impl SupportedPrefix {
        pub fn new(non_standard_data: Option<NonStandardParameter>, prefix: AliasAddress) -> Self {
            Self {
                non_standard_data,
                prefix,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum SupportedProtocols {
        nonStandardData(NonStandardParameter),
        h310(H310Caps),
        h320(H320Caps),
        h321(H321Caps),
        h322(H322Caps),
        h323(H323Caps),
        h324(H324Caps),
        voice(VoiceCaps),
        #[rasn(identifier = "t120-only")]
        t120_only(T120OnlyCaps),
        #[rasn(extension_addition)]
        nonStandardProtocol(NonStandardProtocol),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct T120OnlyCaps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl T120OnlyCaps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TerminalInfo {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
    }
    impl TerminalInfo {
        pub fn new(non_standard_data: Option<NonStandardParameter>) -> Self {
            Self { non_standard_data }
        }
    }
    #[doc = " shall be set to"]
    #[doc = " {itu-t (0) recommendation (0) h (8) 2250"]
    #[doc = " version (0) 2}"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("1..=4294967295"))]
    pub struct TimeToLive(pub u32);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct TransportAddressIpAddress {
        #[rasn(size("4"))]
        pub ip: OctetString,
        #[rasn(value("0..=65535"))]
        pub port: u16,
    }
    impl TransportAddressIpAddress {
        pub fn new(ip: OctetString, port: u16) -> Self {
            Self { ip, port }
        }
    }
    #[doc = " Anonymous SEQUENCE OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "OCTET_STRING")]
    pub struct AnonymousTransportAddressIpSourceRouteRoute(pub FixedOctetString<4usize>);
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct TransportAddressIpSourceRouteRoute(
        pub SequenceOf<AnonymousTransportAddressIpSourceRouteRoute>,
    );
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TransportAddressIpSourceRouteRouting {
        strict(()),
        loose(()),
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TransportAddressIpSourceRoute {
        #[rasn(size("4"))]
        pub ip: OctetString,
        #[rasn(value("0..=65535"))]
        pub port: u16,
        pub route: TransportAddressIpSourceRouteRoute,
        pub routing: TransportAddressIpSourceRouteRouting,
    }
    impl TransportAddressIpSourceRoute {
        pub fn new(
            ip: OctetString,
            port: u16,
            route: TransportAddressIpSourceRouteRoute,
            routing: TransportAddressIpSourceRouteRouting,
        ) -> Self {
            Self {
                ip,
                port,
                route,
                routing,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    pub struct TransportAddressIpxAddress {
        #[rasn(size("6"))]
        pub node: OctetString,
        #[rasn(size("4"))]
        pub netnum: OctetString,
        #[rasn(size("2"))]
        pub port: OctetString,
    }
    impl TransportAddressIpxAddress {
        pub fn new(node: OctetString, netnum: OctetString, port: OctetString) -> Self {
            Self { node, netnum, port }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TransportAddressIp6Address {
        #[rasn(size("16"))]
        pub ip: OctetString,
        #[rasn(value("0..=65535"))]
        pub port: u16,
    }
    impl TransportAddressIp6Address {
        pub fn new(ip: OctetString, port: u16) -> Self {
            Self { ip, port }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TransportAddress {
        ipAddress(TransportAddressIpAddress),
        ipSourceRoute(TransportAddressIpSourceRoute),
        ipxAddress(TransportAddressIpxAddress),
        ip6Address(TransportAddressIp6Address),
        #[rasn(size("16"))]
        netBios(OctetString),
        #[rasn(size("1..=20"))]
        nsap(OctetString),
        nonStandardAddress(NonStandardParameter),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct TransportChannelInfo {
        #[rasn(identifier = "sendAddress")]
        pub send_address: Option<TransportAddress>,
        #[rasn(identifier = "recvAddress")]
        pub recv_address: Option<TransportAddress>,
    }
    impl TransportChannelInfo {
        pub fn new(
            send_address: Option<TransportAddress>,
            recv_address: Option<TransportAddress>,
        ) -> Self {
            Self {
                send_address,
                recv_address,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum TransportQOS {
        endpointControlled(()),
        gatekeeperControlled(()),
        noControl(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UUIEsRequested {
        pub setup: bool,
        #[rasn(identifier = "callProceeding")]
        pub call_proceeding: bool,
        pub connect: bool,
        pub alerting: bool,
        #[rasn(identifier = "userInformation")]
        pub user_information: bool,
        #[rasn(identifier = "releaseComplete")]
        pub release_complete: bool,
        pub facility: bool,
        pub progress: bool,
        pub empty: bool,
    }
    impl UUIEsRequested {
        pub fn new(
            setup: bool,
            call_proceeding: bool,
            connect: bool,
            alerting: bool,
            user_information: bool,
            release_complete: bool,
            facility: bool,
            progress: bool,
            empty: bool,
        ) -> Self {
            Self {
                setup,
                call_proceeding,
                connect,
                alerting,
                user_information,
                release_complete,
                facility,
                progress,
                empty,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnknownMessageResponse {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl UnknownMessageResponse {
        pub fn new(
            request_seq_num: RequestSeqNum,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UnregRejectReason {
        notCurrentlyRegistered(()),
        callInProgress(()),
        undefinedReason(()),
        #[rasn(extension_addition)]
        permissionDenied(()),
        #[rasn(extension_addition)]
        securityDenial(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice, automatic_tags)]
    #[non_exhaustive]
    pub enum UnregRequestReason {
        reregistrationRequired(()),
        ttlExpired(()),
        securityDenial(()),
        undefinedReason(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnregistrationConfirm {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl UnregistrationConfirm {
        pub fn new(
            request_seq_num: RequestSeqNum,
            non_standard_data: Option<NonStandardParameter>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                non_standard_data,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnregistrationReject {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "rejectReason")]
        pub reject_reason: UnregRejectReason,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "altGKInfo")]
        pub alt_gkinfo: Option<AltGKInfo>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
    }
    impl UnregistrationReject {
        pub fn new(
            request_seq_num: RequestSeqNum,
            reject_reason: UnregRejectReason,
            non_standard_data: Option<NonStandardParameter>,
            alt_gkinfo: Option<AltGKInfo>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
        ) -> Self {
            Self {
                request_seq_num,
                reject_reason,
                non_standard_data,
                alt_gkinfo,
                tokens,
                crypto_tokens,
                integrity_check_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct UnregistrationRequest {
        #[rasn(identifier = "requestSeqNum")]
        pub request_seq_num: RequestSeqNum,
        #[rasn(identifier = "callSignalAddress")]
        pub call_signal_address: SequenceOf<TransportAddress>,
        #[rasn(identifier = "endpointAlias")]
        pub endpoint_alias: Option<SequenceOf<AliasAddress>>,
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(identifier = "endpointIdentifier")]
        pub endpoint_identifier: Option<EndpointIdentifier>,
        #[rasn(extension_addition, identifier = "alternateEndpoints")]
        pub alternate_endpoints: Option<SequenceOf<Endpoint>>,
        #[rasn(extension_addition, identifier = "gatekeeperIdentifier")]
        pub gatekeeper_identifier: Option<GatekeeperIdentifier>,
        #[rasn(extension_addition)]
        pub tokens: Option<SequenceOf<ClearToken>>,
        #[rasn(extension_addition, identifier = "cryptoTokens")]
        pub crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
        #[rasn(extension_addition, identifier = "integrityCheckValue")]
        pub integrity_check_value: Option<ICV>,
        #[rasn(extension_addition)]
        pub reason: Option<UnregRequestReason>,
    }
    impl UnregistrationRequest {
        pub fn new(
            request_seq_num: RequestSeqNum,
            call_signal_address: SequenceOf<TransportAddress>,
            endpoint_alias: Option<SequenceOf<AliasAddress>>,
            non_standard_data: Option<NonStandardParameter>,
            endpoint_identifier: Option<EndpointIdentifier>,
            alternate_endpoints: Option<SequenceOf<Endpoint>>,
            gatekeeper_identifier: Option<GatekeeperIdentifier>,
            tokens: Option<SequenceOf<ClearToken>>,
            crypto_tokens: Option<SequenceOf<CryptoH323Token>>,
            integrity_check_value: Option<ICV>,
            reason: Option<UnregRequestReason>,
        ) -> Self {
            Self {
                request_seq_num,
                call_signal_address,
                endpoint_alias,
                non_standard_data,
                endpoint_identifier,
                alternate_endpoints,
                gatekeeper_identifier,
                tokens,
                crypto_tokens,
                integrity_check_value,
                reason,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(automatic_tags)]
    #[non_exhaustive]
    pub struct VoiceCaps {
        #[rasn(identifier = "nonStandardData")]
        pub non_standard_data: Option<NonStandardParameter>,
        #[rasn(extension_addition, identifier = "dataRatesSupported")]
        pub data_rates_supported: Option<SequenceOf<DataRate>>,
        #[rasn(extension_addition, identifier = "supportedPrefixes")]
        pub supported_prefixes: SequenceOf<SupportedPrefix>,
    }
    impl VoiceCaps {
        pub fn new(
            non_standard_data: Option<NonStandardParameter>,
            data_rates_supported: Option<SequenceOf<DataRate>>,
            supported_prefixes: SequenceOf<SupportedPrefix>,
        ) -> Self {
            Self {
                non_standard_data,
                data_rates_supported,
                supported_prefixes,
            }
        }
    }
}
