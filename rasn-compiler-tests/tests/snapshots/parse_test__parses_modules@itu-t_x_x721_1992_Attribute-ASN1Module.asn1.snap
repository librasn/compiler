---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x721_1992_Attribute-ASN1Module.asn1
---
Warnings:
Unidentified generating bindings for : Unexpectedly encountered unlinked struct-like ASN1 value!
Unidentified generating bindings for : A type name is needed to stringify sequence value LinkedStructLikeValue([("intervalStart", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "Time24", constraints: [] }), Explicit(LinkedNestedValue { supertypes: ["Time24"], value: LinkedStructLikeValue([("hour", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(23)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint8, value: 0 })), ("minute", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(59)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint8, value: 0 }))]) })), ("intervalEnd", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "Time24", constraints: [] }), Explicit(LinkedNestedValue { supertypes: ["Time24"], value: LinkedStructLikeValue([("hour", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(23)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint8, value: 23 })), ("minute", Integer(Integer { constraints: [Subtype(ElementSetSpecs { set: Element(ValueRange { min: Some(Integer(0)), max: Some(Integer(59)), extensible: false }), extensible: false })], distinguished_values: None }), Explicit(LinkedIntValue { integer_type: Uint8, value: 59 }))]) }))])
Unidentified generating bindings for : A type name is needed to stringify sequence value LinkedStructLikeValue([("daysOfWeek", BitString(BitString { constraints: [Subtype(ElementSetSpecs { set: Element(SizeConstraint(Element(SingleValue { value: Integer(7), extensible: false }))), extensible: false })], distinguished_values: Some([DistinguishedValue { name: "sunday", value: 0 }, DistinguishedValue { name: "monday", value: 1 }, DistinguishedValue { name: "tuesday", value: 2 }, DistinguishedValue { name: "wednesday", value: 3 }, DistinguishedValue { name: "thursday", value: 4 }, DistinguishedValue { name: "friday", value: 5 }, DistinguishedValue { name: "saturday", value: 6 }]) }), Explicit(BitString([true, true, true, true, true, true, true]))), ("intervalsOfDay", ElsewhereDeclaredType(DeclarationElsewhere { parent: None, module: None, identifier: "IntervalsOfDay", constraints: [] }), Explicit(LinkedElsewhereDefinedValue { parent: None, identifier: "defaultIntervalsOfDay", can_be_const: false }))])
LinkerError in ASN grammar: Failed to link value with 'CMISFilter'


Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod attribute_asn1_module {
    extern crate alloc;
    use super::acse_1::AETitle;
    use super::cmip_1::*;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " supporting productions"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ActiveDestination(pub Destination);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AdditionalInformation(pub SetOf<ManagementExtension>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AdditionalText(pub GraphicString);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum AdministrativeState {
        locked = 0,
        unlocked = 1,
        shuttingDown = 2,
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER")]
    pub struct AnonymousAlarmStatus(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AlarmStatus(pub SetOf<AnonymousAlarmStatus>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Allomorphs(pub SetOf<ObjectClass>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeIdentifierList(pub SetOf<AttributeId>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeList(pub SetOf<Attribute>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousAttributeValueChangeDefinition {
        #[rasn(identifier = "attributeId")]
        pub attribute_id: Any,
        #[rasn(tag(context, 1), identifier = "oldAttributeValue")]
        pub old_attribute_value: Option<Any>,
        #[rasn(tag(context, 2), identifier = "newAttributeValue")]
        pub new_attribute_value: Any,
    }
    impl AnonymousAttributeValueChangeDefinition {
        pub fn new(
            attribute_id: Any,
            old_attribute_value: Option<Any>,
            new_attribute_value: Any,
        ) -> Self {
            Self {
                attribute_id,
                old_attribute_value,
                new_attribute_value,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AttributeValueChangeDefinition(pub SetOf<AnonymousAttributeValueChangeDefinition>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER")]
    pub struct AnonymousAvailabilityStatus(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct AvailabilityStatus(pub SetOf<AnonymousAvailabilityStatus>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct BackUpDestinationList(pub SequenceOf<AETitle>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum BackUpRelationshipObject {
        objectName(ObjectInstance),
        noObject(()),
    }
    #[doc = " logFull is defined in CCITT Rec X.735 | ISO/IEC 10164-6."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct BackedUpStatus(pub bool);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER", value("0..=100"))]
    pub struct AnonymousCapacityAlarmThreshold(pub u8);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CapacityAlarmThreshold(pub SetOf<AnonymousCapacityAlarmThreshold>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct ConfirmedMode(pub bool);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER")]
    pub struct AnonymousControlStatus(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ControlStatus(pub SetOf<AnonymousControlStatus>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousCorrelatedNotifications {
        #[rasn(identifier = "correlatedNotifications")]
        pub correlated_notifications: SetOf<NotificationIdentifier>,
        #[rasn(identifier = "sourceObjectInst")]
        pub source_object_inst: Option<ObjectInstance>,
    }
    impl AnonymousCorrelatedNotifications {
        pub fn new(
            correlated_notifications: SetOf<NotificationIdentifier>,
            source_object_inst: Option<ObjectInstance>,
        ) -> Self {
            Self {
                correlated_notifications,
                source_object_inst,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CorrelatedNotifications(pub SetOf<AnonymousCorrelatedNotifications>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Count(pub Integer);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousCounterThreshold {
        #[rasn(identifier = "comparisonLevel")]
        pub comparison_level: Integer,
        #[rasn(identifier = "offsetValue")]
        pub offset_value: Integer,
        #[rasn(identifier = "notificationOnOff")]
        pub notification_on_off: bool,
    }
    impl AnonymousCounterThreshold {
        pub fn new(
            comparison_level: Integer,
            offset_value: Integer,
            notification_on_off: bool,
        ) -> Self {
            Self {
                comparison_level,
                offset_value,
                notification_on_off,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CounterThreshold(pub SetOf<AnonymousCounterThreshold>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct CurrentLogSize(pub Integer);
    #[doc = " size in octets"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "DMI-EXTENSION")]
    pub struct DMIEXTENSION(pub DMITYPEIDENTIFIER);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "DMI-SERVICEUSER")]
    pub struct DMISERVICEUSER(pub DMITYPEIDENTIFIER);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "DMI-SUPPORTEDFEATURES")]
    pub struct DMISUPPORTEDFEATURES(pub DMITYPEIDENTIFIER);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum Destination {
        single(AETitle),
        multiple(SetOf<AETitle>),
    }
    #[doc = " Note that the syntax of AE-title to be used is from CCITT X.227 | ISO 8650 Technical"]
    #[doc = " corrigendum 1 and not \"ANY\"."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct DiscriminatorConstruct(pub CMISFilter);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct EventTime(pub GeneralizedTime);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousGaugeThreshold {
        #[rasn(identifier = "notifyLow")]
        pub notify_low: NotifyThreshold,
        #[rasn(identifier = "notifyHigh")]
        pub notify_high: NotifyThreshold,
    }
    impl AnonymousGaugeThreshold {
        pub fn new(notify_low: NotifyThreshold, notify_high: NotifyThreshold) -> Self {
            Self {
                notify_low,
                notify_high,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GaugeThreshold(pub SetOf<AnonymousGaugeThreshold>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GaugeThresholdValue(pub ObservedValue);
    #[doc = " same choice must be chosen within a sequence"]
    #[doc = " for both GenericOldState and GenericNewState."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct GroupObjects(pub SetOf<ObjectInstance>);
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousIntervalsOfDay {
        #[rasn(identifier = "intervalStart")]
        pub interval_start: Time24,
        #[rasn(identifier = "intervalEnd")]
        pub interval_end: Time24,
    }
    impl AnonymousIntervalsOfDay {
        pub fn new(interval_start: Time24, interval_end: Time24) -> Self {
            Self {
                interval_start,
                interval_end,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct IntervalsOfDay(pub SetOf<AnonymousIntervalsOfDay>);
    #[doc = " stop at the end of this minute"]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum LifecycleState {
        planned = 0,
        installed = 1,
        pendingRemoval = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct LogAvailability(pub AvailabilityStatus);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum LogFullAction {
        wrap = 0,
        halt = 1,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct LogRecordId(pub SimpleNameType);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct LoggingTime(pub GeneralizedTime);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ManagementExtension {
        pub identifier: Any,
        #[rasn(tag(context, 1), default = "management_extension_significance_default")]
        pub significance: bool,
        #[rasn(tag(context, 2))]
        pub information: Any,
    }
    impl ManagementExtension {
        pub fn new(identifier: Any, significance: bool, information: Any) -> Self {
            Self {
                identifier,
                significance,
                information,
            }
        }
    }
    fn management_extension_significance_default() -> bool {
        false
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct MaxLogSize(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct MonitoredAttributes(pub SetOf<Attribute>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct NameBinding(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct NotificationIdentifier(pub Integer);
    #[doc = " reuse only when no requirement exists"]
    #[doc = " for correlating prior notification."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct NotifyThreshold {
        pub threshold: ObservedValue,
        #[rasn(identifier = "notifyOnOff")]
        pub notify_on_off: bool,
    }
    impl NotifyThreshold {
        pub fn new(threshold: ObservedValue, notify_on_off: bool) -> Self {
            Self {
                threshold,
                notify_on_off,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct NumberOfRecords(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ObservedValue {
        integer(Integer),
        real(f64),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum OperationalState {
        disabled = 0,
        enabled = 1,
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "OBJECT_IDENTIFIER")]
    pub struct AnonymousPackages(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct Packages(pub SetOf<AnonymousPackages>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum PerceivedSeverity {
        indeterminate = 0,
        critical = 1,
        major = 2,
        minor = 3,
        warning = 4,
        cleared = 5,
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousPrioritisedObject {
        pub object: ObjectInstance,
        pub priority: Integer,
    }
    impl AnonymousPrioritisedObject {
        pub fn new(object: ObjectInstance, priority: Integer) -> Self {
            Self { object, priority }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct PrioritisedObject(pub SetOf<AnonymousPrioritisedObject>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ProbableCause {
        globalValue(ObjectIdentifier),
        localValue(Integer),
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, identifier = "INTEGER")]
    pub struct AnonymousProceduralStatus(pub Integer);
    #[doc = " The values for the probable cause defined in CCITT Rec X.733 | ISO/IEC 10164-4 are specified"]
    #[doc = " above."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ProceduralStatus(pub SetOf<AnonymousProceduralStatus>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ProposedRepairActions(pub SetOf<SpecificIdentifier>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SchedulingAvailability(pub AvailabilityStatus);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SecurityAlarmCause(pub ObjectIdentifier);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum SecurityAlarmDetector {
        #[rasn(tag(context, 0))]
        mechanism(ObjectIdentifier),
        #[rasn(tag(context, 1))]
        object(ObjectInstance),
        #[rasn(tag(context, 2))]
        application(AETitle),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate, value("0..=4"))]
    pub struct SecurityAlarmSeverity(pub PerceivedSeverity);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ServiceProvider(pub ServiceUser);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ServiceUser {
        pub identifier: Any,
        pub details: Any,
    }
    impl ServiceUser {
        pub fn new(identifier: Any, details: Any) -> Self {
            Self {
                identifier,
                details,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum SimpleNameType {
        number(Integer),
        string(GraphicString),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum SourceIndicator {
        resourceOperation = 0,
        managementOperation = 1,
        unknown = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum SpecificIdentifier {
        oi(ObjectIdentifier),
        int(Integer),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SpecificProblems(pub SetOf<SpecificIdentifier>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct StandbyStatus(pub Integer);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct StartTime(pub GeneralizedTime);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum StopTime {
        specific(GeneralizedTime),
        continual(()),
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousSupportedFeatures {
        #[rasn(identifier = "featureIdentifier")]
        pub feature_identifier: Any,
        #[rasn(identifier = "featureInfo")]
        pub feature_info: Any,
    }
    impl AnonymousSupportedFeatures {
        pub fn new(feature_identifier: Any, feature_info: Any) -> Self {
            Self {
                feature_identifier,
                feature_info,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct SupportedFeatures(pub SetOf<AnonymousSupportedFeatures>);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum SystemId {
        name(GraphicString),
        number(Integer),
        nothing(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum SystemTitle {
        distinguishedName(DistinguishedName),
        oid(ObjectIdentifier),
        nothing(()),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ThresholdInfo {
        #[rasn(identifier = "triggeredThreshold")]
        pub triggered_threshold: AttributeId,
        #[rasn(identifier = "observedValue")]
        pub observed_value: ObservedValue,
        #[rasn(tag(context, 1), identifier = "thresholdLevel")]
        pub threshold_level: Option<ThresholdLevelInd>,
        #[rasn(tag(context, 2), identifier = "armTime")]
        pub arm_time: Option<GeneralizedTime>,
    }
    impl ThresholdInfo {
        pub fn new(
            triggered_threshold: AttributeId,
            observed_value: ObservedValue,
            threshold_level: Option<ThresholdLevelInd>,
            arm_time: Option<GeneralizedTime>,
        ) -> Self {
            Self {
                triggered_threshold,
                observed_value,
                threshold_level,
                arm_time,
            }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ThresholdLevelIndUp {
        pub high: ObservedValue,
        pub low: Option<ObservedValue>,
    }
    impl ThresholdLevelIndUp {
        pub fn new(high: ObservedValue, low: Option<ObservedValue>) -> Self {
            Self { high, low }
        }
    }
    #[doc = " Inner type "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct ThresholdLevelIndDown {
        pub high: ObservedValue,
        pub low: ObservedValue,
    }
    impl ThresholdLevelIndDown {
        pub fn new(high: ObservedValue, low: ObservedValue) -> Self {
            Self { high, low }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum ThresholdLevelInd {
        #[rasn(tag(context, 1))]
        up(ThresholdLevelIndUp),
        #[rasn(tag(context, 2))]
        down(ThresholdLevelIndDown),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(choice)]
    pub enum TideMark {
        #[rasn(tag(context, 0))]
        maxTideMar(ObservedValue),
        #[rasn(tag(context, 1))]
        minTideMark(ObservedValue),
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct TideMarkInfo {
        #[rasn(identifier = "currentTideMark")]
        pub current_tide_mark: TideMark,
        #[rasn(identifier = "previousTideMark")]
        pub previous_tide_mark: TideMark,
        #[rasn(identifier = "resetTime")]
        pub reset_time: GeneralizedTime,
    }
    impl TideMarkInfo {
        pub fn new(
            current_tide_mark: TideMark,
            previous_tide_mark: TideMark,
            reset_time: GeneralizedTime,
        ) -> Self {
            Self {
                current_tide_mark,
                previous_tide_mark,
                reset_time,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    pub struct Time24 {
        #[rasn(value("0..=23"))]
        pub hour: u8,
        #[rasn(value("0..=59"))]
        pub minute: u8,
    }
    impl Time24 {
        pub fn new(hour: u8, minute: u8) -> Self {
            Self { hour, minute }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum TrendIndication {
        lessSevere = 0,
        noChange = 1,
        moreSevere = 2,
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(delegate)]
    pub struct UnknownStatus(pub bool);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct UnscheduledLogAvailability(pub AvailabilityStatus);
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash, Copy)]
    #[rasn(enumerated)]
    pub enum UsageState {
        idle = 0,
        active = 1,
        busy = 2,
    }
    #[doc = " Anonymous SET OF member "]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(identifier = "SEQUENCE")]
    pub struct AnonymousWeekMask {
        #[rasn(size("7"), identifier = "daysOfWeek")]
        pub days_of_week: BitString,
        #[rasn(identifier = "intervalsOfDay")]
        pub intervals_of_day: IntervalsOfDay,
    }
    impl AnonymousWeekMask {
        pub fn new(days_of_week: BitString, intervals_of_day: IntervalsOfDay) -> Self {
            Self {
                days_of_week,
                intervals_of_day,
            }
        }
    }
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct WeekMask(pub SetOf<AnonymousWeekMask>);
    pub static ADAPTER_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[1u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static APPLICATION_SUBSYSTEM_FAILURE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[2u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    #[doc = " The value assignments for the probable cause used in CCITT Rec. X.733 | ISO/IEC 10164-4 are specified"]
    #[doc = " below."]
    #[doc = " These are specified in accordance with the corrigendum to ASN.1 ISO/IEC JTC1/SC21 N5901"]
    pub static ARF_PROBABLE_CAUSE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 3u32, 2u32, 0u32, 0u32]).to_owned());
    #[doc = " The following applies to CCITT applications only."]
    #[doc = " The use of the following values is subject to 8.1.2.12 of The Alarm Management Function"]
    #[doc = " (CCITT Recommendation X.733 | 10164-4)."]
    pub static ARF_PROPOSED_REPAIR_ACTION: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 3u32, 2u32, 0u32, 2u32]).to_owned());
    pub static AUTHENTICATION_FAILURE: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[1u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static BANDWIDTH_REDUCED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[3u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static BREACH_OF_CONFIDENTIALITY: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[2u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static CABLE_TAMPER: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[3u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static CALL_ESTABLISHMENT_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[4u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static COMMUNICATIONS_PROTOCOL_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[5u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static COMMUNICATIONS_SUBSYSTEM_FAILURE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[6u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static CONFIGURATION_OR_CUSTOMIZATION_ERROR: LazyLock<ProbableCause> =
        LazyLock::new(|| {
            ProbableCause::globalValue(
                Oid::new(&[&***ARF_PROBABLE_CAUSE, &[7u32]].concat())
                    .unwrap()
                    .to_owned(),
            )
        });
    pub static CONGESTION: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[8u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static CORRUPT_DATA: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[9u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static CPU_CYCLES_LIMIT_EXCEEDED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[10u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static D_TE_DCEINTERFACE_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[13u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static DATA_SET_OR_MODEM_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[11u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub const DEFAULT_STOP_TIME: StopTime = StopTime::continual(());
    pub static DEGRADED_SIGNAL: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[12u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static DELAYED_INFORMATION: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[4u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static DENIAL_OF_SERVICE: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[5u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static DUPLICATE_INFORMATION: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[6u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static ENCLOSURE_DOOR_OPEN: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[14u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static EQUIPMENT_MALFUNCTION: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[15u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static EXCESSIVE_VIBRATION: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[16u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static FILE_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[17u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static FIRE_DETECTED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[18u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static FLOOD_DETECTED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[19u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static FRAMING_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[20u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static HEATING_OR_VENTILATION_OR_COOLING_SYSTEM_PROBLEM: LazyLock<ProbableCause> =
        LazyLock::new(|| {
            ProbableCause::globalValue(
                Oid::new(&[&***ARF_PROBABLE_CAUSE, &[21u32]].concat())
                    .unwrap()
                    .to_owned(),
            )
        });
    pub static HUMIDITY_UNACCEPTABLE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[22u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static INFORMATION_MISSING: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[7u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static INFORMATION_MODIFICATION_DETECTED: LazyLock<SecurityAlarmCause> =
        LazyLock::new(|| {
            SecurityAlarmCause(
                Oid::new(&[&***SECURITY_ALARM_CAUSE, &[8u32]].concat())
                    .unwrap()
                    .to_owned(),
            )
        });
    pub static INFORMATION_OUT_OF_SEQUENCE: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[9u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static INPUT_DEVICE_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[24u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static INPUT_OUTPUT_DEVICE_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[23u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static INTRUSION_DETECTION: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[10u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static KEY_EXPIRED: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[11u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static L_ANERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[25u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static LEAK_DETECTED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[26u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static LOCAL_NODE_TRANSMISSION_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[27u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static LOSS_OF_FRAME: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[28u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static LOSS_OF_SIGNAL: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[29u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static MATERIAL_SUPPLY_EXHAUSTED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[30u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static MULTIPLEXER_PROBLEM: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[31u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static NO_ACTION_REQUIRED: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ARF_PROPOSED_REPAIR_ACTION, &[1u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static NON_REPUDIATION_FAILURE: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[12u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static OUPUT_DEVICE_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[33u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static OUT_OF_HOURS_ACTIVITY: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[13u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static OUT_OF_MEMORY: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[32u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static OUT_OF_SERVICE: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[14u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static PERFORMANCE_DEGRADED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[34u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static POWER_PROBLEM: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[35u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static PRESSURE_UNACCEPTABLE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[36u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static PROCEDURAL_ERROR: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[15u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static PROCESSOR_PROBLEM: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[37u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static PUMP_FAILURE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[38u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static QUEUE_SIZE_EXCEEDED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[39u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static RECEIVE_FAILURE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[40u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static RECEIVER_FAILURE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[41u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static REMOTE_NODE_TRANSMISSION_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[42u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static REPAIR_ACTION_REQUIRED: LazyLock<ObjectIdentifier> = LazyLock::new(|| {
        Oid::new(&[&***ARF_PROPOSED_REPAIR_ACTION, &[2u32]].concat())
            .unwrap()
            .to_owned()
    });
    pub static RESOURCE_AT_OR_NEARING_CAPACITY: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[43u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static RESPONSE_TIME_EXCESSIVE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[44u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static RETRANSMISSION_RATE_EXCESSIVE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[45u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    #[doc = " The value assignments for the security alarm cause used in CCITT Rec. X.736 | ISO/IEC 10164-7 are"]
    #[doc = " specified below."]
    pub static SECURITY_ALARM_CAUSE: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 3u32, 2u32, 0u32, 1u32]).to_owned());
    pub static SMI2_ATTRIBUTE_GROUP: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 3u32, 2u32, 8u32]).to_owned());
    #[doc = " Note that the syntax of AE-title to be used is from CCITT Rec. X.227 | ISO 8650 corrigendum and"]
    #[doc = " not \"ANY\"."]
    pub static SMI2_ATTRIBUTE_ID: LazyLock<ObjectIdentifier> =
        LazyLock::new(|| Oid::const_new(&[2u32, 9u32, 3u32, 2u32, 7u32]).to_owned());
    pub static SOFTWARE_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[46u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static SOFTWARE_PROGRAM_ABNORMALLY_TERMINATED: LazyLock<ProbableCause> =
        LazyLock::new(|| {
            ProbableCause::globalValue(
                Oid::new(&[&***ARF_PROBABLE_CAUSE, &[47u32]].concat())
                    .unwrap()
                    .to_owned(),
            )
        });
    pub static SOFTWARE_PROGRAM_ERROR: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[48u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static STORAGE_CAPACITY_PROBLEM: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[49u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static TEMPERATURE_UNACCEPTABLE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[50u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static THRESHOLD_CROSSED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[51u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static TIMING_PROBLEM: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[52u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static TOXIC_LEAK_DETECTED: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[53u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static TRANSMIT_FAILURE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[54u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static TRANSMITTER_FAILURE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[55u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static UNAUTHORIZED_ACCESS_ATTEMPT: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[16u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static UNDERLYING_RESOURCE_UNAVAILABLE: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[56u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static UNEXPECTED_INFORMATION: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[17u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static UNSPECIFIED_REASON: LazyLock<SecurityAlarmCause> = LazyLock::new(|| {
        SecurityAlarmCause(
            Oid::new(&[&***SECURITY_ALARM_CAUSE, &[18u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
    pub static VERSION_MISMATCH: LazyLock<ProbableCause> = LazyLock::new(|| {
        ProbableCause::globalValue(
            Oid::new(&[&***ARF_PROBABLE_CAUSE, &[57u32]].concat())
                .unwrap()
                .to_owned(),
        )
    });
}
