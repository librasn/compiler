---
source: rasn-compiler-tests/tests/parse_test.rs
input_file: rasn-compiler-tests/tests/modules/itu-t_x_x501_2016_UsefulDefinitions.asn1
---
Generated:
#[allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused,
    clippy::too_many_arguments
)]
pub mod useful_definitions {
    extern crate alloc;
    use core::borrow::Borrow;
    use rasn::prelude::*;
    use std::sync::LazyLock;
    #[doc = " EXPORTS All"]
    #[doc = " The types and values defined in this module are exported for use in the other ASN.1"]
    #[doc = " modules contained within these Directory Specifications, and for the use of other"]
    #[doc = " applications which will use them to access Directory services. Other applications"]
    #[doc = " may use them for their own purposes, but this will not constrain extensions and"]
    #[doc = " modifications needed to maintain or improve the Directory service."]
    #[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
    #[rasn(delegate)]
    pub struct ID(pub ObjectIdentifier);
    pub static ALGORITHM_OBJECT_IDENTIFIERS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[8u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ATTRIBUTE_CERTIFICATE_DEFINITIONS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[32u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static AUTHENTICATION_FRAMEWORK: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[7u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static AVL_MANAGEMENT: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[43u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static BASIC_ACCESS_CONTROL: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[24u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static CERTIFICATE_EXTENSIONS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[26u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static COMMON_PROTOCOL_SPECIFICATION: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[35u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static COSINE: LazyLock<ID> =
        LazyLock::new(
            || ID(Oid::const_new(&[0u32, 9u32, 2342u32, 19200300u32, 100u32]).to_owned()),
        );
    pub static COSINE_ATTR: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***COSINE, &[1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_ABSTRACT_SERVICE: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[2u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_IDMPROTOCOLS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[31u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_MANAGEMENT: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[27u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_OSIPROTOCOLS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[37u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_OBJECT_IDENTIFIERS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[9u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_OPERATIONAL_BINDING_TYPES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[25u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_SHADOW_ABSTRACT_SERVICE: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[15u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DIRECTORY_SHADOW_OIDS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[14u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " upperBounds                           ID ::= {module upperBounds(10) 8}"]
    #[doc = " dap                                   ID ::= {module dap(11) 8}"]
    #[doc = " dsp                                   ID ::= {module dsp(12) 8}"]
    pub static DISTRIBUTED_DIRECTORY_OIDS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[13u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DISTRIBUTED_OPERATIONS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[3u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static DS: LazyLock<ID> = LazyLock::new(|| ID(Oid::const_new(&[2u32, 5u32]).to_owned()));
    pub static DSA_OPERATIONAL_ATTRIBUTE_TYPES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[22u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ENHANCED_SECURITY: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[28u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static EXTENSION_ATTRIBUTES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[41u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static HIERARCHICAL_OPERATIONAL_BINDINGS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[20u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " directorySecurityExchanges            ID ::= {module"]
    #[doc = "                                              directorySecurityExchanges (29) 8}"]
    pub static I_DMPROTOCOL_SPECIFICATION: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[30u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " The following definition is for ASN.1 definitions moved from"]
    #[doc = " Rec. ITU-T X.660 | ISO/IEC 9834-1:"]
    pub static ID: LazyLock<ID> =
        LazyLock::new(|| ID(Oid::const_new(&[2u32, 17u32, 1u32, 2u32]).to_owned()));
    pub static ID_AC: LazyLock<ID> = LazyLock::new(|| ID(APPLICATION_CONTEXT));
    #[doc = " id-rosObject                          ID ::= rosObject"]
    #[doc = " id-contract                           ID ::= contract"]
    #[doc = " id-package                            ID ::= package"]
    pub static ID_AC_SCHEME: LazyLock<ID> = LazyLock::new(|| ID(ACCESS_CONTROL_SCHEMES));
    pub static ID_ACA: LazyLock<ID> = LazyLock::new(|| ID(ACCESS_CONTROL_ATTRIBUTE));
    pub static ID_AR: LazyLock<ID> = LazyLock::new(|| ID(ADMINISTRATIVE_ROLES));
    pub static ID_AS: LazyLock<ID> = LazyLock::new(|| ID(ABSTRACT_SYNTAX));
    #[doc = "id-lc                                  ID ::= ldapControl"]
    pub static ID_ASX: LazyLock<ID> = LazyLock::new(|| ID(ATTRIBUTE_SYNTAX));
    pub static ID_AT: LazyLock<ID> = LazyLock::new(|| ID(ATTRIBUTE_TYPE));
    pub static ID_ATS: LazyLock<ID> = LazyLock::new(|| ID(ATTRIBUTE_SYNTAX));
    pub static ID_AVC: LazyLock<ID> = LazyLock::new(|| ID(ATTRIBUTE_VALUE_CONTEXT));
    pub static ID_AVR: LazyLock<ID> = LazyLock::new(|| ID(AV_RESTRICTION));
    pub static ID_CAT: LazyLock<ID> = LazyLock::new(|| ID(CONTROL_ATTRIBUTE_TYPE));
    pub static ID_CE: LazyLock<ID> = LazyLock::new(|| ID(CERTIFICATE_EXTENSION));
    pub static ID_CMSCT: LazyLock<ID> = LazyLock::new(|| ID(CMS_CONTENT_TYPE));
    pub static ID_COAT: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***COSINE, &[1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_DOA: LazyLock<ID> = LazyLock::new(|| ID(DSA_OPERATIONAL_ATTRIBUTE));
    #[doc = " id-se                                 ID ::= securityExchange"]
    pub static ID_IDM: LazyLock<ID> = LazyLock::new(|| ID(IDM_PROTOCOL));
    pub static ID_KMR: LazyLock<ID> = LazyLock::new(|| ID(KNOWLEDGE_MATCHING_RULE));
    pub static ID_KP: LazyLock<ID> = LazyLock::new(|| ID(KEY_PURPOSES));
    pub static ID_LAT: LazyLock<ID> = LazyLock::new(|| ID(LDAP_ATTR));
    pub static ID_LDX: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***LDAP_DIR, &[15u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_LMR: LazyLock<ID> = LazyLock::new(|| ID(LDAP_MATCH));
    pub static ID_LSX: LazyLock<ID> = LazyLock::new(|| ID(LDAP_SYNTAX));
    pub static ID_MGT: LazyLock<ID> = LazyLock::new(|| ID(MANAGEMENT_OBJECT));
    pub static ID_MR: LazyLock<ID> = LazyLock::new(|| ID(MATCHING_RULE));
    pub static ID_MRE: LazyLock<ID> = LazyLock::new(|| ID(MATCHING_RESTRICTION));
    pub static ID_NF: LazyLock<ID> = LazyLock::new(|| ID(NAME_FORM));
    pub static ID_NOT: LazyLock<ID> = LazyLock::new(|| ID(NOTIFICATION));
    pub static ID_OA: LazyLock<ID> = LazyLock::new(|| ID(OPERATIONAL_ATTRIBUTE_TYPE));
    pub static ID_OAT: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***LDAP_OPEN_LDAP, &[3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static ID_OB: LazyLock<ID> = LazyLock::new(|| ID(OPERATIONAL_BINDING));
    #[doc = " synonyms"]
    pub static ID_OC: LazyLock<ID> = LazyLock::new(|| ID(OBJECT_CLASS));
    pub static ID_PQ: LazyLock<ID> = LazyLock::new(|| ID(PASSWORD_QUALITY));
    pub static ID_PR: LazyLock<ID> = LazyLock::new(|| ID(PROBLEM));
    pub static ID_SC: LazyLock<ID> = LazyLock::new(|| ID(SUBENTRY));
    pub static ID_SOA: LazyLock<ID> = LazyLock::new(|| ID(SCHEMA_OPERATIONAL_ATTRIBUTE));
    pub static ID_SOC: LazyLock<ID> = LazyLock::new(|| ID(SCHEMA_OBJECT_CLASS));
    pub static INFORMATION_FRAMEWORK: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[1u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static INT_SECURITY: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***INTERNET, &[5u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " The following defition is for ASN.1 definitions of LDAP schema"]
    pub static INTERNET: LazyLock<ID> =
        LazyLock::new(|| ID(Oid::const_new(&[1u32, 3u32, 6u32, 1u32]).to_owned()));
    pub static LDAP_DIR: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***INTERNET, &[1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static LDAP_ENTERPRISE: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***INTERNET, &[4u32, 1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static LDAP_OPEN_LDAP: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***LDAP_ENTERPRISE, &[4203u32, 1u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static LDAP_WALL: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***LDAP_ENTERPRISE, &[1466u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static LDAP_X509: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***LDAP_DIR, &[15u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static LDAP_ATTRIBUTES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[34u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static LDAP_SYSTEM_SCHEMA: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[38u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static O_SIPROTOCOL_SPECIFICATION: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[36u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " disp                                  ID ::= {module disp(16) 7}"]
    #[doc = " dop                                   ID ::= {module dop(17) 7}"]
    pub static OP_BINDING_MANAGEMENT: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[18u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static OP_BINDING_OIDS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[19u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static OPEN_LDAP_ATTRIBUTES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***LDAP_OPEN_LDAP, &[3u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static OPEN_LDAP_CONTROLS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***LDAP_OPEN_LDAP, &[10u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static PASSWORD_POLICY: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[39u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static PKI_PMI_EXTERNAL_DATA_TYPES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[40u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static PKI_PMI_WRAPPER: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[42u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static SCHEMA_ADMINISTRATION: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[23u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " protocolObjectIdentifiers             ID ::= {module protocolObjectIdentifiers(4) 8}"]
    pub static SELECTED_ATTRIBUTE_TYPES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[5u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static SELECTED_OBJECT_CLASSES: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[6u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static SERVICE_ADMINISTRATION: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[33u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    pub static TRUST_BROKER_PROTOCOL: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[44u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
    #[doc = " modules"]
    pub static USEFUL_DEFINITIONS: LazyLock<ID> = LazyLock::new(|| {
        ID(Oid::new(&[&***MODULE, &[0u32, 8u32]].concat())
            .unwrap()
            .to_owned())
    });
}
